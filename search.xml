<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/08/09/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/"/>
      <url>/2019/08/09/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="centos7系统中忘记了root管理员账号密码的解决方式"><a href="#centos7系统中忘记了root管理员账号密码的解决方式" class="headerlink" title="centos7系统中忘记了root管理员账号密码的解决方式"></a>centos7系统中忘记了root管理员账号密码的解决方式</h2><p>随着计算机的使用越来越普遍，现在的用户都会有多个密码，不是这软件的密码就是那个的，QQ、邮箱、游戏，还有系统的登录密码！每一个密码都不一样！所以越来越多的密码需要去记住！也因为这样，只要其中一个长时间不使用，就很有可能密码这个密码！然后当我们要再次使用的时候，就会很无奈的发现因为忘记密码了，无法正常使用的了！</p><p>下面分享一下，当你忘记了centos7的root管理员账号的登录密码了怎么解决</p><p>首先，打开centos7，在选择进入系统的界面按“e”进入编辑页面。</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%811.jpg" alt="img"></p><p>然后按向下键，找到以“Linux16”开头的行，在该行的最后面输入“init=/bin/sh”</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%812.jpg" alt="img"></p><p>接下来按“ctrl+X”组合键进入单用户模式</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%813.jpg" alt="img"></p><p>然后输入“ls”查询当前位置（也可以省略），回车</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%814.jpg" alt="img"></p><p>接下来再输入“mount -o remount,rw /”(注意mount与－o之间和rw与/之间的有空格)</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%815.jpg" alt="img"><br>然后再输入“passwd”回车</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%816.jpg" alt="img"></p><p>接下来就是修改你的root账号密码了，重复输入一个不少于8位的密码（密码在输入的时候是不显示的，看起来就像没反应一样，只需要正确输入并回车就可以）</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%817.jpg" alt="img"></p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%818.jpg" alt="img"><br>接下来再输入touch /.autorelabel,回车</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%819.jpg" alt="img"></p><p>输入exec /sbin/init,回车</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%8110.jpg" alt="img"></p><p>回车后出现下面的界面，这里稍微等几分钟，系统会自动重启</p><p>接下来就等系统重启然后进入查看是否已经修改成功了</p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%8111.jpg" alt="img"></p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%8112.jpg" alt="img"></p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%8113.jpg" alt="img"></p><p><img src="assets%5C%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%8114.jpg" alt="img"></p><p>觉得有用记得点击关注加收，方便以后遇到时可用<del>~</del></p><p>原文<a href="https://baijiahao.baidu.com/s?id=1614000108255096283&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1614000108255096283&amp;wfr=spider&amp;for=pc</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/Webbench%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/08/09/Webbench%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Web性能压力测试之Webbench使用详解"><a href="#Web性能压力测试之Webbench使用详解" class="headerlink" title="Web性能压力测试之Webbench使用详解"></a><a href="https://www.cnblogs.com/fjping0606/p/5852049.html" target="_blank" rel="noopener">Web性能压力测试之Webbench使用详解</a></h1><p>Webbench是知名的网站压力测试工具，它是由Lionbridge公司（<a href="http://www.lionbridge.com）开发。" target="_blank" rel="noopener">http://www.lionbridge.com）开发。</a><br>Webbench能测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。webbench的标准测试可以向我们展示服务器的两项内容：每秒钟相应请求数和每秒钟传输数据量。webbench不但能具有便准静态页面的测试能力，还能对动态页面（ASP,PHP,JAVA,CGI）进 行测试的能力。还有就是他支持对含有SSL的安全网站例如电子商务网站进行静态或动态的性能测试。<br>Webbench最多可以模拟3万个并发连接去测试网站的负载能力。<br>官方主页：<a href="http://home.tiscali.cz/~cz210552/webbench.html" target="_blank" rel="noopener">http://home.tiscali.cz/~cz210552/webbench.html</a><br>官方介绍：<br>Web Bench is very simple tool for benchmarking WWW or proxy servers. Uses fork() for simulating multiple clients and can use HTTP/0.9-HTTP/1.1 requests. This benchmark is not very realistic, but it can test if your HTTPD can realy handle that many clients at once (try to run some CGIs) without taking your machine down. Displays pages/min and bytes/sec. Can be used in more aggressive mode with -f switch.</p><h3 id="1-WebBench安装"><a href="#1-WebBench安装" class="headerlink" title="1.WebBench安装"></a>1.WebBench安装</h3><ul><li><p>yum install -y gcc ctags</p></li><li><p>wget <a href="http://www.ha97.com/code/webbench-1.5.tar.gz" target="_blank" rel="noopener">http://www.ha97.com/code/webbench-1.5.tar.gz</a></p></li><li><p>tar zxvf webbench-1.5.tar.gz</p></li><li><p>cd webbench-1.5</p></li><li><p>make</p></li><li><p>make install</p></li></ul><h3 id="2-WebBench使用"><a href="#2-WebBench使用" class="headerlink" title="2.WebBench使用"></a>2.WebBench使用</h3><p>webbench -c 1000 -t 60 <a href="http://test.domain.com/phpinfo.php" target="_blank" rel="noopener">http://test.domain.com/phpinfo.php</a><br>webbench -c 并发数 -t 运行测试时间 URL</p><h3 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3.测试结果"></a>3.测试结果</h3><p>当并发300时:<br>向<a href="http://test.domain.com/phpinfo.php发起300个线程请求，持续时间60秒" target="_blank" rel="noopener">http://test.domain.com/phpinfo.php发起300个线程请求，持续时间60秒</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webbench -c 300 -t 60 http://test.domain.com/phpinfo.php</span><br></pre></td></tr></table></figure><p>Webbench - Simple Web Benchmark 1.5<br>Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.</p><p>Benchmarking: GET <a href="http://test.domain.com/phpinfo.php" target="_blank" rel="noopener">http://test.domain.com/phpinfo.php</a><br>300 clients, running 60 sec.</p><p>Speed=24525 pages/min, 20794612 bytes/sec.<br>Requests: 24525 susceed, 0 failed.<br>速度：每秒钟响应请求数：24525 pages/min，每秒钟传输数据量20794612 bytes/sec.<br>返回数：24525次返回成功，0次返回失败</p><p>当并发1000时:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webbench -c 1000 -t 60 http://test.domain.com/phpinfo.php</span><br></pre></td></tr></table></figure><p>Webbench - Simple Web Benchmark 1.5<br>Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.</p><p>Benchmarking: GET <a href="http://test.domain.com/phpinfo.php" target="_blank" rel="noopener">http://test.domain.com/phpinfo.php</a><br>1000 clients, running 60 sec.</p><p>Speed=24920 pages/min, 21037312 bytes/sec.<br>Requests: 24833 susceed, 87 failed.</p><p>当并发1000时，已经显示有87个连接failed了，说明超负荷了。</p><p>备注：<br>1、压力测试工作应该放到产品上线之前进行<br>2、测试时尽量跨公网模拟正式环境进行<br>3、测试时并发应当由小逐渐加大，比如并发100时观察一下网站负载是多少、打开是否流程，并发200时又是多少、网站打开缓慢时并发是多少、网站打不开时并发又是多少</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/uwsgi%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/08/09/uwsgi%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx和uwsgi的区别和作用："><a href="#nginx和uwsgi的区别和作用：" class="headerlink" title="nginx和uwsgi的区别和作用："></a>nginx和uwsgi的区别和作用：</h1><p>Django+uwsgi+nginx</p><p>nginx和uwsgi的区别和作用：</p><p>1, nginx是对外的服务器，外部浏览器通过url访问nginx, uwsgi是对内的服务器，主要用来处理动态请求。</p><p>2, nginx接收到浏览器发送过来的http请求，将包进行解析，分析url， a.如果是静态文件请求就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件， b.如果不是静态文件，而是一个动态的请求，那么nginx就将请求转发给uwsgi,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uwsgi接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi,</span><br><span class="line">wsgi根据请求调用应用程序的某个文件，某个文件的某个函数，最后处理完将</span><br><span class="line">返回值再次交给wsgi,wsgi将返回值进行打包，打包成uwsgi能够接收的格式，</span><br><span class="line">uwsgi接收wsgi发送的请求，并转发给nginx,nginx最终将返回值返回给浏览器。</span><br></pre></td></tr></table></figure><h1 id="uwsgi概念和作用"><a href="#uwsgi概念和作用" class="headerlink" title="uwsgi概念和作用"></a>uwsgi概念和作用</h1><h4 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h4><p>WSGI是一种WEB服务器==网关接口==。 是一个Web服务器（如nginx）与应用服务器（如uWSGI）通信的一种规范（协议）。</p><p>在生产环境中使用WSGI作为python web的服务器。Python Web服务器网关接口，是Python应用程序或框架和Web服务器之间的一种接口，被广泛接受。WSGI没有官方的实现, 因为WSGI更像一个协议，只要遵照这些协议，WSGI应用(Application)都可以在任何服务器(Server)上运行。</p><h3 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a>uWSGI</h3><p>uWSGI实现了WSGI的所有接口，是一个快速、自我修复、开发人员和系统管理员友好的服务器。uWSGI代码完全用C编写，效率高、性能稳定。</p><p>uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>Django 是一个 Web 框架，框架的作用在于处理 request 和 reponse，其他的不是框架所关心的内容。所以怎么部署 Django 不是 Django 所需要关心的。</p><p>Django 所提供的是一个开发服务器，这个开发服务器，没有经过安全测试，而且使用的是 Python 自带的 simple HTTPServer 创建的，在安全性和效率上都是不行的</p><p>而uWSGI 是一个全功能的 HTTP 服务器，他要做的就是把 HTTP 协议转化成语言支持的网络协议。比如把 HTTP 协议转化成 WSGI 协议，让 Python 可以直接使用。<br>uwsgi 是一种 uWSGI 的内部协议，使用二进制方式和其他应用程序进行通信。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/uwsgi%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/08/09/uwsgi%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-安装uwsgi"><a href="#linux-安装uwsgi" class="headerlink" title="linux 安装uwsgi"></a>linux 安装uwsgi</h1><h3 id="安装并查看版本"><a href="#安装并查看版本" class="headerlink" title="安装并查看版本"></a>安装并查看版本</h3><ul><li><p>yum groupinstall “Development tools”</p></li><li><p>yum install zlib-devel bzip2-devel pcre-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel</p></li><li><p>yum install python-devel</p></li><li><p>yum install gcc</p><ul><li>安装gcc编译器。</li></ul></li><li><p>pip3 install uwsgi</p><ul><li><p>安装uwsig可以尝试其他下载源</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install uwsgi -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider</span><br></pre></td></tr></table></figure></li><li><p>在这里我用的是pip3 这看大家用的是那种pip3 根据实际情况使用</p></li></ul></li><li><p>uwsgi –version</p><ul><li><p>报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon /]<span class="comment"># uwsgi --version</span></span><br><span class="line">-bash: uwsgi: command <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure></li><li><p>解决：</p><blockquote><p>查看位置： find / -name uwsgi</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon /]<span class="comment"># find / -name uwsgi</span></span><br><span class="line">/usr/local/python3/bin/uwsgi</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>&gt; 配置软连接：   ps:软连接在这只作为解决方法 可能大家的python路径都不同酌情安装<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</span><br></pre></td></tr></table></figure>&gt;配置软连之后可以再任何地方运行 uwsgi&gt; 再次查看版本号<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># uwsgi --version</span></span><br><span class="line"><span class="number">2.0</span><span class="number">.18</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="uwsig测试"><a href="#uwsig测试" class="headerlink" title="uwsig测试"></a>uwsig测试</h3><ul><li><p>普通文件测试</p><ul><li><p><strong>测试uwsgi，创建test.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(env, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b"Hello uwsgi!"</span>]</span><br></pre></td></tr></table></figure></li><li><p><strong>uwsgi运行该文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --http-socket :<span class="number">8088</span> --wsgi-file test.py</span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置uwsig.ini 启动</p><ul><li><p><strong>测试uwsgi，创建test.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(env, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b"Hello uwsgi!"</span>]</span><br></pre></td></tr></table></figure></li><li><p><strong>任意地方创建uwsgi.ini，内容如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">http-socket= :<span class="number">8088</span></span><br><span class="line">chdir=/home/xlf</span><br><span class="line">wsgi-file=test.py</span><br></pre></td></tr></table></figure><blockquote><p>下面是文件内配置文件的内容：</p></blockquote><p>文件里面的字段意思:</p><ul><li>socket ：指定项目执行的端口号 <ul><li>用nginx的时候就配socket , 直接运行的时候配 http</li></ul></li><li>chadir :指定项目的目录</li><li>module ：可以这么来理解，对于- myweb_uwsgi.ini文件来说，与它的平级的有一个partner目录，这个目录下有一个wsgi.py文件</li><li>master :允许主线程存在（true）</li><li>processes:开启的进程数量（这里是开启4个进程）</li><li>vacuum :当服务器退出的时候自动清理环境，删除unix socket文件和pid文件</li><li>原文：<a href="https://www.jianshu.com/p/f3fd1f831729" target="_blank" rel="noopener">https://www.jianshu.com/p/f3fd1f831729</a></li></ul></li><li><p><strong>到uwsgi.ini目录下</strong></p><p>执行 uwsgi –ini ./uwsgi.ini</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/Nginx+uwsgi%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/08/09/Nginx+uwsgi%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-Nginx-uwsgi-安装配置"><a href="#Django-Nginx-uwsgi-安装配置" class="headerlink" title="Django Nginx+uwsgi 安装配置"></a>Django Nginx+uwsgi 安装配置</h1><p>在前面的章节中我们使用 <strong>python manage.py runserver</strong> 来运行服务器。这只适用测试环境中使用。</p><p>正式发布的服务，我们需要一个可以稳定而持续的服务器，比如apache, Nginx, lighttpd等，本文将以 Nginx 为例。</p><blockquote><p>你也可以直接参考：<a href="https://www.runoob.com/python3/python-uwsgi.html" target="_blank" rel="noopener">Python uwsgi 安装配置</a></p></blockquote><hr><h2 id="安装基础开发包"><a href="#安装基础开发包" class="headerlink" title="安装基础开发包"></a>安装基础开发包</h2><p>Centos 下安装步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;Development tools&quot;</span><br><span class="line">yum install zlib-devel bzip2-devel pcre-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel</span><br></pre></td></tr></table></figure><p>CentOS 自带 Python 2.4.3，但我们可以再安装Python2.7.5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget http://python.org/ftp/python/2.7.5/Python-2.7.5.tar.bz2</span><br><span class="line">tar xvf Python-2.7.5.tar.bz2</span><br><span class="line">cd Python-2.7.5</span><br><span class="line">./configure --prefix=/usr/local</span><br><span class="line">make &amp;&amp; make altinstall</span><br></pre></td></tr></table></figure><h3 id="安装Python包管理"><a href="#安装Python包管理" class="headerlink" title="安装Python包管理"></a>安装Python包管理</h3><p>easy_install 包 <a href="https://pypi.python.org/pypi/distribute" target="_blank" rel="noopener">https://pypi.python.org/pypi/distribute</a></p><p>安装步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget https://pypi.python.org/packages/source/d/distribute/distribute-0.6.49.tar.gz</span><br><span class="line">tar xf distribute-0.6.49.tar.gz</span><br><span class="line">cd distribute-0.6.49</span><br><span class="line">python2.7 setup.py install</span><br><span class="line">easy_install --version</span><br></pre></td></tr></table></figure><p>pip 包: <a href="https://pypi.python.org/pypi/pip" target="_blank" rel="noopener">https://pypi.python.org/pypi/pip</a></p><p>安装 pip 的好处是可以用 pip list、pip uninstall 管理 Python 包， easy_install 没有这个功能，只有 uninstall。</p><hr><h2 id="安装-uwsgi"><a href="#安装-uwsgi" class="headerlink" title="安装 uwsgi"></a>安装 uwsgi</h2><p>uwsgi:<a href="https://pypi.python.org/pypi/uWSGI" target="_blank" rel="noopener">https://pypi.python.org/pypi/uWSGI</a></p><p>uwsgi 参数详解：<a href="http://uwsgi-docs.readthedocs.org/en/latest/Options.html" target="_blank" rel="noopener">http://uwsgi-docs.readthedocs.org/en/latest/Options.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install uwsgi</span><br><span class="line">uwsgi --version    # 查看 uwsgi 版本</span><br></pre></td></tr></table></figure><p>测试 uwsgi 是否正常：</p><p>新建 test.py 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def application(env, start_response):</span><br><span class="line">    start_response(&apos;200 OK&apos;, [(&apos;Content-Type&apos;,&apos;text/html&apos;)])</span><br><span class="line">    return &quot;Hello World&quot;</span><br></pre></td></tr></table></figure><p>然后在终端运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --http :8001 --wsgi-file test.py</span><br></pre></td></tr></table></figure><p>在浏览器内输入：<a href="http://127.0.0.1:8001，查看是否有&quot;Hello" target="_blank" rel="noopener">http://127.0.0.1:8001，查看是否有&quot;Hello</a> World”输出，若没有输出，请检查你的安装过程。</p><hr><h2 id="安装-Django"><a href="#安装-Django" class="headerlink" title="安装 Django"></a>安装 Django</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django</span><br></pre></td></tr></table></figure><p>测试 django 是否正常，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django-admin.py startproject demosite</span><br><span class="line">cd demosite</span><br><span class="line">python2.7 manage.py runserver 0.0.0.0:8002</span><br></pre></td></tr></table></figure><p>在浏览器内输入：<a href="http://127.0.0.1:8002，检查django是否运行正常。" target="_blank" rel="noopener">http://127.0.0.1:8002，检查django是否运行正常。</a></p><hr><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><p>安装命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">wget http://nginx.org/download/nginx-1.5.6.tar.gz</span><br><span class="line">tar xf nginx-1.5.6.tar.gz</span><br><span class="line">cd nginx-1.5.6</span><br><span class="line">./configure --prefix=/usr/local/nginx-1.5.6 \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_gzip_static_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>你可以阅读 <a href="https://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="noopener">Nginx 安装配置</a> 了解更多内容。</p><hr><h2 id="uwsgi-配置"><a href="#uwsgi-配置" class="headerlink" title="uwsgi 配置"></a>uwsgi 配置</h2><p>uwsgi支持ini、xml等多种配置方式，本文以 ini 为例， 在/etc/目录下新建uwsgi9090.ini，添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:9090</span><br><span class="line">master = true         //主进程</span><br><span class="line">vhost = true          //多站模式</span><br><span class="line">no-site = true        //多站模式时不设置入口模块和文件</span><br><span class="line">workers = 2           //子进程数</span><br><span class="line">reload-mercy = 10     </span><br><span class="line">vacuum = true         //退出、重启时清理文件</span><br><span class="line">max-requests = 1000   </span><br><span class="line">limit-as = 512</span><br><span class="line">buffer-size = 30000</span><br><span class="line">pidfile = /var/run/uwsgi9090.pid    //pid文件，用于下面的脚本启动、停止该进程</span><br><span class="line">daemonize = /website/uwsgi9090.log</span><br></pre></td></tr></table></figure><hr><h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><p>找到nginx的安装目录（如：/usr/local/nginx/），打开conf/nginx.conf文件，修改server配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        location / &#123;            </span><br><span class="line">            include  uwsgi_params;</span><br><span class="line">            uwsgi_pass  127.0.0.1:9090;              //必须和uwsgi中的设置一致</span><br><span class="line">            uwsgi_param UWSGI_SCRIPT demosite.wsgi;  //入口文件，即wsgi.py相对于项目根目录的位置，“.”相当于一层目录</span><br><span class="line">            uwsgi_param UWSGI_CHDIR /demosite;       //项目根目录</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            client_max_body_size 35m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>你可以阅读 <a href="https://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="noopener">Nginx 安装配置</a> 了解更多内容。</p><p>设置完成后，在终端运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --ini /etc/uwsgi9090.ini &amp;</span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>在浏览器输入：<a href="http://127.0.0.1，你就可以看到" target="_blank" rel="noopener">http://127.0.0.1，你就可以看到</a> django 的 “It work” 了。</p><p> <a href="https://www.runoob.com/django/django-admin-manage-tool.html" target="_blank" rel="noopener">Django Admin 管理工具</a></p><h2 id="2-篇笔记-写笔记"><a href="#2-篇笔记-写笔记" class="headerlink" title="2 篇笔记 写笔记"></a>2 篇笔记 写笔记</h2><ol><li><p>安装 uwsgi 如果失败，有可能是缺少Python的头文件和静态库，需要安装开发版本：</p><p>   For apt (Ubuntu, Debian…):</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev   # for python2.x installs</span><br><span class="line">    sudo apt-get install python3-dev  # for python3.x installs</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">For yum (CentOS, RHEL...):</span><br></pre></td></tr></table></figure><p>   sudo yum install python-devel<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">For dnf (Fedora...):</span><br></pre></td></tr></table></figure></p><p>sudo dnf install python2-devel  # for python2.x installs<br>   sudo dnf install python3-devel  # for python3.x installs<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">For zypper (openSUSE...):</span><br></pre></td></tr></table></figure></p><p>   sudo zypper in python-devel   # for python2.x installs<br>   sudo zypper in python3-devel  # for python3.x installs<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">2. 非多站模式时 **vhost = true** 和 **no-site = true** 需要注释掉，否则后续 nginx 配置文件中设置的入口文件则不生效，服务器会回应 **Internal Server error**：</span><br></pre></td></tr></table></figure></p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1:9090</span><br><span class="line">master = true         //主进程</span><br><span class="line"></span><br><span class="line">vhost = true          //多站模式</span><br><span class="line"></span><br><span class="line">no-site = true        //多站模式时不设置入口模块和文件</span><br><span class="line"></span><br><span class="line">workers = 2           //子进程数</span><br><span class="line">reload-mercy = 10     </span><br><span class="line">vacuum = true         //退出、重启时清理文件</span><br><span class="line">max-requests = 1000   </span><br><span class="line">limit-as = 512</span><br><span class="line">buffer-size = 30000</span><br><span class="line">pidfile = /var/run/uwsgi9090.pid    //pid文件，用于下面的脚本启动、停止该进程</span><br><span class="line">daemonize = /website/uwsgi9090.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/Linux%E4%BF%AE%E6%94%B9pip%E4%B8%8B%E8%BD%BD%E6%BA%90/"/>
      <url>/2019/08/09/Linux%E4%BF%AE%E6%94%B9pip%E4%B8%8B%E8%BD%BD%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下永久更换镜像源"><a href="#Linux下永久更换镜像源" class="headerlink" title="Linux下永久更换镜像源"></a>Linux下永久更换镜像源</h1><p><strong>需要修改~/ .pip/pip.conf</strong></p><ul><li><p>cd~</p></li><li><p>mkdir pip</p></li><li><p>cd pip</p></li><li><p>vi pip.conf</p></li><li><p>在pip.conf中，添加配置内容</p><ul><li>i 进入插入状态</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">timeout = <span class="number">6000</span></span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">trusted-host = pypi.douban.com</span><br></pre></td></tr></table></figure><ul><li>保存退出<ul><li>Esc</li><li>shift + :</li><li>wq                  </li></ul></li></ul></li></ul><p><strong>然后就修改完毕了！</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/Linux%E4%B8%8BScrapyd%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/08/09/Linux%E4%B8%8BScrapyd%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ss-py/p/9661928.html" target="_blank" rel="noopener">https://www.cnblogs.com/ss-py/p/9661928.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/Linux%E4%B8%8BMysql%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/08/09/Linux%E4%B8%8BMysql%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Mysql-数据库重置密码步骤"><a href="#Linux-Mysql-数据库重置密码步骤" class="headerlink" title="Linux-Mysql 数据库重置密码步骤"></a>Linux-Mysql 数据库重置密码步骤</h1><p>第一步：cat /var/log/mysqld.log |grep “password”</p><p>第二步：set password = password(“123456”);</p><p>第三步：set global validate_password_policy=0;</p><p>第四步：set global validate_password_length=1;</p><p>第五步：alter user ‘root’@’localhost’ password expire never;</p><p>第六步：flush privileges;</p><p>第七步：exit;</p><p>拓展：</p><p>第一步：pip install flask-sqlalchemy</p><p>第二步：yum -y install mysql-devel gcc gcc-devel python-devel</p><p>第三步：pip install mysqlclient</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/Linux%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8/"/>
      <url>/2019/08/09/Linux%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>linux下的文件结构，看看每个文件夹都是干吗用的<br>/bin 二进制可执行命令<br>/dev 设备特殊文件<br>/etc 系统管理和配置文件<br>/etc/rc.d 启动的配置文件和脚本<br>/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示<br>/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件<br>/sbin 系统管理命令，这里存放的是系统管理员使用的管理程序<br>/tmp 公用的临时文件存储点<br>/root 系统管理员的主目录（呵呵，特权阶级）<br>/mnt 系统提供这个目录是让用户临时挂载其他的文件系统。<br>/lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里<br>/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。<br>/var 某些大文件的溢出区，比方说各种服务的日志文件<br>/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：<br>/usr/x11r6 存放x window的目录<br>/usr/bin 众多的应用程序<br>/usr/sbin 超级用户的一些管理程序<br>/usr/doc linux文档<br>/usr/include linux下开发和编译应用程序所需要的头文件<br>/usr/lib 常用的动态链接库和软件包的配置文件<br>/usr/man 帮助文档<br>/usr/src 源代码，linux内核的源代码就放在/usr/src/linux里<br>/usr/local/bin 本地增加的命令<br>/usr/local/lib 本地增加的库</p><p>通常情况下，根文件系统所占空间一般应该比较小，因为其中的绝大部分文件都不需要<br>经常改动，而且包括严格的文件和一个小的不经常改变的文件系统不容易损坏。<br>除了可能的一个叫/ v m l i n u z标准的系统引导映像之外，根目录一般不含任何文件。所有<br>其他文件在根文件系统的子目录中。 </p><ol><li>/bin目录<br>/ b i n目录包含了引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。这些<br>命令都是二进制文件的可执行程序( b i n是b i n a r y - -二进制的简称)，多是系统中重要的系统文件。 </li><li>/sbin目录<br>/ s b i n目录类似/bin ，也用于存储二进制文件。因为其中的大部分文件多是系统管理员使<br>用的基本的系统程序，所以虽然普通用户必要且允许时可以使用，但一般不给普通用户使用。 </li><li>/etc目录<br>/ e t c目录存放着各种系统配置文件，其中包括了用户信息文件/ e t c / p a s s w d，系统初始化文<br>件/ e t c / r c等。l i n u x正是*这些文件才得以正常地运行。 </li><li>/root目录<br>/root 目录是超级用户的目录。 </li><li>/lib目录<br>/ l i b目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文<br>件。这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副<br>本，故可以使得可执行文件变得更小，节省空间。 </li><li>/lib/modules 目录<br>/lib/modules 目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重新引<br>导系统所需的模块(例如网络和文件系统驱动)。 </li><li>/dev目录<br>/ d e v目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用<br>户可以通过访问/ d e v / m o u s e来访问鼠标的输入，就像访问其他文件一样。 </li><li>/tmp目录<br>/tmp 目录存放程序在运行时产生的信息和数据。但在引导启动后，运行的程序最好使用<br>/ v a r / t m p来代替/tmp ，因为前者可能拥有一个更大的磁盘空间。 </li><li>/boot目录<br>/ b o o t目录存放引导加载器(bootstrap loader)使用的文件，如l i l o，核心映像也经常放在这里，<br>而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的<br>文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在i d e硬盘的前1 0 2 4柱面内。 </li><li>/mnt目录<br>/ m n t目录是系统管理员临时安装( m o u n t )文件系统的安装点。程序并不自动支持安装到<br>/mnt 。/mnt 下面可以分为许多子目录，例如/mnt/dosa 可能是使用m s d o s文件系统的软驱，<br>而/mnt/exta 可能是使用e x t 2文件系统的软驱，/mnt/cdrom 光驱等等。 </li><li>/proc, /usr,/var,/home目录<br>其他文件系统的安装点。 </li></ol><p>下面详细介绍； </p><p>/etc文件系统<br>/etc 目录包含各种系统配置文件，下面说明其中的一些。其他的你应该知道它们属于哪个<br>程序，并阅读该程序的m a n页。许多网络配置文件也在/etc 中。 </p><ol><li>/etc/rc或/etc/rc.d或/etc/rc?.d<br>启动、或改变运行级时运行的脚本或脚本的目录。 </li><li>/etc/passwd<br>用户数据库，其中的域给出了用户名、真实姓名、用户起始目录、加密口令和用户的其<br>他信息。 </li><li>/etc/fdprm<br>软盘参数表，用以说明不同的软盘格式。可用setfdprm 进行设置。更多的信息见s e t f d p r m<br>的帮助页。 </li><li>/etc/fstab<br>指定启动时需要自动安装的文件系统列表。也包括用swapon -a启用的s w a p区的信息。 </li><li>/etc/group<br>类似/etc/passwd ，但说明的不是用户信息而是组的信息。包括组的各种数据。 </li><li>/etc/inittab<br>init 的配置文件。 </li><li>/etc/issue<br>包括用户在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。具体内<br>容由系统管理员确定。 </li><li>/etc/magic<br>“f i l e”的配置文件。包含不同文件格式的说明，“f i l e”基于它猜测文件类型。 </li><li>/etc/motd<br>m o t d是message of the day的缩写，用户成功登录后自动输出。内容由系统管理员确定。<br>常用于通告信息，如计划关机时间的警告等。 </li><li>/etc/mtab<br>当前安装的文件系统列表。由脚本( s c r i t p )初始化，并由mount 命令自动更新。当需要一<br>个当前安装的文件系统的列表时使用(例如df 命令)。 </li><li>/etc/shadow<br>在安装了影子( s h a d o w )口令软件的系统上的影子口令文件。影子口令文件将/ e t c / p a s s w d<br>文件中的加密口令移动到/ e t c / s h a d o w中，而后者只对超级用户( r o o t )可读。这使破译口令更困<br>难，以此增加系统的安全性。 </li><li>/etc/login.defs<br>l o g i n命令的配置文件。 </li><li>/etc/printcap<br>类似/etc/termcap ，但针对打印机。语法不同。 </li><li>/etc/profile 、/ e t c / c s h . l o g i n、/etc/csh.cshrc<br>登录或启动时b o u r n e或c shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。 </li><li>/etc/securetty<br>确认安全终端，即哪个终端允许超级用户( r o o t )登录。一般只列出虚拟控制台，这样就不<br>可能(至少很困难)通过调制解调器( m o d e m )或网络闯入系统并得到超级用户特权。 </li><li>/etc/shells<br>列出可以使用的s h e l l。chsh 命令允许用户在本文件指定范围内改变登录的s h e l l。提供一<br>台机器f t p服务的服务进程ftpd 检查用户s h e l l是否列在/etc/shells 文件中，如果不是，将不允<br>许该用户登录。 </li><li>/etc/termcap<br>终端性能数据库。说明不同的终端用什么“转义序列”控制。写程序时不直接输出转义<br>序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。<br>这样，多数的程序可以在多数终端上运行。 </li></ol><p>/dev文件系统<br>/dev 目录包括所有设备的设备文件。设备文件用特定的约定命名，这在设备列表中说明。<br>设备文件在安装时由系统产生，以后可以用/dev/makedev 描述。/ d e v / m a k e d e v.local 是<br>系统管理员为本地设备文件(或连接)写的描述文稿(即如一些非标准设备驱动不是标准<br>makedev 的一部分)。下面简要介绍/ d e v下一些常用文件。 </p><ol><li>/dev/console<br>系统控制台，也就是直接和系统连接的监视器。 </li><li>/dev/hd<br>i d e硬盘驱动程序接口。如： / d e v / h d a指的是第一个硬盘， h a d 1则是指/ d e v / h d a的第一个<br>分区。如系统中有其他的硬盘，则依次为/ d e v / h d b、/ d e v / h d c、. . . . . .；如有多个分区则依次为<br>h d a 1、h d a 2 . . . . . . </li><li>/dev/sd<br>s c s i磁盘驱动程序接口。如有系统有s c s i硬盘，就不会访问/ d e v / h a d，而会访问/ d e v / s d a。 </li><li>/dev/fd<br>软驱设备驱动程序。如： / d e v / f d 0指系统的第一个软盘，也就是通常所说的a：盘，<br>/ d e v / f d 1指第二个软盘，. . . . . .而/ d e v / f d 1 h 1 4 4 0则表示访问驱动器1中的4 . 5高密盘。 </li><li>/dev/st<br>s c s i磁带驱动器驱动程序。 </li><li>/dev/tty<br>提供虚拟控制台支持。如： / d e v / t t y 1指的是系统的第一个虚拟控制台， / d e v / t t y 2则是系统<br>的第二个虚拟控制台。 </li><li>/dev/pty<br>提供远程登陆伪终端支持。在进行te l n e t登录时就要用到/ d e v / p t y设备。 </li><li>/dev/ttys<br>计算机串行接口，对于d o s来说就是“ c o m 1”口。 </li><li>/dev/cua<br>计算机串行接口，与调制解调器一起使用的设备。 </li><li>/dev/null<br>“黑洞”，所有写入该设备的信息都将消失。例如：当想要将屏幕上的输出信息隐藏起来<br>时，只要将输出信息输入到/ d e v / n u l l中即可。 </li></ol><p>/usr文件系统<br>/usr 是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr 里的<br>所有文件一般来自l i n u x发行版( d i s t r i b u t i o n )；本地安装的程序和其他东西在/usr/local 下，因为这样可以在升级新版系统或新发行版时无须重新安装全部程序。/usr 目录下的许多内容是<br>可选的，但这些功能会使用户使用系统更加有效。/ u s r可容纳许多大型的软件包和它们的配置<br>文件。下面列出一些重要的目录(一些不太重要的目录被省略了)。 </p><ol><li>/usr/x11r6<br>包含x wi n d o w系统的所有可执行程序、配置文件和支持文件。为简化x的开发和安装，<br>x的文件没有集成到系统中。x wi n d o w系统是一个功能强大的图形环境，提供了大量的图形<br>工具程序。用户如果对microsoft wi n d o w s或m a c h i n t o s h比较熟悉的话，就不会对x wi n d o w系统感到束手无策了。 </li><li>/usr/x386<br>类似/ u s r / x 11r6 ，但是是专门给x 11 release 5的。 </li><li>/usr/bin<br>集中了几乎所有用户命令，是系统的软件库。另有些命令在/bin 或/usr/local/bin 中。 </li><li>/usr/sbin<br>包括了根文件系统不必要的系统管理命令，例如多数服务程序。 </li><li>/usr/man、/ u s r / i n f o、/ u s r / d o c<br>这些目录包含所有手册页、g n u信息文档和各种其他文档文件。每个联机手册的“节”<br>都有两个子目录。例如： / u s r / m a n / m a n 1中包含联机手册第一节的源码(没有格式化的原始文<br>件)，/ u s r / m a n / c a t 1包含第一节已格式化的内容。l联机手册分为以下九节：内部命令、系统调<br>用、库函数、设备、文件格式、游戏、宏软件包、系统管理和核心程序。 </li><li>/usr/include<br>包含了c语言的头文件，这些文件多以. h结尾，用来描述c语言程序中用到的数据结构、<br>子过程和常量。为了保持一致性，这实际上应该放在/usr/lib 下，但习惯上一直沿用了这个名<br>字。 </li><li>/usr/lib<br>包含了程序或子系统的不变的数据文件，包括一些s i t e - w i d e配置文件。名字l i b来源于库<br>(library); 编程的原始库也存在/usr/lib 里。当编译程序时，程序便会和其中的库进行连接。也<br>有许多程序把配置文件存入其中。 </li><li>/usr/local<br>本地安装的软件和其他文件放在这里。这与/ u s r很相似。用户可能会在这发现一些比较大<br>的软件包，如t e x、e m a c s等。 </li></ol><p>/var文件系统<br>/var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化<br>或扩充的。原来/ v a r目录中有些内容是在/ u s r中的，但为了保持/ u s r目录的相对稳定，就把那<br>些需要经常改变的目录放到/ v a r中了。每个系统是特定的，即不通过网络与其他计算机共享。<br>下面列出一些重要的目录(一些不太重要的目录省略了)。 </p><ol><li>/var/catman<br>包括了格式化过的帮助( m a n )页。帮助页的源文件一般存在/ u s r / m a n / m a n中；有些m a n页<br>可能有预格式化的版本，存在/ u s r / m a n / c a t中。而其他的m a n页在第一次看时都需要格式化，<br>格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。<br>(/var/catman 经常被清除，就像清除临时目录一样。) </li><li>/var/lib<br>存放系统正常运行时要改变的文件。 </li><li>/var/local<br>存放/usr/local 中安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，<br>即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。 </li><li>/var/lock<br>锁定文件。许多程序遵循在/var/lock 中产生一个锁定文件的约定，以用来支持他们正在<br>使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文<br>件。 </li><li>/var/log<br>各种程序的日志( l o g )文件，尤其是login (/var/log/wtmp log纪录所有到系统的登录和注<br>销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息)。/var/log 里的文件经常不<br>确定地增长，应该定期清除。 </li><li>/var/run<br>保存在下一次系统引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登<br>录的用户的信息。 </li><li>/var/spool<br>放置“假脱机( s p o o l )”程序的目录，如m a i l、n e w s、打印队列和其他队列工作的目录。每<br>个不同的s p o o l在/var/spool 下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中。 </li><li>/var/tmp<br>比/tmp 允许更大的或需要存在较长时间的临时文件。<br>注意系统管理员可能不允许/var/tmp 有很旧的文件。 </li></ol><p>/proc文件系统<br>/proc 文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一<br>个非常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提<br>供关于系统的信息。下面说明一些最重要的文件和目录(/proc 文件系统在proc man页中有更详<br>细的说明)。 </p><ol><li>/proc/x<br>关于进程x的信息目录，这一x是这一进程的标识号。每个进程在/proc 下有一个名为自<br>己进程号的目录。 </li><li>/proc/cpuinfo<br>存放处理器( c p u )的信息，如c p u的类型、制造商、型号和性能等。 </li><li>/proc/devices<br>当前运行的核心配置的设备驱动的列表。 </li><li>/proc/dma<br>显示当前使用的d m a通道。 </li><li>/proc/filesystems<br>核心配置的文件系统信息。 </li><li>/proc/interrupts<br>显示被占用的中断信息和占用者的信息，以及被占用的数量。 </li><li>/proc/ioports<br>当前使用的i / o端口。 </li><li>/proc/kcore<br>系统物理内存映像。与物理内存大小完全一样，然而实际上没有占用这么多内存；它仅<br>仅是在程序访问它时才被创建。(注意：除非你把它拷贝到什么地方，否则/proc 下没有任何<br>东西占用任何磁盘空间。) </li><li>/proc/kmsg<br>核心输出的消息。也会被送到s y s l o g。 </li><li>/proc/ksyms<br>核心符号表。 </li><li>/proc/loadavg<br>系统“平均负载”； 3个没有意义的指示器指出系统当前的工作量。 </li><li>/proc/meminfo<br>各种存储器使用信息，包括物理内存和交换分区( s w a p )。 </li><li>/proc/modules<br>存放当前加载了哪些核心模块信息。 </li><li>/proc/net<br>网络协议状态信息。 </li><li>/proc/self<br>存放到查看/proc 的程序的进程目录的符号连接。当2个进程查看/proc 时，这将会是不同<br>的连接。这主要便于程序得到它自己的进程目录。 </li><li>/proc/stat<br>系统的不同状态，例如，系统启动后页面发生错误的次数。 </li><li>/proc/uptime<br>系统启动的时间长度。 </li><li>/proc/version<br>核心版本。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/09/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Linux系统下使用虚拟环境"><a href="#Linux系统下使用虚拟环境" class="headerlink" title="Linux系统下使用虚拟环境"></a>Linux系统下使用虚拟环境</h1><blockquote><p>安装虚拟环境的包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenv</span><br></pre></td></tr></table></figure><blockquote><p>创建虚拟环境的软连接</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/virtualenv /usr/bin/virtualenv</span><br></pre></td></tr></table></figure><blockquote><p>创建虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p /usr/bin/python3 xxxxx</span><br></pre></td></tr></table></figure><blockquote><p>进入虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source bin/activate</span><br></pre></td></tr></table></figure><blockquote><p>退出虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><h1 id="Windos-使用Xshell"><a href="#Windos-使用Xshell" class="headerlink" title="Windos 使用Xshell"></a>Windos 使用Xshell</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@172.0.0.1           //需要连接服务器的IP地址 通过ifconfig获得</span><br></pre></td></tr></table></figure><h1 id="Linux安装Mysql数据库服务"><a href="#Linux安装Mysql数据库服务" class="headerlink" title="Linux安装Mysql数据库服务"></a>Linux安装Mysql数据库服务</h1><table><thead><tr><th>解释</th><th>命令</th></tr></thead><tbody><tr><td>安装服务端</td><td>yum install mysql-community-server</td></tr><tr><td>启动</td><td>service mysqld start</td></tr><tr><td>停止</td><td>service mysqld stop</td></tr></tbody></table><blockquote><p>CentOS下自带mariadb    可以通过下面命令删除</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove mariadb-libs.x86_64</span><br></pre></td></tr></table></figure><blockquote><p>下载Mysql57的源文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /</span><br><span class="line">cd tmp</span><br><span class="line">wget https://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><blockquote><p>安装Mysql57</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><blockquote><p>安装数据库服务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure><blockquote><p>启动数据库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure><blockquote><p>停止数据库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld stop</span><br></pre></td></tr></table></figure><h1 id="Linux网络连接"><a href="#Linux网络连接" class="headerlink" title="Linux网络连接"></a>Linux网络连接</h1><p>ifconfig</p><p>ip addr</p><p>cd /</p><p>cd /etc/sysconfig/newwork-scripts/ifcfg-xxx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将最后一行的 no 修改为 yes</span><br><span class="line">i 修改</span><br><span class="line">Esc 退出</span><br><span class="line">：wq 保存退出</span><br></pre></td></tr></table></figure><p>配置完成后关闭客户机</p><p>编辑–&gt;虚拟网络编辑器–&gt;还原默认设置</p><p>vi /etc/resolv.conf         （添加nameserver114.114.114.114）</p><p>service network restart    重启网络服务</p><p>yum provides ifconfig      安装ifconfig</p><p>yum install net-tools</p><blockquote><p>ifcfg-xxx     的配置文件内容   提供参考不做修改</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0                              // 装置名称</span><br><span class="line">BOOTPROTO=none                    // 启动引导协议</span><br><span class="line">ONBOOT=yes                             // 启动加载</span><br><span class="line">IPADDR=192.168.1.200              // IP地址                              若无，手动添加</span><br><span class="line">NETMASK=255.255.255.0          // 网络掩码；子网掩码          若无，手动添加</span><br><span class="line">BROADCAST=192.168.1.255      // </span><br><span class="line">GATEWAY=192.168.1.1              // 网关            若无，手动添加</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PREFIX=24</span><br><span class="line">DNS1=192.168.1.1          // DNS ，如果桥接配置下，无DNS，无法连接Inernet。 若无，需手动添加。</span><br><span class="line">DEFROUTE=yes           //这个需要打开</span><br><span class="line">IPV4_FAILURE_FATAL=yes</span><br><span class="line">IPV6INIT=no</span><br><span class="line">NAME=&quot;System eth0&quot;</span><br><span class="line">UUID=5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03</span><br><span class="line">LAST_CONNECT=1437140517</span><br></pre></td></tr></table></figure><h1 id="Linux升级yum"><a href="#Linux升级yum" class="headerlink" title="Linux升级yum"></a>Linux升级yum</h1><p>需要有网的状态下。</p><p>检测网络 ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p><p>然后执行下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure><h1 id="Lnux下Mysql-修改密码"><a href="#Lnux下Mysql-修改密码" class="headerlink" title="Lnux下Mysql-修改密码"></a>Lnux下Mysql-修改密码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start    //启动数据库服务</span><br><span class="line">第一次启动过程中</span><br><span class="line">ps -ef |frep mysql                  //这条命令查看是否存在Mysql服务</span><br></pre></td></tr></table></figure><blockquote><p>查看mysql 密码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/mysqld.log |grep &quot;password&quot;</span><br></pre></td></tr></table></figure><blockquote><p>修改mysql数据库密码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/mysqld.log |grep &quot;password&quot;      //首先查看mysql数据库密码并赋值</span><br><span class="line">mysql -u root -p              //进入数据库</span><br><span class="line">password                         //输入密码</span><br><span class="line">set password = password(&quot;123456&quot;);          //修改密码为123456</span><br><span class="line">- 如果显示 OK 证明修改密码成果</span><br><span class="line">- 如果提示 Your password does not satisfy the current policy requirements</span><br><span class="line">- 他的意思是告诉你你密码不符合当前策略要求</span><br><span class="line">set global validate_password_policy=0;       //密码安全策略为0</span><br><span class="line">set global validate_password_length=1;        //密码长度为1</span><br><span class="line">alter user &apos;root&apos;@&apos;localhost&apos; password expire never;  //root密码永不过期</span><br><span class="line">flush privileges;                 //重新加载权限列表</span><br><span class="line">set password = password(&quot;123456&quot;);          //修改密码为123456</span><br><span class="line"> - 这时候就可以成功了</span><br><span class="line">exit;        //退出</span><br><span class="line"> - 可以尝试使用新的密码重新登陆</span><br></pre></td></tr></table></figure><h1 id="在Linux环境下安装Python3-5-0"><a href="#在Linux环境下安装Python3-5-0" class="headerlink" title="在Linux环境下安装Python3.5.0:"></a>在Linux环境下安装Python3.5.0:</h1><blockquote><p>安装python所需要的依赖环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlit-devel</span><br></pre></td></tr></table></figure><blockquote><p>安装 wget</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure><blockquote><p>下载Python3.5.0                       ps:cd  到 tmp 目录下面否则会安装到桌面</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget &quot;https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tgz&quot;</span><br></pre></td></tr></table></figure><blockquote><p>解压Python3.5.0                  ps:下载的Python是一个压缩包需要解压</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Python-3.5.0.tgz</span><br></pre></td></tr></table></figure><blockquote><p>建立一个新的文件夹地址</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/python3</span><br></pre></td></tr></table></figure><blockquote><p>安装gcc编译器，否则编译过程中会报错</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc</span><br></pre></td></tr></table></figure><blockquote><p>在解压Python的目录下把Python编译到指定目录</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Python-3.5.0/configure --prefix=/usr/local/python3</span><br></pre></td></tr></table></figure><blockquote><p>Make在发现错误之后不停止继续执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><blockquote><p>Python安装完成！                           ps:可以通过下面的命令来运行一下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/python3/bin/python3</span><br><span class="line">exit();                   退出</span><br></pre></td></tr></table></figure><blockquote><p>建立Python的软链接</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python3</span><br><span class="line">python3</span><br><span class="line">exit()；               退出</span><br></pre></td></tr></table></figure><blockquote><p>建立pip3的软链接</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><blockquote><p>接下来可以使用pip3 安装包测试一下是否可用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install request</span><br></pre></td></tr></table></figure><h1 id="Linux系统下使用虚拟环境-1"><a href="#Linux系统下使用虚拟环境-1" class="headerlink" title="Linux系统下使用虚拟环境"></a>Linux系统下使用虚拟环境</h1><blockquote><p>安装虚拟环境的包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenv</span><br></pre></td></tr></table></figure><blockquote><p>创建虚拟环境的软连接</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/virtualenv /usr/bin/virtualenv</span><br></pre></td></tr></table></figure><blockquote><p>创建虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p /usr/bin/python3 xxxxx</span><br></pre></td></tr></table></figure><blockquote><p>进入虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source bin/activate</span><br></pre></td></tr></table></figure><blockquote><p>退出虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><h1 id="Atom的使用方法"><a href="#Atom的使用方法" class="headerlink" title="Atom的使用方法"></a>Atom的使用方法</h1><blockquote><p>汉化</p><ul><li>打开 packages –setting views–open </li><li>点击install 输入包名simplified-chinese-menu搜索并安装 </li><li>汉化成功！</li></ul></blockquote><h1 id="Linux-Webbench压力测试工具安装"><a href="#Linux-Webbench压力测试工具安装" class="headerlink" title="Linux-Webbench压力测试工具安装"></a>Linux-Webbench压力测试工具安装</h1><p>下载            cd 到tmp目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://home.tiscali.cz/~cz210552/distfiles/webbench-1.5.tar.gz</span><br></pre></td></tr></table></figure><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf ./webbench-1.5.tar.gz</span><br></pre></td></tr></table></figure><p>安装编译环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc ctags</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ./webbench-1.5</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><p>如果遇到以下问题：        ps:这是给你参考的要去运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install: cannot create regular file &apos;/usr/local/man/man1&apos;: No such file or directory</span><br><span class="line">make: *** [install] Error 1</span><br></pre></td></tr></table></figure><p>网上解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/man</span><br></pre></td></tr></table></figure><p>但是我发现<code>man</code>目录是存在的，那问题只可能是权限了,修改好权限，问题解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /usr/local/man</span><br></pre></td></tr></table></figure><h3 id="Webbench压力测试工具使语法"><a href="#Webbench压力测试工具使语法" class="headerlink" title="Webbench压力测试工具使语法"></a>Webbench压力测试工具使语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">webbench [option]... URL</span><br><span class="line">  -f|--force               Don&apos;t wait for reply from server.</span><br><span class="line">  -r|--reload              Send reload request - Pragma: no-cache.</span><br><span class="line">  -t|--time &lt;sec&gt;          Run benchmark for &lt;sec&gt; seconds. Default 30.</span><br><span class="line">  -p|--proxy &lt;server:port&gt; Use proxy server for request.</span><br><span class="line">  -c|--clients &lt;n&gt;         Run &lt;n&gt; HTTP clients at once. Default one.</span><br><span class="line">  -9|--http09              Use HTTP/0.9 style requests.</span><br><span class="line">  -1|--http10              Use HTTP/1.0 protocol.</span><br><span class="line">  -2|--http11              Use HTTP/1.1 protocol.</span><br><span class="line">  --get                    Use GET request method.</span><br><span class="line">  --head                   Use HEAD request method.</span><br><span class="line">  --options                Use OPTIONS request method.</span><br><span class="line">  --trace                  Use TRACE request method.</span><br><span class="line">  -?|-h|--help             This information.</span><br><span class="line">  -V|--version             Display program version.</span><br></pre></td></tr></table></figure><p>这里time和clients比较重要，</p><ul><li><p>time是benchmark持续多久</p></li><li><p>clients是指time时间内请求多少次。</p><p>比如我们测试百度, 启动100个客户端同时请求百度首页，持续60S：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webbench -t 60 -c 100 http://www.baidu.com/</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Webbench - Simple Web Benchmark 1.5</span><br><span class="line">Copyright (c) Radim Kolar 1997-2004, GPL Open Source Software.</span><br><span class="line"></span><br><span class="line">Benchmarking: GET http://www.baidu.com/</span><br><span class="line">100 clients, running 60 sec.</span><br><span class="line"></span><br><span class="line">Speed=2643 pages/min, 5045450 bytes/sec.</span><br><span class="line">Requests: 2641 susceed, 2 failed.</span><br></pre></td></tr></table></figure><p>ps:网上荡下来的未亲测，如有问题请找即使联系作者。</p><h1 id="Nginx安装配置"><a href="#Nginx安装配置" class="headerlink" title="Nginx安装配置"></a>Nginx安装配置</h1><p>Nginx（“引擎x”）是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的Web和反向代理服务器，也是一个IMAP / POP3 / SMTP代理服务器。</p><p>在高连接并发的情况下，Nginx的是Apache的服务器不错的替代品。</p><h4 id="一-安装编译工具及库文件"><a href="#一-安装编译工具及库文件" class="headerlink" title="一.安装编译工具及库文件"></a>一.安装编译工具及库文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c ++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure><h4 id="二-首先安装PCRE"><a href="#二-首先安装PCRE" class="headerlink" title="二.首先安装PCRE"></a>二.首先安装PCRE</h4><p>PCRE作用是让Nginx支持重写功能。</p><ol><li>下载PCRE安装包，下载地址：<a href="http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz" target="_blank" rel="noopener">http</a>：  <a href="http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz" target="_blank" rel="noopener">//downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz</a></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd / usr / local / src /</span><br><span class="line">wget http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>解压安装包</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf pcre-8.35.tar.gz</span><br></pre></td></tr></table></figure><ol start="3"><li>进入安装目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd pcre-8.35</span><br></pre></td></tr></table></figure><ol start="4"><li>编译安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不搞了自己看网站去吧：</p><p><a href="https://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/linux/nginx-install-setup.html</a></p><h1 id="Django-Nginx-uwsgi-安装配置"><a href="#Django-Nginx-uwsgi-安装配置" class="headerlink" title="Django Nginx+uwsgi 安装配置"></a>Django Nginx+uwsgi 安装配置</h1><p>链接：🔗</p><p><a href="https://www.runoob.com/django/django-nginx-uwsgi.html" target="_blank" rel="noopener">https://www.runoob.com/django/django-nginx-uwsgi.html</a></p><h1 id="Django-Nginx-uWSGI-安装配置"><a href="#Django-Nginx-uWSGI-安装配置" class="headerlink" title="Django Nginx+uWSGI 安装配置"></a>Django Nginx+uWSGI 安装配置</h1><p>链接：🔗</p><p><a href="https://www.runoob.com/django/django-nginx-uwsgi.html" target="_blank" rel="noopener">https://www.runoob.com/django/django-nginx-uwsgi.html</a></p><blockquote><p>yum  update</p><p>yum install gcc </p><p>pip  install  uwsgi</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">查看uwsgi动态链接库是否有问题：</span><br><span class="line">which  uwsgi</span><br><span class="line">ldd /root/anaconda3/bin/uwsgi</span><br><span class="line">发现:libicui18n.so.58 =&gt; not found</span><br><span class="line">     libicuuc.so.58 =&gt; not found</span><br><span class="line">     libicudata.so.58 =&gt; not found</span><br><span class="line">通过 LDD 发现 uwsgi 找不到三个包（具体就是 not found 的三个）</span><br><span class="line">于是就把anaconda3/lib 下相应的包软链到/lib64下去（64bit 机器，如果时32bit 机器则软链到/lib下）</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ln -s /root/anaconda3/lib/libicui18n.so.58 /lib64/libicui18n.so.58</span><br><span class="line">[root@localhost ~]# ln -s /root/anaconda3/lib/libicuuc.so.58 /lib64/libicuuc.so.58</span><br><span class="line">[root@localhost ~]# ln -s /root/anaconda3/lib/libicudata.so.58 /lib64/libicudata.so.58</span><br><span class="line">运行uwsgi:发现还有问题</span><br><span class="line">于是：</span><br><span class="line">    把libstdc++.so.6.0.24拷贝到/lib64目录下。</span><br><span class="line">      cp /root/anaconda3/lib/libstdc++.so.6.0.25 /lib64/</span><br><span class="line">    删除原来的libstdc++.so.6符号连接。</span><br><span class="line">      rm -fr /lib64/libstdc++.so.6</span><br><span class="line">    新建新符号连接。</span><br><span class="line">      ln -s /lib64/libstdc++.so.6.0.25 /lib64/libstdc++.so.6</span><br><span class="line">    再次执行uwsgi查看结果符合就哦了。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">测试：创建index.py</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(env, start_response)</span>:</span></span><br><span class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b"Hello World"</span>]</span><br><span class="line"></span><br><span class="line">uwsgi --http :<span class="number">9090</span> --wsgi-file index.py</span><br><span class="line">浏览器访问<span class="number">9090</span>端口</span><br></pre></td></tr></table></figure><h6 id="添加并发"><a href="#添加并发" class="headerlink" title="添加并发"></a>添加并发</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi --http :<span class="number">9090</span> --wsgi-file index.py --processes <span class="number">4</span> --threads <span class="number">2</span></span><br></pre></td></tr></table></figure><h6 id="部署-Django"><a href="#部署-Django" class="headerlink" title="部署 Django"></a>部署 Django</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在项目中创建djangospider.ini</span></span><br><span class="line">[uwsgi]</span><br><span class="line"><span class="comment"># 使用Nginx做反向代理时使用socket</span></span><br><span class="line"><span class="comment">#socket=127.0.0.1:8080</span></span><br><span class="line"><span class="comment"># 不通过Nginx反向代理，直接做web服务器时使用http</span></span><br><span class="line">http = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br><span class="line"><span class="comment">#项目目录</span></span><br><span class="line">chdir = /usr/www/DjangoSpider/</span><br><span class="line">wsgi-file = DjangoSpider/wsgi.py</span><br><span class="line">processes = <span class="number">4</span></span><br><span class="line">threads = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#django项目setting中</span></span><br><span class="line">ALLOWED_HOSTS = [] 改为</span><br><span class="line">ALLOWED_HOSTS = [<span class="string">'*'</span>]</span><br><span class="line"></span><br><span class="line">启动：uwsji --ini  djangospider.ini</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在www中创建uwsgi文件夹，用来存放uwsgi相关文件</span><br><span class="line"><span class="comment">#### 启动： </span></span><br><span class="line">uwsgi --ini xxx.ini</span><br><span class="line"><span class="comment">#### 重启：</span></span><br><span class="line">uwsgi --reload xxx.pid</span><br><span class="line"><span class="comment">#### 停止：</span></span><br><span class="line">uwsgi --stop xxx.pid</span><br></pre></td></tr></table></figure><h1 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h1><p><img src="C:/Users/Administrator/Desktop/Down/MarkDown/Linux%E6%93%8D%E4%BD%9C/assets/20181226194100326.png" alt="img"> </p><p><strong>nginx服务器安装：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">下载对应当前系统版本的nginx包(package)</span><br><span class="line"># wget  http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line">建立nginx的yum仓库</span><br><span class="line"># rpm -ivh nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br><span class="line"></span><br><span class="line">下载并安装nginx</span><br><span class="line"># yum install -y nginx</span><br><span class="line"></span><br><span class="line">启动nginx服务</span><br><span class="line">systemctl restart nginx</span><br><span class="line">验证：直接请求IP，可见nginx</span><br><span class="line"></span><br><span class="line">配置</span><br><span class="line">默认的配置文件在 /etc/nginx 路径下，使用该配置已经可以正确地运行nginx；如需要自定义，</span><br><span class="line">修改其下的 nginx.conf 等文件即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看是否启动：（如果有master和worker两个进程证明启动成功）</span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line">停止(建议用quit，不建议用stop)</span><br><span class="line">nginx -s quit</span><br><span class="line"></span><br><span class="line">重新加载配置文件</span><br><span class="line">nginx -s reload</span><br><span class="line"></span><br><span class="line">默认配置文件位置：</span><br><span class="line">/etc/nginx/conf.d/default.conf</span><br><span class="line">备份默认配置文件：</span><br><span class="line">cp  /etc/nginx/conf.d/default.conf   /etc/nginx/conf.d/default.conf.bak</span><br><span class="line"></span><br><span class="line">welcome所在位置（默认值：/usr/share/nginx/html/）</span><br></pre></td></tr></table></figure><p><strong>修改nginx配置文件：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 负载均衡</span><br><span class="line">upstream upstream1 &#123;</span><br><span class="line">    server 127.0.0.1:8000;  # 处理相同业务的多个服务器 (负载均衡)</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;   # 对外部用户提供的统一域名</span><br><span class="line"></span><br><span class="line">    # 将动态请求转发给uwsgi服务器</span><br><span class="line">    location / &#123;</span><br><span class="line">        # 包含uwsgi请求的参数</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        # 转交请求给uwsgi服务器 (uwsgi服务器的ip和端口号)</span><br><span class="line">        #uwsgi_pass 127.0.0.1:8000;  # 单个uwsgi服务器(不需要负载均衡)</span><br><span class="line">        uwsgi_pass upstream1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 如果是静态资源请求就直接响应资源。</span><br><span class="line">    location /static &#123;</span><br><span class="line">        # 指定静态文件存放的目录 (需要修改/usr/...目录的操作权限。 $ chmod 777 /usr)</span><br><span class="line">        alias /usr/www/D_text04/static/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>验证：</strong></p><p>nginx  -s   reload   (重新加载配置文件)</p><p>请求80端口，可能出现permission 问题（办法：先关掉selinux： setenforce 0 ）</p><p><strong>收集Django中的静态资源：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">项目名/settings.py（项目配置，STATIC_ROOT设置收集静态资源的路径）：</span><br><span class="line">STATIC_URL = &apos;/static/&apos;</span><br><span class="line">STATICFILES_DIRS = [os.path.join(BASE_DIR, &apos;static&apos;)]</span><br><span class="line"># 指定收集静态文件的路径 (需要修改/var/...目录的操作权限)</span><br><span class="line">STATIC_ROOT=&apos;./static&apos;</span><br><span class="line"></span><br><span class="line">$ python manage.py collectstatic</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/09/Linux%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-操作命令"><a href="#Linux-操作命令" class="headerlink" title="Linux-操作命令"></a>Linux-操作命令</h1><p>\1. ctr + alt + t  打开新的终端窗口</p><p>\2. ctr + shift + + 终端窗口字体放大</p><p>\3. ctr + - 终端窗口字体缩小</p><p>\4. ls : 查看目录下的文件信息</p><p>\5. pwd: 查看目录所对应路径</p><p>\6. touch: 创建文件</p><p>\7. mkdir: 创建文件夹</p><p>\8. cd: 切换目录</p><p>8.1 cd .. 切换到上一级目录</p><p>8.2 cd 目录名： 切换到指定目录</p><p>8.3 cd -: 切换到上一次路径</p><p>8.4 cd ~: 切换到用户的家目录 /home/python</p><p>8.5 cd .: 切换到当前目录</p><p>\9. rmdir: 删除空文件夹，注意点:只能是空文件夹</p><p>\10. rm:可以删除文件也可以删除文件夹，如果删除的是文件夹需要加上一个选项， -r: 以递归的方式把文件夹里面的文件都删除，然后再删除外面的目录</p><p>\11. clear: 清屏</p><p>\12. 绝对路径: 从根目录算起的路径就是绝对路径 比如： /home/python/xxx</p><p>\13. 相对路径: 从当前目录算起的路径就是相对路径 比如: ../  或者  ./</p><p>\14. cp: 复制</p><p>14.1 cp 文件名 路径  ： 把指定文件拷贝到指定路径</p><p>14.2 cp 文件夹 路径 -r : 把指定文件夹拷贝到指定路径，需要加上-r选项 :以递归的方式把文件夹里面的文件拷贝到指定的目录</p><p>14.3 cp 文件名 路径/新文件名: 先拷贝文件到指定路径然后再对文件进行重命名</p><p>\15. mv: 移动</p><p>15.1 mv 文件名 路径 ： 把指定文件移动（剪切）到指定路径</p><p>15.2 mv 文件夹 路径 ： 把指定文件夹移动（剪切）到指定路径， 注意点：移动文件或者文件夹的时候不需要加上-r</p><p>15.3 提示： 拷贝或者删除文件夹的时候都需要加上-r选项</p><p>15.4 mv 文件名 新文件名: 重命名</p><p>15.5 mv 文件名 路径/新文件名 : 先移动文件到指定路径然后再对文件进行重命名</p><p>\16. tree： 以目录树方式显示文件信息，提示目前查看当前目录</p><p>tree /: 查看指定目录以目录树方式显示文件信息</p><p>\17. cal: 查看当前月日历</p><p>cal -y : 查看全年</p><p>\18. date: 查看当前日期及时间</p><p>date “+%Y:%m:%d %H:%M:%S”  显示年月日 时分秒</p><p>\19. history： 查看历史命令</p><p>!历史命令编号 =&gt;执行对应编号对应的命令</p><p>\20. 命令格式</p><p>命令名 [命令选项] <a href="可以是多个路径或者多个文件名">命令参数</a></p><p>[命令选项]：比如：rm -r  也可以有多个</p><p>\21. –help: 查看命令的帮助信息</p><p>rm –help : 查看删除命令的选项信息有那些</p><p>\22. man rm : 查看命令的帮助信息</p><p>\23. ls 选项</p><p>23.1 -a : 显示隐藏文件及文件夹</p><p>23.2 -l : 以列表方式显示</p><p>23.3 -h : 显示文件大小单位</p><p>23.4 ll  =&gt; ls -al</p><p>23.5 l =&gt; ls</p><p>\24. mkdir选项</p><p>24.1 -p : 可以创建嵌套多层的文件夹</p><p>\25. rm 选项</p><p>25.1 -i: 显示提醒信息</p><p>25.2 -f: 如果文件存在就删除，否则不会显示错误信息</p><p>25.3 -r: 删除文件夹</p><p>\26. cp 选项</p><p>26.1 -i: 显示提醒信息</p><p>26.2 -v: 显示文件或者文件夹拷贝后的路径描述</p><p>26.3 -r: 拷贝文件夹</p><p>\27. mv 选项</p><p>27.1 -i:显示提醒信息</p><p>27.2 -v: 显示文件或者文件夹移动（剪切）后的路径描述</p><p>\28. 重定向(&gt;, &gt;&gt;)</p><p>28.1: 重定向：重新规定显示方向，把终端显示的信息重新规定方向保存到指定文件里面</p><p>28.2: &gt; : 提示：如果文件存在，先把原有数据清空然后在写入新的数据，相当于文件操作里面-&gt;w模式</p><p>28.3: &gt;&gt;: 提示： 如果文件存在，在原有数据的基础上进行追加，相当于文件操作里面的里面-&gt;a模式，如果文件不存在会自动创建然后再写入</p><p>\29. 查看文件的方式</p><p>29.1 gedit 可以查看及编辑文件</p><p>29.2 cat 可以查看文件但是不能分屏显示以及不能修改文件</p><p>29.2.1 cat可以通过重定向合并文件信息</p><p>cat 1.txt 2.txt &gt; 3.txt</p><p>29.3 more 分屏显示文件信息</p><p>29.3.1： 回车：看下一行</p><p>29.3.2:  f(空格)： 看下一页</p><p>29.3.3： q:退出</p><p>\30. 管道（|）：可以理解成一个容器，在终端显示的数据可以放到管道里面，然后通过其它命令可以在管道里面获取数据</p><p>30.1： ls /bin | more</p><p>\31. 链接</p><p>31.1 软链接: ln -s 文件名 软链接文件名   提示： 创建软链接不会对硬链接数加1， 软链接还可以给文件夹创建</p><p>31.2 硬链接: ln 文件名 硬链接文件名  提示： 创建硬链接会对硬链接数加1，不能对文件夹创建硬链接</p><p>\32. grep ： 在文件里面查找指定的内容</p><p>32.1 -n: 显示行号</p><p>32.2 -i: 不区分大小写</p><p>32.3 -v: 根据查找数据取反</p><p>提示： 还可以支持通配符: ^,$,[abc],?*等这些通配符</p><p>\33. find: 在指定路径查找文件</p><p>33.1 find ./ -name “123.txt”: 只找123.txt文件</p><p>提示： 还可以使用通配符</p><p>​      33.2 find ./ -name “1?3.txt” : ?表示匹配任意一位字符</p><p>​      33.3 find ./ -name “1*3.txt” : *表示可以匹配0个或者多个任意字符</p><p>​      33.4 find ./ -name “[123].txt” : [123]表示匹配中一个文件比如1.txt,2.txt,3.txt</p><p>34 ls</p><p>提示： 也可以使用通配符，进行模糊查询</p><p>总结： 通配符就是起到模糊查询作用</p><p>\35. tar命令</p><p>35.1 打包命令</p><p>35.1.1 tar -cvf test.tar *.txt  : 提示： 没有压缩</p><p>35.1.2 -c 表示打包 -v表示显示那些文件要打到包里面 -f:包的后缀是.tar ,提示：-f必须放到后面不再接收其它选项 -z 压缩选项</p><p>35.2 压缩命令</p><p>gzip test.tar =&gt; 压缩包  test.tar.gz</p><p>35.3 打包及压缩的命令</p><p>tar -zcvf test.tar.gz *.txt</p><p>35.4 解压缩</p><p>gzip -d test.tar.gz  =&gt; 获取到包</p><p>35.5 解包</p><p>tar -xvf test.tar  =&gt; 获取包里面的文件</p><p>35.6 解压缩及解包</p><p>tar -zxvf test.tar.gz =&gt; 获取压缩包里面的文件</p><p>35.7 打包及压缩后缀是bz2命令</p><p>tar -jcvf test.bz2 *.txt =&gt; 获取bz2的压缩包</p><p>35.8 解压缩及解包后缀是bz2命令</p><p>tar -jxvf test.bz2  =&gt;  获取压缩包里面的文件</p><p>35.9 指定解压缩后路径</p><p>tar -jxvf test.bz2 -C ./123</p><p>35.10</p><p>zip test.zip *.txt =&gt; test.zip : 提示： 压缩包的后缀可以省略</p><p>unzip test.zip : 表示解压到当前目录获取到文件</p><p>unzip -d ./456 test.zip: 表示解压到指定路径</p><p>\36. chmod： 修改文件权限</p><p>36.1 权限有:r：可读(4)， w: 可写(2)， x: 可执行(1), -(0): 没有权限</p><p>36.2 u: 当前用户，g：同组用户 ， o:其它用户， a:所有用户</p><p>36.3：权限设置： + 添加权限， - 删除权限， = 设定权限</p><p>chmod a=— 1.txt : 表示1.txt的所有用户都没有权限</p><p>chmod a= 1.txt : 表示1.txt的所有用户都没有权限</p><p># 数字法：</p><p>chmod 000 1.txt 表示1.txt的所有用户都没有权限</p><p>\37. cp 选项</p><p>-a: 表示保留文件的原有权限，包含-r，还可以拷贝文件夹</p><p>\38. which: 查看命令的路径， 比如： ls</p><p>\39. passwd: 修改密码</p><p>\40. sudo -s: 切换到管理用户，注意: 一般不建议大家切换进去，如果想要获取管理员的权限可以在命令前面加上sudo apt-get install sl</p><p>\41. exit : 退出某个用户</p><p>\42. who： 当前有那些用户登陆</p><p>\43. whoami: 当前电脑登陆的用户是谁</p><p>\44. ssh: 远程登陆=&gt; ssh 用户名@ip地址 =&gt; ssh <a href="mailto:python@192.168.122.138" target="_blank" rel="noopener">python@192.168.122.138</a></p><p>\45. scp: 远程拷贝</p><p>45.1 scp ./1.txt <a href="mailto:python@192.168.122.138" target="_blank" rel="noopener">python@192.168.122.138</a>:/home/python/Desktop =&gt; 本地文件远程拷贝到服务端</p><p>45.2 scp -r ./test <a href="mailto:python@192.168.122.138" target="_blank" rel="noopener">python@192.168.122.138</a>:/home/python/Desktop =&gt; 本地文件夹远程拷贝到服务端</p><p>45.3 scp <a href="mailto:python@192.168.122.138" target="_blank" rel="noopener">python@192.168.122.138</a>:/home/python/Desktop/1.txt ./ =&gt; 从服务端远程拷贝1.txt文件到本地</p><p>45.4 scp -r <a href="mailto:python@192.168.122.138" target="_blank" rel="noopener">python@192.168.122.138</a>:/home/python/Desktop/test ./ =&gt; 从服务端远程拷贝test文件夹到本地</p><p>\46. vim命令</p><p>46.1 vim有三种模式，编辑模式，末行模式，默认是进入的是命令模式</p><p>46.1 命令模式进入编辑模式使用(i,a), 命令模式进入末行模式使用(:), 编辑模式进入末行模式首先使用esc进入命令模式然后使用(:)进入末行模式</p><p>46.2 末行模式下: wq，x 表示保存及退出</p><p>vim命令模式使用的命令</p><p>\1. yy 复制光标所在行， 3yy: 复制包含光标在内3行数据</p><p>\2. p : 粘贴， 4p: 粘贴4次</p><p>\3. dd: 剪切（删除） 3dd: 剪切或者删除3行</p><p>\4. 数字加G： 回到指定行，比如:10G</p><p>\5. 快速回到第一行: gg, 1G</p><p>\6. 快速回到最后一行:G</p><p>\7. 快速回到行末： shift+4</p><p>\8. 快速回到行首: shift+6</p><p>\9. 下一页: ctr+f</p><p>10 上一页: ctr+b</p><p>\11. 上下左右除了方向键，还可以使用h:左 l：右 k:上 j:下</p><p>\12. 撤销：u</p><p>\13. 往右移动： shift + &gt;  .重复上一次操作</p><p>\14. 往左移动： shift + &lt;  .重复上一次操作</p><p>\15. V:选中光标经过行</p><p>“””</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/CentOS%E9%87%8D%E5%90%AF%E7%BD%91%E5%8D%A1/"/>
      <url>/2019/08/09/CentOS%E9%87%8D%E5%90%AF%E7%BD%91%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="centos7的网卡重启方法"><a href="#centos7的网卡重启方法" class="headerlink" title="centos7的网卡重启方法"></a>centos7的网卡重启方法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos6的网卡重启方法：service network restart</span><br><span class="line">centos7的网卡重启方法：systemctl restart network</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙并设置开机不启动"><a href="#关闭防火墙并设置开机不启动" class="headerlink" title="关闭防火墙并设置开机不启动"></a>关闭防火墙并设置开机不启动</h3><p>查看防火墙状态：systemctl status firewalld.service<br>关闭：systemctl stop firewalld<br>开启：systemctl start firewalld<br>开机自动关闭：systemctl disable firewalld<br>开机自动启动：systemctl enable firewalld<br>查看开机是否启动：chkconfig –list|grep network(RHLE6)</p><h3 id="临时和永久关闭Selinux"><a href="#临时和永久关闭Selinux" class="headerlink" title="临时和永久关闭Selinux"></a>临时和永久关闭Selinux</h3><p>临时关闭：<br>_getenforce<br>Enforcing</p><p>_setenforce 0<br>setenforce:SELinux is disabled</p><p>永久关闭：<br>_vim /etc/selinux/config</p><p>2、DNS配置文件：</p><p>cat /etc/resolv.conf<br>设置主机和IP绑定信息：cat /etc/hosts<br>设置主机名：cat /etc/hostname</p><p>3、可以使用nmtui文本框方式修改IP</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/CentOS%E4%BF%AE%E6%94%B9yum%E6%BA%90/"/>
      <url>/2019/08/09/CentOS%E4%BF%AE%E6%94%B9yum%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="替换默认源"><a href="#替换默认源" class="headerlink" title="替换默认源"></a>替换默认源</h1><p>替换源：</p><p>默认的源是国外的源，国外的源有可能打开比较慢有可能打不开所以要替换源。</p><p>国内很多厂商做了镜像我们现在使用163的源。</p><p><a href="http://mirrors.163.com/.help/centos.html" target="_blank" rel="noopener">http://mirrors.163.com/.help/centos.html</a></p><blockquote><p>首先备份repo</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><blockquote><p>就可以查看到备份的repo</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repos.d/                //进入指定目录</span><br><span class="line">ll              //查看命令</span><br></pre></td></tr></table></figure><blockquote><p>安装CentOS 7    下载对应版本的 repo 放入到 /etc/yum.repos.d/CentOS-Base.repo</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://mirrors.163.com/.help/CentOS7-Base-163.repo -o CentOS7-Base-163.repo</span><br></pre></td></tr></table></figure><blockquote><p>运行下面命令生成缓存</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all             //这条命令如果失败不用管</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><blockquote><p>如果提示你看不懂的命令就是因为yum被占用了 我们可以通过下面命令来干掉他</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /var/run/yum.pid      //然后在执行 运行下面命令生成缓存 的步骤</span><br></pre></td></tr></table></figure><blockquote><p>源安装完成后可以安装一个wget   安装过的不用安装</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget                //安装wget</span><br></pre></td></tr></table></figure><blockquote><p>安装vim       机器默认有vi，vim比vi更好用一些</p><p>vim 是Linux下面的文件编辑神器</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim</span><br></pre></td></tr></table></figure><h1 id="修改yum源为阿里"><a href="#修改yum源为阿里" class="headerlink" title="修改yum源为阿里"></a>修改yum源为阿里</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 备份本地yum源</span><br><span class="line"></span><br><span class="line"> mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo_bak </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>获取阿里yum源配置文件</span><br><span class="line"></span><br><span class="line">将https://mirrors.tuna.tsinghua.edu.cn/help/centos/  中的内容粘贴到CentOS-Base.repo</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>更新cache</span><br><span class="line"></span><br><span class="line">yum  clean   all</span><br><span class="line"></span><br><span class="line">yum makecache </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>查看</span><br><span class="line"></span><br><span class="line">yum -y update</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/CentOS%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/"/>
      <url>/2019/08/09/CentOS%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简解："><a href="#简解：" class="headerlink" title="简解："></a>简解：</h1><p> 你好</p><p>是虚拟机 服务 没有开启</p><p>点击“开始→运行”，在运行框中输入 CMD 回车打开命令提示符，然后依次执行以下命令。</p><p>net start vmci</p><p>net start vmx86</p><p>net start VMnetuserif</p><p>sc config vmci=auto</p><p>sc config vmx86=auto</p><p>sc config VMnetuserif=auto</p><p>我和你同样的问题，已解决  </p><h1 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h1><p>这是因为没有开启虚拟机服务，只要将其开启即可解决。</p><p>工具：电脑。</p><p>1、用鼠标指向电脑桌面上的开始菜单，点击鼠标右键选择菜单上的运行。</p><p><img src="assets/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A81.png" alt></p><p>2、再输入CMD，然后点击界面下方的确定。</p><p><img src="assets/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A82.png" alt></p><p>3、输入net start vmci后，点击回车。</p><p><img src="assets/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A83.png" alt></p><p>4、输入net start vmx86后，点击回车。</p><p><img src="assets/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A84.png" alt></p><p>5、输入net start VMnetuserif，点击回车。</p><p><img src="assets/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A85.png" alt></p><p>6、输入net start vmci后，点击回车。</p><p><img src="assets/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A86.png" alt></p><p>7、输入sc config vmx86=auto后，点击回车。</p><p><img src="assets/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A87.png" alt></p><p>8、输入sc config VMnetuserif=auto后，点击回车。</p><p><img src="assets/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A88.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/CentOS%E5%90%AF%E5%8A%A8Django%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/09/CentOS%E5%90%AF%E5%8A%A8Django%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Django无法使用Sqlite3问题"><a href="#Django无法使用Sqlite3问题" class="headerlink" title="Django无法使用Sqlite3问题"></a>Django无法使用Sqlite3问题</h1><p><strong>解决Nomodule named _sqlite3</strong></p><ol><li><p>服务器Centos7.4</p></li><li><p>Python 3.6.5</p></li><li><p>Scrapy 1.5.1</p></li></ol><p>我在本地编写的Scrapy程序放在服务器上跑，但是在启动程序的时候遇到了，没有sqlite3模块，现在的Python版本是3.6.5。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/root/zhongan/.venv/lib/python3.6/site-packages/twisted/internet/defer.py"</span>, line <span class="number">1418</span>, <span class="keyword">in</span> inlineCallbacks</span><br><span class="line">    result = g.send(result)</span><br><span class="line">  File <span class="string">"/root/zhongan/.venv/lib/python3.6/site-packages/scrapy/crawler.py"</span>, line <span class="number">82</span>, <span class="keyword">in</span> crawl</span><br><span class="line">    <span class="keyword">yield</span> self.engine.open_spider(self.spider, start_requests)</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">'sqlite3'</span></span><br></pre></td></tr></table></figure><p><strong>解决办法</strong><br>安装sqlit-devel：yum install sqlite-devel</p><p>尊重作者原文链接：<a href="https://blog.csdn.net/qq_1290259791/article/details/82800002" target="_blank" rel="noopener">https://blog.csdn.net/qq_1290259791/article/details/82800002</a></p><p><strong>还有一种方法就是不适用sqlite3直接使用mysql或者其他数据库！</strong></p><h1 id="主机无法连接虚拟机数据库问题"><a href="#主机无法连接虚拟机数据库问题" class="headerlink" title="主机无法连接虚拟机数据库问题"></a>主机无法连接虚拟机数据库问题</h1><p>问题解析：</p><ol><li><p>虚拟机防火墙没有关闭。</p><ul><li><p>解决方法</p><ul><li><p>查看是否运行</p><blockquote><p>systemctl is-active firewalld.service</p><hr><p>systemctl status firewalld.service</p></blockquote></li><li><p>停止防火墙</p><blockquote><p>systemctl stop firewalld.service</p></blockquote></li></ul></li><li><p>问题原因：</p><p>防火墙拒绝访问了外部连接。</p></li></ul></li><li><p>mysql（mariadb）数据库没有开启允许其他主机连接的设置。</p><ul><li><p>解决方法：</p><ul><li><p>进入数据库使用以下命令。</p><blockquote><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root’@’%’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION;</p><p>flush privileges;</p></blockquote></li></ul></li><li><p>问题原因：</p><p>没有开启外部访问。</p></li></ul></li><li><p>检查主机连接的ip以及密码是否正确，可以先使用虚拟机上面的数据库是否能进去。</p></li><li><p>直接关闭防火墙的方式比较粗暴，我们可以开启指定端口来控制mysql的链接。</p><ul><li><p>解决方法。</p><ul><li><p>进入虚拟机操作窗口。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h1 id="启动python3的软连接问题"><a href="#启动python3的软连接问题" class="headerlink" title="启动python3的软连接问题"></a>启动python3的软连接问题</h1><p>mv  /usr/bin/python /usr/bin/python.bak<br>ln -s /usr/local/python3/bin/python3 /usr/bin/python<br>mv /usr/bin/pip /usr/bin/pip.bak<br>ln -s /usr/local/python3/bin/pip3 /usr/bin/pip<br>验证：python，会出python3<br>验证：pip，会调用pip3</p><h1 id="安装uwsgi后无法使用问题"><a href="#安装uwsgi后无法使用问题" class="headerlink" title="安装uwsgi后无法使用问题"></a>安装uwsgi后无法使用问题</h1><ul><li><p>报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon /]<span class="comment"># uwsgi --version</span></span><br><span class="line">-bash: uwsgi: command <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure></li><li><p>解决：</p><blockquote><p>查看位置： find / -name uwsgi</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon /]<span class="comment"># find / -name uwsgi</span></span><br><span class="line">/usr/local/python3/bin/uwsgi</span><br></pre></td></tr></table></figure><blockquote><p>配置软连接：   ps:软连接在这只作为解决方法 可能大家的python路径都不同酌情安装</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</span><br></pre></td></tr></table></figure><blockquote><p>配置软连之后可以再任何地方运行 uwsgi</p></blockquote><blockquote><p>再次查看版本号</p></blockquote>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]<span class="comment"># uwsgi --version</span></span><br><span class="line"><span class="number">2.0</span><span class="number">.18</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="无法安装scrapy问题"><a href="#无法安装scrapy问题" class="headerlink" title="无法安装scrapy问题"></a>无法安装scrapy问题</h1><p><strong>报错</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collecting Twisted&gt;=<span class="number">10.0</span><span class="number">.0</span> (<span class="keyword">from</span> scrapy)</span><br><span class="line">  Could <span class="keyword">not</span> find a version that satisfies the requirement Twisted&gt;=<span class="number">10.0</span><span class="number">.0</span> (<span class="keyword">from</span> scrapy) (<span class="keyword">from</span> versions: )</span><br><span class="line">No matching distribution found <span class="keyword">for</span> Twisted&gt;=<span class="number">10.0</span><span class="number">.0</span> (<span class="keyword">from</span> scrapy)</span><br></pre></td></tr></table></figure><p>*<em>还有一个错误是提示版本太低的因为这是因为pip insatall twisted 安装的版本低 不能支持python3.6以上的版本 *</em></p><p>由于使用python3.6，因此需要下载最新的17.9.0版本，此版本已经支持python3.6</p><blockquote><p>下载对应python3.6的版本 这里直接给个链接:执行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://twistedmatrix.com/Releases/Twisted/<span class="number">17.9</span>/Twisted<span class="number">-17.9</span><span class="number">.0</span>.tar.bz2</span><br></pre></td></tr></table></figure><blockquote><p>解压下载下来的Twisted-17.9.0.tar.bz2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf Twisted<span class="number">-17.9</span><span class="number">.0</span>.tar.bz2</span><br></pre></td></tr></table></figure><blockquote><p>进入目录</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Twisted<span class="number">-17.9</span><span class="number">.0</span>.tar.bz2</span><br></pre></td></tr></table></figure><blockquote><p>执行：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><blockquote><p>验证</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure><p><strong>安装scrapy，scrapyd</strong></p><blockquote><p>安装scrapy</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><blockquote><p>相同的道理安装scrapyd</p></blockquote><h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">django.core.exceptions.ImproperlyConfigured: </span><br><span class="line">Error loading MySQLdb module. Did you install mysqlclient?</span><br></pre></td></tr></table></figure><p>这是错误的意思是你要不要使用mysql数据库。</p><ul><li><p>检查是否安装了pymysql</p><ul><li>查看：pip3 pymysql</li><li>安装：pip3 install pymysql</li></ul></li><li><p>打开项目与setting.py同级目录的 <code>__init__.py</code>文件配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></li></ul><h1 id="报错-1"><a href="#报错-1" class="headerlink" title="报错"></a>报错</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command <span class="string">"python setup.py egg_info"</span> failed <span class="keyword">with</span> error code <span class="number">1</span></span><br></pre></td></tr></table></figure><p>报出错误为下载工具文件缺失问题：</p><ul><li><p>解决方法：</p><ul><li><p>故通过<a href="https://pypi.org/simple/setuptools-scm/下载补丁setuptools_scm-3.0.6-py2.py3-noneany.whl进行解决。" target="_blank" rel="noopener">https://pypi.org/simple/setuptools-scm/下载补丁setuptools_scm-3.0.6-py2.py3-noneany.whl进行解决。</a></p></li><li><p>通过<strong>pip install setuptools_scm-3.0.6-py2.py3-none-any.whl</strong> </p></li><li><p>后进行<strong>sudo pip install drf-haystack</strong>解决</p></li></ul></li></ul><h1 id="报错-2"><a href="#报错-2" class="headerlink" title="报错"></a>报错</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error loading MySQLdb module:No module named MySQLdb</span><br></pre></td></tr></table></figure><p>原因没有安装 pymysql模块</p><p>解决方法：</p><blockquote><p>pip install pymysql</p></blockquote><h1 id="报错-3"><a href="#报错-3" class="headerlink" title="报错"></a>报错</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/CentOS%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/09/CentOS%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h4 id="1-关机-系统的关机、重启以及登出-的命令、"><a href="#1-关机-系统的关机、重启以及登出-的命令、" class="headerlink" title="1.关机 (系统的关机、重启以及登出 ) 的命令、"></a>1.关机 (系统的关机、重启以及登出 ) 的命令、</h4><table><thead><tr><th>名称</th><th>命令1</th><th>命令2</th><th>命令3</th></tr></thead><tbody><tr><td>关闭系统</td><td>shutdown -h now</td><td>init 0</td><td>telinit 0</td></tr><tr><td>定时关机</td><td>shutdown -h hours:minutes &amp;</td><td></td><td></td></tr><tr><td>取消定时关机</td><td>shutdown -c</td><td></td><td></td></tr><tr><td>重启</td><td>shutdown -r now</td><td>reboot</td><td></td></tr><tr><td>注销</td><td>logout</td><td></td><td></td></tr></tbody></table><p>####2.查看系统信息的命令</p><table><thead><tr><th>名称</th><th>命令1</th><th>命令2</th><th>命令3</th><th>命令4</th></tr></thead><tbody><tr><td>显示机器的处理器架构</td><td>arch</td><td>uname -m</td><td></td><td></td></tr><tr><td>显示正在使用的内核版本</td><td>uname -r</td><td></td><td></td><td></td></tr><tr><td>显示硬件系统部件 - (SMBIOS / DMI)</td><td>dmidecode -q</td><td></td><td></td><td></td></tr><tr><td>罗列一个磁盘的架构特性</td><td>hdparm -i /dev/hda</td><td></td><td></td><td></td></tr><tr><td>在磁盘上执行测试性读取操作</td><td>hdparm -tT /dev/sda</td><td></td><td></td><td></td></tr><tr><td>显示CPU info的信息</td><td>cat /proc/cpuinfo</td><td></td><td></td><td></td></tr><tr><td>显示中断</td><td>cat /proc/interrupts</td><td></td><td></td><td></td></tr><tr><td>校验内存使用</td><td>cat /proc/meminfo</td><td></td><td></td><td></td></tr><tr><td>显示哪些swap被使用</td><td>cat /proc/swaps</td><td></td><td></td><td></td></tr><tr><td>显示内核的版本</td><td>cat /proc/version</td><td></td><td></td><td></td></tr></tbody></table><p>cat /proc/net/dev 显示网络适配器及统计</p><p>cat /proc/mounts 显示已加载的文件系统</p><p>lspci -tv 罗列 PCI 设备</p><p>lsusb -tv 显示 USB 设备</p><p>date 显示系统日期</p><p>cal 2007 显示2007年的日历表</p><p>date 041217002007.00 设置日期和时间 - 月日时分年.秒</p><p>clock -w 将时间修改保存到 BIOS</p><p>####3.文件和目录操作命令</p><p>cd /home 进入 ‘/ home’ 目录’</p><p>cd .. 返回上一级目录</p><p>cd ../.. 返回上两级目录</p><p>cd 进入个人的主目录</p><p>cd ~user1 进入个人的主目录</p><p>cd - 返回上次所在的目录</p><p>pwd 显示工作路径</p><p>ls 查看目录中的文件</p><p>ls -F 查看目录中的文件</p><p>ls -l 显示文件和目录的详细资料</p><p>ls -a 显示隐藏文件</p><p>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’</p><p>mkdir dir1 dir2 同时创建两个目录</p><p>mkdir -p /tmp/dir1/dir2 创建一个目录树</p><p>rm -f file1 删除一个叫做 ‘file1’ 的文件’</p><p>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’</p><p>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容</p><p>rm -rf dir1 dir2 同时删除两个目录及它们的内容</p><p>mv dir1 new_dir 重命名/移动 一个目录</p><p>cp file1 file2 复制一个文件</p><p>cp dir/* . 复制一个目录下的所有文件到当前工作目录</p><p>cp -a /tmp/dir1 . 复制一个目录到当前工作目录</p><p>cp -a dir1 dir2 复制一个目录</p><p>ln -s file1 lnk1 创建一个指向文件或目录的软链接</p><p>ln file1 lnk1 创建一个指向文件或目录的物理链接</p><p>touch file1 创建一个文件</p><p>####4.文件搜索命令</p><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录</p><p>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录</p><p>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件</p><p>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件</p><p>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件</p><p>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令</p><p>whereis file 显示一个二进制文件、源码或man的位置</p><p>which file 显示一个二进制文件或可执行文件的完整路径</p><p>####5.查看文件内容</p><p>cat file1 从第一个字节开始正向查看文件的内容</p><p>tac file1 从最后一行开始反向查看一个文件的内容</p><p>more file1 查看一个长文件的内容</p><p>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作</p><p>head -2 file1 查看一个文件的前两行</p><p>tail -2 file1 查看一个文件的最后两行 5.挂载命令</p><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 (注：确定目录 ‘/ mnt/hda2’ 已经存在)</p><p>umount /dev/hda2 卸载一个叫做hda2的盘 (先从挂载点 ‘/ mnt/hda2’ 退出)</p><p>fuser -km /mnt/hda2 当设备繁忙时强制卸载</p><p>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件(当文件为只读或当磁盘写满时非常有用)</p><p>mount /dev/fd0 /mnt/floppy 挂载一个软盘</p><p>mount /dev/cdrom /mnt/cdrom 挂载一个光盘</p><p>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom</p><p>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom</p><p>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件</p><p>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统</p><p>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备</p><p>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p><p>####6.磁盘空间操作的命令</p><p>df -h 显示已经挂载的分区列表</p><p>ls -lSr |more 以尺寸大小排列文件和目录</p><p>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’</p><p>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小</p><p>####7.用户和群组相关命令</p><p>groupadd group_name 创建一个新用户组</p><p>groupdel group_name 删除一个用户组</p><p>groupmod -n new_group_name old_group_name 重命名一个用户组</p><p>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户</p><p>useradd user1 创建一个新用户</p><p>userdel -r user1 删除一个用户 ( ‘-r’ 同时删除除主目录)</p><p>passwd user1 修改一个用户的口令 (只允许root执行)</p><p>chage -E 2005-12-31 user1 设置用户口令的失效期限</p><p>ls -lh 显示权限</p><p>chmod 777 directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读(r )、写(w)和执行(x)的权限</p><p>chmod 700 directory1 删除群组(g)与其他人(o)对目录的读写执行权限</p><p>chown user1 file1 改变一个文件的所有人属性，为use1。</p><p>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性都为use1所有</p><p>chgrp group1 file1 改变文件的群组为group1</p><p>chown user1:group1 file1 改变一个文件的所有人和群组属性，所属组为group1，用户为use1。</p><p>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件</p><p>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</p><p>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位</p><p>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</p><p>chmod g-s /home/public 禁用一个目录的 SGID 位</p><p>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</p><p>chmod o-t /home/public 禁用一个目录的 STIKY 位</p><p>####8.打包和解压缩文件的命令</p><p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件</p><p>bzip2 file1 压缩一个叫做 ‘file1’ 的文件</p><p>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件</p><p>gzip file1 压缩一个叫做 ‘file1’的文件</p><p>gzip -9 file1 最大程度压缩</p><p>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包</p><p>rar a file1.rar file1 file2 dir1 打包 ‘file1’, ‘file2’ 以及目录 ‘dir1’</p><p>rar x file1.rar 解rar包</p><p>unrar x file1.rar 解rar包</p><p>tar -cvf archive.tar file1 创建一个非压缩的tar包</p><p>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ ‘dir1’的包</p><p>tar -tf archive.tar 显示一个包中的内容</p><p>tar -xvf archive.tar 释放一个包</p><p>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 (-c是指定目录)</p><p>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包</p><p>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包</p><p>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包</p><p>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包</p><p>zip file1.zip file1 创建一个zip格式的压缩包</p><p>zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包</p><p>unzip file1.zip 解压一个zip格式压缩包</p><p>####9.关于RPM 包的命令</p><p>rpm -ivh package.rpm 安装一个rpm包</p><p>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告</p><p>rpm -U package.rpm 更新一个rpm包但不改变其配置文件</p><p>rpm -F package.rpm 更新一个确定已经安装的rpm包</p><p>rpm -e package_name.rpm 删除一个rpm包</p><p>rpm -qa 显示系统中所有已经安装的rpm包</p><p>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包</p><p>rpm -qi package_name 获取一个已安装包的特殊信息</p><p>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表</p><p>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表</p><p>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表</p><p>rpm -q package_name –whatprovides 显示一个rpm包所占的体积</p><p>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l</p><p>rpm -q package_name –changelog 显示一个rpm包的修改历史</p><p>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供</p><p>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表</p><p>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书</p><p>rpm –checksig package.rpm 确认一个rpm包的完整性</p><p>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性</p><p>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</p><p>rpm -Va 检查系统中所有已安装的rpm包- 小心使用</p><p>rpm -Vp package.rpm 确认一个rpm包还未安装</p><p>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件</p><p>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包</p><p>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</p><p>####10.YUM 软件包升级器</p><p>yum install package_name 下载并安装一个rpm包</p><p>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</p><p>yum update package_name.rpm 更新当前系统中所有安装的rpm包</p><p>yum update package_name 更新一个rpm包</p><p>yum remove package_name 删除一个rpm包</p><p>yum list 列出当前系统中安装的所有包</p><p>yum search package_name 在rpm仓库中搜寻软件包</p><p>yum clean packages 清理rpm缓存删除下载的包</p><p>yum clean headers 删除所有头文件</p><p>yum clean all 删除所有缓存的包和头文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/CentOS7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/09/CentOS7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">centos常用命令：</span><br><span class="line"></span><br><span class="line">查看所有运行的单元：systemctl list-units</span><br><span class="line"></span><br><span class="line">查看所有单元：systemctl list-units --all</span><br><span class="line"></span><br><span class="line">查看所有启动的服务：systemctl list-units --type=service 对应以前的chkconfig --list</span><br><span class="line"></span><br><span class="line">查看是否启用，例如防火墙：systemctl <span class="keyword">is</span>-enabled firewalld.service</span><br><span class="line"></span><br><span class="line">查看是否运行，例如防火墙：ystemctl <span class="keyword">is</span>-active firewalld.service或者</span><br><span class="line">systemctl status firewalld.service</span><br><span class="line"></span><br><span class="line">停止防火墙：systemctl stop firewalld.service</span><br><span class="line"></span><br><span class="line">启动防火墙：systemctl start firewalld.service</span><br><span class="line"></span><br><span class="line">重启防火墙：systemctl restart firewalld.service</span><br><span class="line"></span><br><span class="line">重载防火墙：systemctl reload firewalld.service</span><br><span class="line"></span><br><span class="line">注意：当我们使用systemctl的start，restart，stop和reload命令时，</span><br><span class="line">我们不会从终端获取到任何输出内容，只有status命令可以打印输出。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务开机自启动：systemctl enable httpd</span><br><span class="line"></span><br><span class="line">服务不开机自启动：systemctl disable httpd</span><br><span class="line"></span><br><span class="line">使用systemctl命令杀死服务：systemctl kill firewalld.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">获取当前某个服务的CPU分配额，例如防火墙：systemctl show -p CPUShares firewalld.service</span><br><span class="line"></span><br><span class="line">获取某个服务（httpd）的依赖性列表：systemctl list-dependencies httpd.service</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">开启防火墙<span class="number">22</span>端口：iptables -I INPUT -p tcp --dport <span class="number">22</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">查看主机名： hostnamectl status --static</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看某个服务的名称：</span><br><span class="line"></span><br><span class="line">systemctl list-units |grep XXX</span><br></pre></td></tr></table></figure><h1 id="CentOS7-常用命令集合"><a href="#CentOS7-常用命令集合" class="headerlink" title="CentOS7 常用命令集合"></a>CentOS7 常用命令集合</h1><p>​       这两天一直在对CentOS 7.2进行初体验，各种学习命令肿么用，不过其实大多和DOS是一样的，只是命令的表达上可能有点儿不一样，毕竟这些都不是一家出来的嘛~</p><p>​       废话不多说，直接上命令和解析！</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="文件与目录操作"><a href="#文件与目录操作" class="headerlink" title="文件与目录操作"></a>文件与目录操作</h3><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>cd /home</td><td>进入 ‘/home’ 目录</td></tr><tr><td>cd ..</td><td>返回上一级目录</td></tr><tr><td>cd ../..</td><td>返回上两级目录</td></tr><tr><td>cd -</td><td>返回上次所在目录</td></tr><tr><td>cp file1 file2</td><td>将file1复制为file2</td></tr><tr><td>cp -a dir1 dir2</td><td>复制一个目录</td></tr><tr><td>cp -a /tmp/dir1 .</td><td>复制一个目录到当前工作目录（.代表当前目录）</td></tr><tr><td>ls</td><td>查看目录中的文件</td></tr><tr><td>ls -a</td><td>显示隐藏文件</td></tr><tr><td>ls -l</td><td>显示详细信息</td></tr><tr><td>ls -lrt</td><td>按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序）</td></tr><tr><td>pwd</td><td>显示工作路径</td></tr><tr><td>mkdir dir1</td><td>创建 ‘dir1’ 目录</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个目录</td></tr><tr><td>mkdir -p /tmp/dir1/dir2</td><td>创建一个目录树</td></tr><tr><td>mv dir1 dir2</td><td>移动/重命名一个目录</td></tr><tr><td>rm -f file1</td><td>删除 ‘file1’</td></tr><tr><td>rm -rf dir1</td><td>删除 ‘dir1’ 目录及其子目录内容</td></tr></tbody></table><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>cat file1</td><td>从第一个字节开始正向查看文件的内容</td></tr><tr><td>head -2 file1</td><td>查看一个文件的前两行</td></tr><tr><td>more file1</td><td>查看一个长文件的内容</td></tr><tr><td>tac file1</td><td>从最后一行开始反向查看一个文件的内容</td></tr><tr><td>tail -3 file1</td><td>查看一个文件的最后三行</td></tr><tr><td>vi file</td><td>打开并浏览文件</td></tr></tbody></table><h3 id="文本内容处理"><a href="#文本内容处理" class="headerlink" title="文本内容处理"></a>文本内容处理</h3><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>grep str /tmp/test</td><td>在文件 ‘/tmp/test’ 中查找 “str”</td></tr><tr><td>grep ^str /tmp/test</td><td>在文件 ‘/tmp/test’ 中查找以 “str” 开始的行</td></tr><tr><td>grep [0-9] /tmp/test</td><td>查找 ‘/tmp/test’ 文件中所有包含数字的行</td></tr><tr><td>grep str -r /tmp/*</td><td>在目录 ‘/tmp’ 及其子目录中查找 “str”</td></tr><tr><td>diff file1 file2</td><td>找出两个文件的不同处</td></tr><tr><td>sdiff file1 file2</td><td>以对比的方式显示两个文件的不同</td></tr><tr><td>vi file</td><td>操作解析i进入编辑文本模式Esc退出编辑文本模式:w保存当前修改:q不保存退出vi:wq保存当前修改并退出vi</td></tr></tbody></table><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>find / -name file1</td><td>从 ‘/’ 开始进入根文件系统查找文件和目录</td></tr><tr><td>find / -user user1</td><td>查找属于用户 ‘user1’ 的文件和目录</td></tr><tr><td>find /home/user1 -name *.bin</td><td>在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件</td></tr><tr><td>find /usr/bin -type f -atime +100</td><td>查找在过去100天内未被使用过的执行文件</td></tr><tr><td>find /usr/bin -type f -mtime -10</td><td>查找在10天内被创建或者修改过的文件</td></tr><tr><td>locate *.ps</td><td>寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令</td></tr><tr><td>find -name ‘*.[ch]’ | xargs grep -E ‘expr’</td><td>在当前目录及其子目录所有.c和.h文件中查找 ‘expr’</td></tr><tr><td>find -type f -print0 | xargs -r0 grep -F ‘expr’</td><td>在当前目录及其子目录的常规文件中查找 ‘expr’</td></tr><tr><td>find -maxdepth 1 -type f | xargs grep -F ‘expr’</td><td>在当前目录中查找 ‘expr’</td></tr></tbody></table><h3 id="压缩、解压"><a href="#压缩、解压" class="headerlink" title="压缩、解压"></a>压缩、解压</h3><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>bzip2 file1</td><td>压缩 file1</td></tr><tr><td>bunzip2 file1.bz2</td><td>解压 file1.bz2</td></tr><tr><td>gzip file1</td><td>压缩 file1</td></tr><tr><td>gzip -9 file1</td><td>最大程度压缩 file1</td></tr><tr><td>gunzip file1.gz</td><td>解压 file1.gz</td></tr><tr><td>tar -cvf archive.tar file1</td><td>把file1打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）</td></tr><tr><td>tar -cvf archive.tar file1 dir1</td><td>把 file1，dir1 打包成 archive.tar</td></tr><tr><td>tar -tf archive.tar</td><td>显示一个包中的内容</td></tr><tr><td>tar -xvf archive.tar</td><td>释放一个包</td></tr><tr><td>tar -xvf archive.tar -C /tmp</td><td>把压缩包释放到 /tmp目录下</td></tr><tr><td>zip file1.zip file1</td><td>创建一个zip格式的压缩包</td></tr><tr><td>zip -r file1.zip file1 dir1</td><td>把文件和目录压缩成一个zip格式的压缩包</td></tr><tr><td>unzip file1.zip</td><td>解压一个zip格式的压缩包到当前目录</td></tr><tr><td>unzip test.zip -d /tmp/</td><td>解压一个zip格式的压缩包到 /tmp 目录</td></tr></tbody></table><h3 id="yum安装器"><a href="#yum安装器" class="headerlink" title="yum安装器"></a>yum安装器</h3><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>yum -y install [package]</td><td>下载并安装一个rpm包</td></tr><tr><td>yum localinstall [package.rpm]</td><td>安装一个rpm包，使用你自己的软件仓库解决所有依赖关系</td></tr><tr><td>yum -y update</td><td>更新当前系统中安装的所有rpm包</td></tr><tr><td>yum update [package]</td><td>更新一个rpm包</td></tr><tr><td>yum remove [package]</td><td>删除一个rpm包</td></tr><tr><td>yum list</td><td>列出当前系统中安装的所有包</td></tr><tr><td>yum search [package]</td><td>在rpm仓库中搜寻软件包</td></tr><tr><td>yum clean [package]</td><td>清除缓存目录（/var/cache/yum）下的软件包</td></tr><tr><td>yum clean headers</td><td>删除所有头文件</td></tr><tr><td>yum clean all</td><td>删除所有缓存的包和头文件</td></tr></tbody></table><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>ifconfig eth0</td><td>显示一个以太网卡的配置</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>配置网卡的IP地址</td></tr><tr><td>ifdown eth0</td><td>禁用 ‘eth0’ 网络设备</td></tr><tr><td>ifup eth0</td><td>启用 ‘eth0’ 网络设备</td></tr><tr><td>iwconfig eth1</td><td>显示一个无线网卡的配置</td></tr><tr><td>iwlist scan</td><td>显示无线网络</td></tr><tr><td>ip addr show</td><td>显示网卡的IP地址</td></tr></tbody></table><h3 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h3><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>su -</td><td>切换到root权限（与su有区别）</td></tr><tr><td>shutdown -h now</td><td>关机</td></tr><tr><td>shutdown -r now</td><td>重启</td></tr><tr><td>top</td><td>罗列使用CPU资源最多的linux任务 （输入q退出）</td></tr><tr><td>pstree</td><td>以树状图显示程序</td></tr><tr><td>man ping</td><td>查看参考手册（例如ping 命令）</td></tr><tr><td>passwd</td><td>修改密码</td></tr><tr><td>df -h</td><td>显示磁盘的使用情况</td></tr><tr><td>cal -3</td><td>显示前一个月，当前月以及下一个月的月历</td></tr><tr><td>cal 10 1988</td><td>显示指定月，年的月历</td></tr><tr><td>date –date ‘1970-01-01 UTC 1427888888 seconds’</td><td>把一相对于1970-01-01 00:00的秒数转换成时间</td></tr></tbody></table><h2 id="XSheel-5相关操作"><a href="#XSheel-5相关操作" class="headerlink" title="XSheel 5相关操作"></a>XSheel 5相关操作</h2><h3 id="窗体快捷键"><a href="#窗体快捷键" class="headerlink" title="窗体快捷键"></a>窗体快捷键</h3><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>Ctrl + u</td><td>删除光标之前到行首的字符</td></tr><tr><td>Ctrl + k</td><td>删除光标之前到行尾的字符</td></tr><tr><td>Ctrl + c</td><td>取消当前行输入的命令，相当于Ctrl + Break</td></tr><tr><td>Ctrl + a</td><td>光标移动到行首（ahead of line），相当于通常的Home键</td></tr><tr><td>Ctrl + e</td><td>光标移动到行尾（end of line）</td></tr><tr><td>Ctrl + f</td><td>光标向前（forward）移动一个字符位置</td></tr><tr><td>Ctrl + b</td><td>光标往回（backward）移动一个字符位置</td></tr><tr><td>Ctrl + l</td><td>清屏，相当于执行clear命令</td></tr><tr><td>Ctrl + r</td><td>显示:号提示，根据用户输入查找相关历史命令（reverse-i-search）</td></tr><tr><td>Ctrl + w</td><td>删除从光标位置前到当前所处单词（word）的开头</td></tr><tr><td>Ctrl + t</td><td>交换光标位置前的两个字符</td></tr><tr><td>Ctrl + y</td><td>粘贴最后一次被删除的单词</td></tr><tr><td>Ctrl + Alt + d</td><td>显示桌面</td></tr><tr><td>Alt + b</td><td>光标往回（backward）移动到前一个单词</td></tr><tr><td>Alt + d</td><td>删除从光标位置到当前所处单词的末尾</td></tr><tr><td>Alt + F2</td><td>运行</td></tr><tr><td>Alt + F4</td><td>关闭当前窗口</td></tr><tr><td>Alt + F9</td><td>最小化当前窗口</td></tr><tr><td>Alt + F10</td><td>最大化当前窗口</td></tr><tr><td>Alt + Tab</td><td>切换窗口</td></tr><tr><td>Alt + 左键</td><td>移动窗口（或在最下面的任务栏滚动鼠标滑轮）</td></tr></tbody></table><h3 id="操作小技巧"><a href="#操作小技巧" class="headerlink" title="操作小技巧"></a>操作小技巧</h3><p>​       鼠标中间键：粘贴突出显示的文本。(使用鼠标左键来选择文本。把光标指向想粘贴文本的地方。点击鼠标中间键来粘贴。)</p><p>​       Tab：命令行自动补全。使用 shell 提示时可使用这一方式。键入命令或文件名的前几个字符，然后按 [Tab] 键，它会自动补全命令或显示匹配键入字符的所有命令。</p><p>​       在滚动条的空白处点击鼠标中键：屏幕即滚动到那个地方。</p><p>​       在桌面或文件管理器中直接按 / 就可以输入位置，打开文件管理器。</p><p>​       在 vi 或 Firefox 中直接按 / 即可进入快速搜索状态。</p><p>​       网站链接和图片可直接拖放到桌面或者目录，可以马上下载。</p><p>​       直接将文件管理器中的文件拖到终端中就可以在终端中得到完整的路径名。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>​       其实要学好Linux的操作并不是很困难的事情，在平常的使用过程中，碰到问题，学会去网上寻找答案不失为一个非常好的手段！谢谢大家！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/13-Django-%E6%9D%82%E5%BF%97%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0-%E6%A8%A1%E6%9D%BF%E9%9B%86%E6%88%90/"/>
      <url>/2019/08/09/13-Django-%E6%9D%82%E5%BF%97%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0-%E6%A8%A1%E6%9D%BF%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<ul><li>Nginx负载均衡<ul><li>必须要安装好</li><li>uwsgi</li></ul></li><li>nosql：<ul><li>mongdb</li><li>redis</li><li>memcached：<ul><li>name:’张三’, age:’16’</li></ul></li></ul></li><li>memcached<ul><li>服务端：<ul><li>apt-get install memcached</li></ul></li><li>客户端：<ul><li>pip install python-memcached</li></ul></li></ul></li><li>nosql的可视化工具：<br>* </li><li>memcached内存结构<ul><li>chunk</li><li>slabs </li><li>Slab Class</li><li>过期缓存是否会被删除，删除怎么删？</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/12-Django-%E6%9D%82%E5%BF%97%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/08/09/12-Django-%E6%9D%82%E5%BF%97%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="用户模块视图"><a href="#用户模块视图" class="headerlink" title="用户模块视图"></a>用户模块视图</h2><ul><li><p>头像：</p><ul><li><p>头像文件为了避免重名，要用时间或者md5去处理</p><ul><li>1.png -&gt; 1238198asjkhdhkas.png</li><li>1.png -&gt; 1asdjkhkjczxhckjasd.png</li></ul></li><li><p>用户一旦修改头像，之前的头像直接覆盖即可</p><ul><li>10.png</li></ul></li></ul></li><li><p>注册</p><ul><li>必须在用户没有登陆的情况下进行注册功能</li><li>get<ul><li>返回表单页面</li></ul></li><li>post<ul><li>获取表单数据<ul><li>为空</li><li>昵称长度 &lt;= 4</li><li>密码长度 &gt;=8 </li><li>from_data[‘name’] = {‘error’:’昵称不能为空’}</li></ul></li><li>判断数据库重复<ul><li>from_data[‘error’] = ‘账号重复’</li></ul></li><li>存入数据库<ul><li>密码使用make_password</li></ul></li></ul></li></ul></li><li><p>登陆</p><ul><li><p>在未登陆情况下才能登陆</p></li><li><p>get</p></li><li><p>post</p><ul><li><p>账号是否存在</p><ul><li>user = User.get()</li></ul></li><li><p>校验密码</p><ul><li>check_password(password,user.password())</li></ul></li><li><p>session设置</p><ul><li>key:user value:user.id</li></ul></li><li></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/08/09/11-Django-%E6%9D%82%E5%BF%97%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0-%E4%B8%9A%E5%8A%A1%E5%88%86%E6%9E%90/"/>
      <url>/2019/08/09/11-Django-%E6%9D%82%E5%BF%97%E5%8E%9F%E7%94%9F%E5%B9%B3%E5%8F%B0-%E4%B8%9A%E5%8A%A1%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="原生杂志平台需求文档"><a href="#原生杂志平台需求文档" class="headerlink" title="原生杂志平台需求文档"></a>原生杂志平台需求文档</h2><h2 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h2><blockquote><p>123456  -&gt; asjdklajdlakjd</p><p>root -&gt; ajdkaldjklasjdjd</p><p>admin</p><p>test</p></blockquote><h3 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h3><h4 id="抽象基类表-Base"><a href="#抽象基类表-Base" class="headerlink" title="抽象基类表:Base"></a>抽象基类表:Base</h4><blockquote><p>将用户、后面其他权限表 角色表的相同属性 作为抽象基类继承</p></blockquote><ul><li><p><strong>create_time</strong> = <code>Datetime</code></p><blockquote><p>auto_now_add = True </p><p>这条数据创建时，直接定义成当前时间</p></blockquote></li><li><p><strong>modify_time</strong> = <code>Datetime</code></p><blockquote><p>auto_now = True</p><p>当这条数据被修改时，自动同步成当前时间</p></blockquote></li><li><p><strong>name</strong> = <code>Char</code></p><blockquote><p>require=True</p><p>数据的名称</p></blockquote></li></ul><h4 id="用户表-User"><a href="#用户表-User" class="headerlink" title="用户表:User"></a>用户表:User</h4><blockquote><p>只存储用户的基本信心，不存储相关权限字段</p></blockquote><ul><li><p><strong>account</strong> = <code>CharField</code></p><blockquote><p>max_length=[8,+] ,50</p><p>unique = True</p></blockquote></li><li><p><strong>password</strong> = <code>CharField</code></p><table><thead><tr><th>md5</th><th>sha256</th><th>sha1</th></tr></thead><tbody><tr><td>速度快</td><td>速度中等</td><td>速度慢</td></tr><tr><td>质量稍低</td><td>质量中等</td><td>质量最高</td></tr></tbody></table><blockquote><p>salt：盐值</p><p>123456 -&gt; -&gt; adjkasjlkzxcndajdka</p><p>密码的创建要用到 ：make_password check_password</p><p>15 </p><p>max_length=100</p></blockquote></li><li><p><strong>email</strong> = <code>Email</code></p><blockquote><p>邮箱字段，发邮件</p><p>密码找回：回调连接，验证码</p></blockquote></li><li><p><strong>login_time</strong> = <code>Decimal</code></p><blockquote><p>保存用户在线时间，单位是分钟数</p><p>default = 0</p></blockquote></li><li><p><strong>is_active</strong> = <code>Bool</code></p><blockquote><p>表示用户是否处于活跃状态，活跃状态可登陆</p><p>default = True</p></blockquote></li><li><p><strong>ip</strong> = <code>GenericIPAddress</code></p></li><li><p>avator = <code>Image</code></p><blockquote><p>pip3 install pillow 解析文件是否是一个图片</p><p>用户头像字段</p><img href="1.mp3"><p>null=Ture,blank=True</p></blockquote></li><li><p><strong>gender</strong> = <code>Char</code></p><blockquote><p>保存性别，最大长度为1</p><p>0，1，2，3，4，5，6</p></blockquote></li><li><p>phone = <code>Char</code></p><blockquote><p>max_length=11</p><p>存储用户手机号</p><p>null =True,blank=True</p></blockquote></li><li><p>role  = <code>ForeignKey</code></p><blockquote><p>外键关联角色表，代表当前用户的具体权限</p><p>null = True</p><p>blank = True</p><p>models.SET_NULL</p></blockquote></li></ul><h5 id="用户表属性"><a href="#用户表属性" class="headerlink" title="用户表属性"></a>用户表属性</h5><ul><li>unique_together =  ( (email,  phone, account),)</li></ul><h4 id="角色表-Role"><a href="#角色表-Role" class="headerlink" title="角色表:Role"></a>角色表:Role</h4><blockquote><p>用来</p></blockquote><ul><li><p>role_count = <code>Int</code></p><blockquote><p>保存有多少用户是这个角色</p><p>default=0</p></blockquote></li><li><p>permission = <code>ManyToMany</code></p><blockquote><p>当前角色多对多关联的权限</p><p>代表这个角色有什么样的权限</p></blockquote></li><li><p>is_active = <code>Bool</code></p><blockquote><p>表示当前角色是否有效，可否使用</p><p>default=True</p></blockquote></li></ul><h4 id="权限表-Permission"><a href="#权限表-Permission" class="headerlink" title="权限表:Permission"></a>权限表:Permission</h4><ul><li><p>action = <code>Char</code></p><blockquote><p>表示当前的具体某一个权限</p></blockquote></li><li><p>per_cate = <code>ForeignKey</code></p><blockquote><p>权限的分类，用来在存储同样标识，但是不同业务权限时，进行区分</p><p>1 ,2 ,4 ,8  1, 2 ,4 ,8</p><p>1.per_cate = ‘user’</p><p>1.per_cate = ‘mag’</p></blockquote></li></ul><h5 id="权限表属性"><a href="#权限表属性" class="headerlink" title="权限表属性"></a>权限表属性</h5><ul><li>unique_together =  ( (action ,  per_cate ),)</li></ul><h4 id="权限分类"><a href="#权限分类" class="headerlink" title="权限分类"></a>权限分类</h4><ul><li><p>name：</p><ul><li>10001：用户</li><li>10002：商品</li><li>10003：店铺 </li></ul></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> user.role.permission.filter(Q(per_cate__name=<span class="string">'10001'</span>) &amp; Q(action=<span class="number">1</span> ))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>02-区块链</title>
      <link href="/2019/08/09/102-%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2019/08/09/102-%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="4-5区块链为什么具有革命性意义"><a href="#4-5区块链为什么具有革命性意义" class="headerlink" title="4.5区块链为什么具有革命性意义"></a>4.5区块链为什么具有革命性意义</h3><p>区块链是生产关系的变更，区块链能够创建信任，减少中间环节，可以使人类的生产结构产生重大变革。</p><h3 id="4-6区块链按应用场景分类"><a href="#4-6区块链按应用场景分类" class="headerlink" title="4.6区块链按应用场景分类"></a>4.6区块链按应用场景分类</h3><ul><li><p>公有链</p><p>特点：所有人都可以随时自带的加入和退出，每个节点平等，都有交易和记账，属于<font color="red">开放式</font>.</p><p>代表：比特币、以太坊、EOS、NEO、量子链、比原链、井通链。</p></li><li><p>联盟链</p><p>特点：</p><ul><li>仅部分人参与，加入和退出需要授权，选定某个节点为记账人，其他人都可以交易，但是无权记账，属于<font color="red">半封闭式</font></li></ul><p>代表：</p><ul><li>R3CEV : 全球40多个银行成立的联盟阻止，2017年7月成立，共享区块链技术。</li><li>IBM farbric项目：Linux基金会发起的超级账本（HyperLedger）项目，2015年成立，farbric是子项目。</li></ul></li><li><p>私有链</p><p>特点：公司内部使用，<font color="red">可以更好的权限控制：管理和审计，属于封闭式。</font></p><p>代表：以太坊可以定制自己的私有链、商用区块链定制。</p></li></ul><h3 id="4-7区块链相关概念"><a href="#4-7区块链相关概念" class="headerlink" title="4.7区块链相关概念"></a>4.7区块链相关概念</h3><h4 id="★矿工"><a href="#★矿工" class="headerlink" title="★矿工"></a>★矿工</h4><p>由运行比特币客户端的节点充当，竞争记账权，从而获得近奖励</p><p><strong>Bit Coin Mining</strong></p><h4 id="★矿机"><a href="#★矿机" class="headerlink" title="★矿机"></a>★矿机</h4><p>CPU挖矿  –&gt;  GPU挖矿   –&gt;  FPGA挖矿   –&gt; ASIC挖矿（专机挖矿）</p><ul><li><p>CPU是电脑核心处理单元</p></li><li><p>GPU是图像处理的处理单元，计算能力更强，GPU的效率是CPU的四倍。</p></li><li><p>FPGA 是一个可编程的芯片，可以把芯片完全用于计算</p></li><li><p>ASIC 专门放置这些算法的专用工具。</p></li></ul><p>矿机吞并了市场后发出CPUS DPUS 模式。拥有矿机的人并不关心社区的发展，脱离算力限制。</p><p><strong>比特大陆：蚂蚁矿机</strong></p><h4 id="★矿场"><a href="#★矿场" class="headerlink" title="★矿场"></a>★矿场</h4><p>集中矿机、设备的场所</p><h4 id="★矿池"><a href="#★矿池" class="headerlink" title="★矿池"></a>★矿池</h4><p>一个软件，矿场和普通矿工接入，矿池负责打包，接入的设备负责挖矿，按照贡献的算力的比例来来分配收益。</p><p>主流矿池：鱼池、蚂池、币网、国池等</p><h4 id="★算力"><a href="#★算力" class="headerlink" title="★算力"></a>★算力</h4><p>1p =1024T，1T=1024G，1G=1024M，1M=1024K</p><p>算力即计算能力，表名一个矿工挖矿能力的，算力越大算出哈希值的概率越高单位为<code>hash/s</code>,即每秒计算哈希的次数，</p><p>例如：</p><p>14T计算能力的矿机，每秒计算哈希次数为<code>1.4 * 10^13</code>,目前算力为<code>4 * 3 10^7TH/s</code>，即每秒运算次数为：<code>4.3 * 10^20</code>，这是全网的算力</p><h4 id="★分叉"><a href="#★分叉" class="headerlink" title="★分叉"></a>★分叉</h4><p><strong>代码升级时不同社区意见发生分歧的结果、重大BUG修复是会分叉</strong></p><ul><li><p>软分叉</p><p>旧节点接收新协议产生的区块，毫无感知，新老协议共同维护一条链。</p></li><li><p>硬分叉</p><p>硬分叉是指块区格式或交易格式发生变化时，未升级的节点拒绝验证已经升级的节点产生的区块，不过已经升级的节点可以验证未升级的节点产出的区块，然后大家各自延续自己认为正确的链，所以分成两个链条。</p><p>特定事件内完成升级未升级的区块会被分离处理形成新的区块。</p><p>旧节点拒绝接受新节点创造的区块，从此分裂为两条独立的链</p><p>案例：以太坊分叉，分为ETC（以太经典），ETN（以太坊V神）</p></li></ul><h4 id="★叔块（孤块）"><a href="#★叔块（孤块）" class="headerlink" title="★叔块（孤块）"></a>★叔块（孤块）</h4><p>在同一时间出现两个矿工同时出矿的情况，此时出现临时的分叉，区块链会同时保留两条链，并且等待生成新的区块，新区块选择连接的链就是最长的链，即 主链，那么另外一个区块就被称为叔块（以太坊，有奖励）/孤块（比特币，无奖励）</p><h4 id="★节点"><a href="#★节点" class="headerlink" title="★节点"></a>★节点</h4><ul><li><p>轻节点SPV（Simplifed Payment Verification)</p><p>手机端钱包，只同步所有的区块头信息以及和自己先关的交易数据。</p></li><li><p>全节点</p><p>包含全账本的节点</p></li></ul><h4 id="★代币（Token）"><a href="#★代币（Token）" class="headerlink" title="★代币（Token）"></a>★代币（Token）</h4><p>创建交易以及运行智能合约运行的燃料</p>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01-区块链</title>
      <link href="/2019/08/09/101-%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
      <url>/2019/08/09/101-%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h4 id="4-1区块链是什么"><a href="#4-1区块链是什么" class="headerlink" title="4.1区块链是什么"></a>4.1区块链是什么</h4><p>从不同角度上来剖析，我们可以这样来看待区块链：</p><hr><ul><li><p>一种分布式数据库（本质）</p><p>每个用户都可以通过和发的手段进行读写，不存储于某一辆特定的服务器或者安全节点，而是分布式存放于网络上所有的完整节点上，每个节点保留一个备份。</p></li><li><p>一种网络底层协议（抽象）</p><p>它是一种共识协议，基于这种协议，可以再其上开发出各种应用，这些应用在每一时刻都保存一条最长的、最权威的、共同认可的数据记录，并遵循共同认可的机制进行无需中间权威仲裁的、直接的、点对点的交互信息。</p><blockquote><p>TCP/TP ： (数据层、网络层、传输层、应用)</p><p>区块链：数据层、网络层、共识层、激励层、应用层、应用</p></blockquote></li></ul><blockquote><p>一、数据层</p><p>数据层主要描述区块链技术的物理形式。区块链系统设计的技术人员们首先建立的一个起始节点是“创世区块”，之后在同样规则下创建的规格相同的区块通过一个链式的结构依次相连组成一条主链条。随着运行时间越来越长，新的区块通过验证后不断被添加到主链上，主链也会不断地延长。</p><p>每个区块中也包含了许多技术，比如时间戳技术，它可以确保每一个区块按时间顺序相连接；再比如哈希函数，它能够确保交易信息不被篡改。</p><p>二、网络层</p><p>网络层的主要目的是实现区块链网络中节点之间的信息交流。区块链网络本质上是一个P2P（点对点）网络。每一个节点既接收信息，也产生信息。节点之间通过维护一个共同的区块链来保持通信。[13]</p><p>区块链的网络中，每一个节点都可以创造新的区块，在新区块被创造后会以广播的形式通知其他节点，其他节点会对这个区块进行验证，当全区块链网络中超过51%的用户验证通过后，这个新区块就可以被添加到主链上了。图2–72 区块链的网络层    </p><p>三、共识层    </p><p>共识层能让高度分散的节点在去中心化的系统中高效地针对区块数据的有效性达成共识。区块链中比较常用的共识机制主要有工作量证明、权益证明和股份授权证明三种，我们在下面的章节中会重点讲解。   </p><p>四、激励层 </p><p>激励层的主要功能是提供一定的激励措施，鼓励节点参与区块链的安全验证工作。我们以比特币为例，它的奖励机制有两种。在比特币总量达到2 100万枚之前，奖励机制有两种，新区块产生后系统奖励的比特币和每笔交易扣除的比特币（手续费）。而当比特币总量达到2 100万时，新产生的区块将不再生成比特币，这时奖励机制主要是每笔交易扣除的手续费。   </p><p>五、合约层</p><p>合约层主要是指各种脚本代码、算法机制以及智能合约等。我们以比特币为例，比特币是一种可编程的货币，合约层封装的脚本中规定了比特币的交易方式和过程中涉及的种种细节。</p><p>六、应用层</p><p>应用层封装了区块链的各种应用场景和案例，比如基于区块链的跨境支付平台OKLink，以及在“应用篇”中我们将讲到的五花八门的应用。</p></blockquote><ol><li><p>区块链是分布式的，区块链公信力在网络上会有许多独立的节点，每一节点都有一份备份信息。每个有授权的人都可以从任意一个节点下载全部的信息，同时，区块链公信力网络也是不可篡改的，任何节点企图更改信息都会被其他节点发现，而更改的节点不会被确认，就会立刻丧失公信力。</p></li><li><p>在区块链公信力模型中，区块链不制定政策，它只是一个公证人的角色，是政府建立和执行政策的工具。区块链的作用是帮助政府更快速和准确地让政策被全民所接受与认可，同时，因为区块链是一个不变的、可以被复制的数据库，政府的政策就变得公开和透明。</p><p>从信任的角度来看，区块链实际上是用基于共识的数学方法，在机器之间建立信任并完成信用创造。基于这样的特点，其对公信力的提升也有着开创性的意义。《经济学人》杂志这样写道：区块链是一台创造信任的机器，可以说区块链最核心的问题就是解决信用共识的问题。</p></li></ol><h4 id="4-2区块链的特点"><a href="#4-2区块链的特点" class="headerlink" title="4.2区块链的特点"></a>4.2区块链的特点</h4><ul><li><p>去中心化</p><p>所有参与其中的网络节点共同维护，无需中心节点调控</p></li><li><p>不可篡改</p><p>整个链条按照时间顺序哈希指针连接起来、环环相扣</p><p>每个交易有时间戳，</p><p>每个区块也有时间戳，如果A变B肯定变。增加了溯源。</p></li><li><p>匿名性</p><p>私钥和地址是使用网络所有条件，无需身份验证</p></li><li><p>可溯源</p><p>所有写入区块的数据需多方验证、公开透明</p></li></ul><h4 id="4-3区块链的发展"><a href="#4-3区块链的发展" class="headerlink" title="4.3区块链的发展"></a>4.3区块链的发展</h4><ul><li><p><strong>V1.0 数字货币（可编程货币）</strong></p><p>1.0仅是电子货币</p><p>特点：TPS低，比特币每秒处理7比交易，基于栈编程，图灵不完备（无循环语句，不能实现复杂的编程）</p><ul><li>专款专用</li></ul></li></ul><ul><li><p><strong>V2.0智能合同（可编程金融）</strong></p><p>区块链2.0是可编程金融、是经济、市场和金融领域的区块链应用，</p><p>例如：</p><p>​    股票、债券、期贷、贷款、抵押、产权、智能财产和智能合约。</p><p>代表：</p><p>​    <font color="red">以太坊（ETH）</font> 、 小蚁（NEO） 、 比原（BTM）</p><p>特点：处理速度加快、图灵完备（可以用代码实现各种复杂逻辑）</p></li><li><p><strong>V3.0 高级智能合同（可编程社会）</strong></p><p>区块链与社会，区块链与各个行业金融：物联网、存储、游戏、区块链+</p><p>代表：</p><p>​    柚子（EOS）、墨客（MOAC）</p></li></ul><h4 id="4-4区块链协议层"><a href="#4-4区块链协议层" class="headerlink" title="4.4区块链协议层"></a>4.4区块链协议层</h4><ul><li><p>数据层</p><ul><li>区块数据</li><li>链式结构</li><li>非对称加密</li><li>哈希函数</li><li>Merkel树</li><li>时间戳</li></ul></li><li><p>网络层</p><ul><li>P2P2网络</li><li>传播机制</li><li>验证机制（自组网的）</li></ul></li><li><p>共识层</p><p>共识机制：共识机制是指可以使所有节点对某一种状态达成一致的方式，共识机制去中心化才有意义，才具备可信度，否则只是数据共享，目前主流的共识机制有：</p><ul><li><p>POW</p><p><code>POW（Proof Of Work , 工作量证明），比特币在Block的生成过程中使用了POW机制，一个符合要求的Block Hash 由N个签到零构成，零的个数决定于网络的难度值，要得到合理的Block Hash 需要大量尝试计算，计算时间决定于机器的哈希运算速度。当某个节点提供一个合理的Block Hash值，说明该节点确实胫骨了大量的尝试计算，当然，并不能得出计算次数的绝对值，因为寻找合理的hash是一个概率事件。当节点拥有全网n%的算力时，该节点即有n/100的概率挖到矿。</code></p><p>特点：</p><ul><li>算一道很难的谜题，系统给予挖矿奖励。</li><li>多劳多得【社会主义】</li></ul><p>优点：</p><ol><li><p>所有节点均可参与，记账权公平的分派到每个节点，去中心化</p></li><li><p>多劳多得，矿工积极性高</p></li><li><p>安全性高，欺诈成本高。</p><p>如果真的可以欺诈成功，有那么强打的算力。不如作为一个诚实的节点那样收益会更高。</p></li></ol><p>缺点：</p><ol><li><p>非主流矿池垄断严重，存在51%算力攻击风险。</p><p>如果某一个用户的算力掌握到百分51那样他就可以为所欲为，但是这样情况概率极低。</p></li><li><p>浪费资源严重（2018年底消耗了全球0.5%电量）</p></li><li><p>持币人没有话语权、算力决定一切</p></li><li><p>网络新能底，共识时间长。</p></li></ol><p>项目：</p><ol><li>比特币</li><li>以太坊</li><li>比原链等</li></ol></li><li><p>POS</p><p><code>POS（Proof Of Stake ,股权证明），类似于财产存储在银行，这种模式会根据你持有的数字货币的数量和时间，分配给你响应的利息。举个栗子，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在股权证明POS模式下，有一个名次叫做币龄，每个币每天产生一个币龄，比如你持有100个币，总共持续了30天，name，此时你的币龄就是3000，这时候，如果你发现了一个POS区块，你的币龄就会被清空为0.你每清空365币龄，你将会从区块中获得0.05个币的利息（假定利息可以理解为年利率5%），name在这个案例中，利息 = 3000 * 5% / 265 =0.41 个币，持币有利息。具体的利息不同的币种不一样。</code></p><p><code>鼓励用户将货币留在自己手里，被动的提高了货币的价值。</code></p><p>特点：</p><ol><li>不挖矿，依靠币龄（币龄持有数量 * 持有天数）决定记账权，利息即为奖。</li><li>按钱分配，钱生钱（资本主义）</li></ol><p>优点：</p><ol><li>在一定程度上缩短了共识达成的时间。</li><li>节约资源。</li><li>防作弊，币龄越大，获取记账权几率越大、避免51%攻击，因为攻击会是自己权益受损。</li></ol><p>缺点：</p><ol><li>数字货币过于集中化，富有的人越来越富有，散户参与积极性低。</li></ol><p>项目：</p><ol><li>ADA等</li></ol></li><li><p>DPOS</p><p><code>DPOS(Delegated Proof Of Stake, 委托权益证明)，他的原理是让每个持有币的人进行投票，由此产生N个代表，我们可以理解为N个超级节点或者矿池，这N个超级节点彼此的权利是完全相等的。从某种角度来看，DPOS有点像议会制度或人民代表大会制度。如果代表不能履行他们的职责（当轮到他们的时候，没有生成区块），他们会被出名，网络会选出新的超级节点来取代他们。DPOS的出现最主要还是因为矿机的产生，大量的算力在不了解也不关心比特币的人身上，类似于演唱会的黄牛，大量囤票而丝毫不关心比特币的内容。</code></p><p>特点：不挖矿，每年按比例增发代币，奖励超级节点。</p><p>优点：高效，拓展性强。</p><p>缺点：21个节点太少，非去中心化，而是多中心化。</p><p>项目：EOS</p></li><li><p>PBFT</p></li><li><p>POW + POS 混合模式</p><p><code>让挖矿和持币人均参与记账</code></p><p>项目：以太坊、HCASH、MOAC</p></li><li><p>Ripple共识机制</p></li><li><p>小蚁NEO共识机制（DBFT）</p></li><li><p>常见区块链项目共识机制表：</p><table><thead><tr><th align="center">币种</th><th>共识算法</th><th>智能合约</th><th align="center">技术特色</th></tr></thead><tbody><tr><td align="center">BTC</td><td>POW</td><td>否</td><td align="center">UTXO模型</td></tr><tr><td align="center">ETN</td><td>POW -&gt; POS</td><td>是</td><td align="center">虚拟机EVM + 智能合约</td></tr><tr><td align="center">ADA</td><td>POS</td><td>是</td><td align="center">分层架构</td></tr><tr><td align="center">EOS</td><td>DBFT</td><td>是</td><td align="center">数字证书+智能合约+跨链互操作</td></tr><tr><td align="center">QTUM</td><td>POS + IPOS</td><td>是</td><td align="center">石墨烯技术+以太坊虚拟机</td></tr><tr><td align="center">LSK</td><td>DPOS</td><td>是</td><td align="center">侧脸技术</td></tr><tr><td align="center">HSR</td><td>POW + POS</td><td>是</td><td align="center">抗原子特性</td></tr><tr><td align="center">BTM</td><td>POW</td><td>是</td><td align="center">AI深度</td></tr><tr><td align="center">AE</td><td>POS + POW</td><td>是</td><td align="center">去中心化语言机</td></tr><tr><td align="center">NXT</td><td>POS</td><td>是</td><td align="center">主链+子链架构</td></tr><tr><td align="center">ACT</td><td>RDPOS</td><td>是</td><td align="center">主链+多侧链架构</td></tr><tr><td align="center">XAS</td><td>DPOS</td><td>是</td><td align="center">侧链技术</td></tr><tr><td align="center">ZIL</td><td>PBFT</td><td>是</td><td align="center">分片技术</td></tr></tbody></table></li></ul></li></ul><ul><li><p>激励层</p><ul><li>发行机制</li><li>分配机制</li></ul></li><li><p>合约层，密闭比特币1.0的不足，比特币是脚本型语言功能不完善。</p><ul><li><p>算法机制</p></li><li><p>智能合约，比如以太坊就有一台EVM的虚拟机。里面执行以太坊的智能合约。</p><p>智能合约介绍：</p><p><code>“智能合约”（smart contract）这个术语至少可以追溯到1995年，是由多产的矿领域法律学者尼克·萨博（Nick Szabo）提出来的。他在发表自己的网站的几遍文章中提到了智能合约的理念。他的定义如下：</code></p><p><font color="red" size="3px">“一个智能合约是一套以数字形式定义的承诺（promises）,包括合约参与方可以在上面记性这些承诺的协议。”</font></p><p>本质：数字化合同</p><p>特点：<font color="red">代码代替人仲裁和执行合同，同时能够发起支付。</font></p><p><strong>举例：</strong></p><p>​    <code>假设你和我对明天的天气进行打赌，我打赌明天是晴天，但是你打赌明天是雨天。双方同意输的一方必须给硬打赌一方100美元，那么，我们如何能够做到这一点，并且确保输的一方不会耍赖呢？</code></p><ul><li><p>传统方法：</p><ol><li><p>基于信任</p><p>仅适用于可信的人，对于陌生人，不适用。</p></li><li><p>签一个法律协议</p><p>将赌约正式形成一个法律效益协议，约定所有细节，输的一方给赢得一方，报错输的一方如果违反协议会怎么样。</p><p>但是他没有任何实用性，因为通过合法途径强制协议执行的脚本，要比这个赌约的价值高的多。</p></li><li><p>请一个中间人帮忙</p><p>如果这个双方都信任的朋友把钱卷走怎么办?</p></li></ol></li><li><p><font color="red">智能合约</font></p><p>代码化的合同，去除人的主观因素，一个合约写好以后，就无法在被编辑或者修改。因此，你可以保证无论合约内容是什么，他都可以无条件执行。</p><p>把合约和合同都写在区块链上，合约一旦执行，人就无法干涉。</p><p>整个步骤包括：构建 —&gt; 存储 —-&gt;执行</p><ol><li><p>构建（<font color="red">本地构建</font>）</p><p>智能合约由区块链内的多个用户共同参与制定，可用于用户之间的任何交易行为。协议中明确了双方的权利和义务，开发人员将这些权利和义务以电子化的方式进行编程，代码中包含会触发合约自动执行的条件。</p></li><li><p>存储（<font color="red">链上存储</font>）</p><p>一旦编码完成，这份智能合约就被上传到区块链网络上，即全网验证节点都会接收到你和双方合约。</p></li><li><p>执行（<font color="red">EVM中执行</font>）</p><ul><li><p>智能合约会定期检查是否存在相关事件和触发条件，满足条件的事件将会推送到等待验证的队列中。天气情况这个数据就成了该合约的触发条件。</p></li><li><p>区块链上的验证节点先对该事件进行签名验证，以确保其有效性；等大多数验证节点对该事件达成共识后，智能合约将成功执行，并通知用户。</p><hr><p>注，<font color="red">外部输入来源于ORACE（中文翻译：’语言机‘）</font>，一种可信的实体，通过签名引入外部状态信息，从而允许确定的智能合约对外部不确定的数据做出反应，语言机具有不可篡改服务器稳定，可以审计等特点。第三方语言机发送一笔区块链交易，交易中附带需要的数据，嵌入区块，同步给所有节点，从而用于智能合约的触发。</p><hr></li></ul></li></ol></li></ul></li></ul></li></ul><ul><li><p>应用层、合约逻辑、业务（金融或者物流）</p><ul><li>业务逻辑</li><li>DAPP、去中心化</li></ul></li><li><p>真正的业务逻辑、去中心化应用：</p><ul><li>新闻</li><li>游戏</li><li>产品溯源等</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python加密方法</title>
      <link href="/2019/07/30/python%E5%8A%A0%E5%AF%86/"/>
      <url>/2019/07/30/python%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="python-各种加密"><a href="#python-各种加密" class="headerlink" title="python 各种加密"></a>python 各种加密</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>加密学习<br><strong>对称加密</strong><br>对称密钥加密 ， 又叫私钥加密。即信息发送的方和接受方用一个密钥去加密和揭秘数据。 最大的优势是 加解密速度快，适合对大量数据进行加密， 对称加密的缺点是密钥的管理和分配， 换句话说就是 如何把密钥发送到需要解密你的消息的人手里的问题。在发送密钥的过程中， 密钥有很大的风险被黑客拦截。 现实中的做法是将对称加密的密钥进行非对称加密然后传给需要他的人。<br><strong>非对称加密</strong><br>非对称加密系统， 又称公钥密钥加密。 非对称加密为数据的加密与解密提供了一种非常安全的方式。她使用了一对密钥， 私钥和公钥。 私钥只能有一方安全保管， 不能外泄， 而公钥可以发给任何请求她的人。非对称加密使用这对密钥中的一个进行加密， 而解密却需要一个另外一个密钥。 比如你去银行 你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人–银行才能对你的消息解密。 与对称加密的不同之处是， 银行不需要将私钥通过网络发送出去。因此安全性大大提高。 目前最常用的非对称加密算法是RSA算法。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多。 公钥机制灵活， 但是加密和解密速度却要比堆成加密慢很多。<br>1） Alice需要在银行的网站做一笔交易，她的浏览器首先生成了一个随机数作为对称密钥。<br>（2） Alice的浏览器向银行的网站请求公钥。<br>（3） 银行将公钥发送给Alice。<br>（4） Alice的浏览器使用银行的公钥将自己的对称密钥加密。<br>（5） Alice的浏览器将加密后的对称密钥发送给银行。<br>（6） 银行使用私钥解密得到Alice浏览器的对称密钥。<br>（7） Alice与银行可以使用对称密钥来对沟通的内容进行加密与解密了。 </p><p><img src="https://img-blog.csdn.net/20180625164302779?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd4aWFvZG9uZzg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>（三）总结<br>（1） 对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。<br>（2） 非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。<br>（3） 解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</p><h2 id="base64-加密"><a href="#base64-加密" class="headerlink" title="base64 加密"></a>base64 加密</h2><p>python3 输入的都是 二进制 byte类型<br><strong>注意：用于base64编码的，要么是ASCII包含的字符，要么是二进制数据</strong><br>base64 是对称加密</p><p>base64 的加密和解密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">s = &apos;hello, world&apos;</span><br><span class="line">s = &quot;你好&quot;</span><br><span class="line"># 加密</span><br><span class="line">bs = base64.b64encode(s.encode(&quot;utf8&quot;))</span><br><span class="line">print(bs)</span><br><span class="line"></span><br><span class="line"># 解密</span><br><span class="line">decode = base64.b64decode(bs)</span><br><span class="line">print(decode)</span><br><span class="line">print(decode.decode(&quot;utf8&quot;))</span><br></pre></td></tr></table></figure><p>base64 是 一种用64 个字符来表示任意的二进制数据的方法。base64 可以成为密码学的基石。可以将任意二进制数据进行Base64 编码。 所有的数据都能被编码为并只有64个字符就能表示的文本文件。（ 64字符：A<del>Z a</del>z 0<del>9 + / ）编码后的数据</del>=编码前数据的4/3，会大1/3左右。</p><p>Base64编码的原理 </p><p><img src="https://img-blog.csdn.net/20180625171145294?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd4aWFvZG9uZzg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>1 将所有字符转化为ASCII码。<br>2 将ASCII码转化为8位二进制 。<br>3 将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位。<br>4 统一在6位二进制前补两个0凑足8位。<br>5 将补0后的二进制转为十进制。<br>6 从Base64编码表获取十进制对应的Base64编码。</p><p><strong>Base64编码的说明</strong></p><p>1 转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。<br>2 数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>3 不断进行，直到全部输入数据转换完成。<br>4 如果最后剩下两个输入数据，在编码结果后加1个“=”。<br>5 如果最后剩下一个输入数据，编码结果后加2个“=”。<br>6 如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>由于MD5模块在python3中被移除，在python3中使用hashlib模块进行md5操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">str = &quot;我真帅&quot;</span><br><span class="line"></span><br><span class="line"># 创建一个md5 对象</span><br><span class="line">h1 = hashlib.md5()</span><br><span class="line"># 此处必须声明encode</span><br><span class="line"># 若写法为hl.update(str)  报错为： Unicode-objects must be encoded before hashing</span><br><span class="line">h1.update(str.encode())</span><br><span class="line">print(&quot;加密前&quot;, str)</span><br><span class="line">print(&quot;加密后&quot;, h1.hexdigest())</span><br></pre></td></tr></table></figure><h2 id="sha1-加密"><a href="#sha1-加密" class="headerlink" title="sha1 加密"></a>sha1 加密</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line">def str_encrypt(str):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    使用sha1加密算法，返回str加密后的字符串</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    sha = hashlib.sha1(str)</span><br><span class="line">    encrypts = sha.hexdigest()</span><br><span class="line">    return encrypts</span><br></pre></td></tr></table></figure><p><strong>简介</strong><br>message-digest algorithm 5（信息-摘要算法）。经常说的“MD5加密”，就是它→信息-摘要算法。</p><p>md5，其实就是一种算法。可以将一个字符串，或文件，或压缩包，执行md5后，就可以生成一个固定长度为128bit的串。这个串，基本上是唯一的。</p><p><strong>不可逆性</strong><br>每个人都有不同的指纹，看到这个人，可以得出他的指纹等信息，并且唯一对应，但你只看一个指纹，是不可能看到或读到这个人的长相或身份等信息。</p><p><strong>特点</strong></p><p>1 压缩性：任意长度的数据，算出的MD5值长度都是固定的。<br>2 容易计算：从原数据计算出MD5值很容易。<br>3 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br>4 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。</p><p><strong>MD5长度</strong></p><p>md5的长度，默认为128bit，也就是128个0和1的二进制串。这样表达是很不友好的。所以将二进制转成了16进制，每4个bit表示一个16进制，所以128/4 = 32 换成16进制表示后，为32位了。</p><p>为什么网上还有md5是16位的呢？</p><p>其实16位的长度，是从32位md5值来的。是将32位md5去掉前八位，去掉后八位得到的。</p><p><strong>DES</strong></p><p>Python加密库PyCryptodome<br>PyCrytodome 取代了 PyCrypto 。<br>安装与导入<br>Windows安装之前需要先安装Microsoft Visual c++ 2015。</p><p>下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=48145" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=48145</a></p><p>在Linux上安装，可以使用以下 pip 命令：<br>pip install pycryptodome<br>import Crypto</p><p>在Windows 系统上安装则稍有不同：<br>pip install pycryptodomex<br>import Cryptodome</p><p>DES算法为密码体制中的对称密码体制，又被称为美国数据加密标准。</p><p>DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。</p><p>DES算法的入口参数有三个：Key、Data、Mode。其中Key为7个字节共56位，是DES算法的工作密钥；Data为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式,有两种:加密或解密。</p><p>密钥长64位，密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位，使得每个密钥都有奇数个1），分组后的明文组和56位的密钥按位替代或交换的方法形成密文组。</p><p><strong>加密原理</strong><br>DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环，使用异或，置换，代换，移位操作四种基本运算。</p><p><strong>算法步骤</strong><br>1）初始置换<br>其功能是把输入的64位数据块按位重新组合,并把输出分为L0、R0两部分,每部分各长3 2位,其置换规则为将输入的第58位换到第一位,第50位换到第2位……依此类推,最后一位是原来的第7位。L0、R0则是换位输出后的两部分，L0是输出的左32位,R0是右32位,例:设置换前的输入值为D1D2D3……D64,则经过初始置换后的结果为:L0=D58D50……D8;R0=D57D49……D7。<br>其置换规则见下表：<br>58,50,42,34,26,18,10,2,60,52,44,36,28,20,12,4,<br>62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,<br>57,49,41,33,25,17,9,1,59,51,43,35,27,19,11,3,<br>61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7,<br>2）逆置换<br>经过16次迭代运算后,得到L16、R16,将此作为输入,进行逆置换,逆置换正好是初始置换的逆运算，由此即得到密文输出。<br>此算法是对称加密算法体系中的代表,在计算机网络系统中广泛使用.</p><p>加密和解密的过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from Cryptodome.Cipher import DES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">key = b&apos;abcdefgh&apos;  # 密钥 8位或16位,必须为bytes</span><br><span class="line">def pad(text):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 加密函数，如果text不是8的倍数【加密文本text必须为8的倍数！】，那就补足为8的倍数</span><br><span class="line">    :param text:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    while len(text) % 8 != 0:</span><br><span class="line">        text += &apos; &apos;</span><br><span class="line">    return text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">des = DES.new(key, DES.MODE_ECB)  # 创建一个DES实例</span><br><span class="line">text = &apos;Python rocks!&apos;</span><br><span class="line">padded_text = pad(text)</span><br><span class="line">encrypted_text = des.encrypt(padded_text.encode(&apos;utf-8&apos;))  # 加密</span><br><span class="line">print(encrypted_text)</span><br><span class="line"># rstrip(&apos; &apos;)返回从字符串末尾删除所有字符串的字符串(默认空白字符)的副本</span><br><span class="line">plain_text = des.decrypt(encrypted_text).decode().rstrip(&apos; &apos;)  # 解密</span><br><span class="line">print(plain_text)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from Cryptodome.Cipher import DES</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line"># 这是密钥</span><br><span class="line">key = b&apos;abcdefgh&apos;</span><br><span class="line"># 需要去生成一个DES对象</span><br><span class="line">des = DES.new(key, DES.MODE_ECB)</span><br><span class="line"># 需要加密的数据</span><br><span class="line">text = &apos;python spider!&apos;</span><br><span class="line">text = text + (8 - (len(text) % 8)) * &apos;=&apos;</span><br><span class="line"># 加密的过程</span><br><span class="line">encrypto_text = des.encrypt(text.encode())</span><br><span class="line"># 加密过后二进制转化为ASCII </span><br><span class="line">encrypto_text = binascii.b2a_hex(encrypto_text)</span><br><span class="line">print(encrypto_text)</span><br><span class="line"># 解密需要ASCII 先转化为二进制 然后再进行解密</span><br><span class="line">plaint = des.decrypt(binascii.a2b_hex(encrypto_text))</span><br><span class="line">print(plaint)</span><br></pre></td></tr></table></figure><p><strong>3DES</strong><br>简介</p><p>3DES（或称为Triple DES）是三重数据加密算法（TDEA，Triple Data Encryption Algorithm）块密码的通称。它相当于是对每个数据块应用三次DES加密算法。</p><p>由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解。3DES即是设计用来提供一种相对简单的方法，即通过增加DES的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</p><p>3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），加密算法，其具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，M代表明文，C代表密文，这样：</p><p>3DES加密过程为：C=Ek3(Dk2(Ek1(M)))</p><p>3DES解密过程为：M=Dk1(EK2(Dk3(C)))</p><p><strong>AES</strong><br><strong>简介</strong></p><p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。</p><p>AES在软件及硬件上都能快速地加解密，相对来说较易于实作，且只需要很少的存储器。作为一个新的加密标准，目前正被部署应用到更广大的范围。<br>特点与思想</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">抵抗所有已知的攻击。</span><br><span class="line">在多个平台上速度快，编码紧凑。</span><br><span class="line">设计简单。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180626135210995?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmd4aWFvZG9uZzg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同。</p><p>一般常用的是128位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from Cryptodome.Cipher import AES</span><br><span class="line">from Cryptodome import Random</span><br><span class="line"></span><br><span class="line">from binascii import a2b_hex</span><br><span class="line"></span><br><span class="line"># 要加密的明文</span><br><span class="line">data = &apos;南来北往&apos;</span><br><span class="line"># 密钥key必须为 16（AES-128）， 24（AES-192）， 32（AES-256）</span><br><span class="line">key = b&apos;this is a 16 key&apos;</span><br><span class="line"># 生成长度等于AES 块大小的不可重复的密钥向量</span><br><span class="line">iv = Random.new().read(AES.block_size)</span><br><span class="line">print(iv)</span><br><span class="line"># 使用 key 和iv 初始化AES 对象， 使用MODE_CFB模式</span><br><span class="line">mycipher = AES.new(key, AES.MODE_CFB, iv)</span><br><span class="line">print(mycipher)</span><br><span class="line"># 加密的明文长度必须为16的倍数， 如果长度不为16的倍数， 则需要补足为16的倍数</span><br><span class="line"># 将iv(密钥向量)加到加密的密钥开头， 一起传输</span><br><span class="line">ciptext = iv + mycipher.encrypt(data.encode())</span><br><span class="line"># 解密的话需要用key 和iv 生成的AES对象</span><br><span class="line">print(ciptext)</span><br><span class="line">mydecrypt = AES.new(key, AES.MODE_CFB, ciptext[:16])</span><br><span class="line"># 使用新生成的AES 对象， 将加密的密钥解密</span><br><span class="line">decrytext = mydecrypt.decrypt(ciptext[16:])</span><br><span class="line"></span><br><span class="line">print(decrytext.decode())</span><br></pre></td></tr></table></figure><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>非对称加密<br>典型的非对称加密<br>典型的如RSA等，常见方法，使用openssl ,keytools等工具生成一对公私钥对，使用被公钥加密的数据可以使用私钥来解密，反之亦然（被私钥加密的数据也可以被公钥解密) 。</p><p>在实际使用中私钥一般保存在发布者手中，是私有的不对外公开的，只将公钥对外公布，就能实现只有私钥的持有者才能将数据解密的方法。 这种加密方式安全系数很高，因为它不用将解密的密钥进行传递，从而没有密钥在传递过程中被截获的风险，而破解密文几乎又是不可能的。</p><p>但是算法的效率低，所以常用于很重要数据的加密，常和对称配合使用，使用非对称加密的密钥去加密对称加密的密钥。</p><p><strong>简介</strong><br>RSA加密算法是一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。</p><p>该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用</p><p>而且，因为RSA加密算法的特性，RSA的公钥私钥都是10进制的，但公钥的值常常保存为16进制的格式，所以需要将其用int()方法转换为10进制格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import rsa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># rsa加密</span><br><span class="line">def rsaEncrypt(str):</span><br><span class="line">    # 生成公钥、私钥</span><br><span class="line">    (pubkey, privkey) = rsa.newkeys(512)</span><br><span class="line">    print(&quot;pub: &quot;, pubkey)</span><br><span class="line">    print(&quot;priv: &quot;, privkey)</span><br><span class="line">    # 明文编码格式</span><br><span class="line">    content = str.encode(&apos;utf-8&apos;)</span><br><span class="line">    # 公钥加密</span><br><span class="line">    crypto = rsa.encrypt(content, pubkey)</span><br><span class="line">    return (crypto, privkey)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># rsa解密</span><br><span class="line">def rsaDecrypt(str, pk):</span><br><span class="line">    # 私钥解密</span><br><span class="line">    content = rsa.decrypt(str, pk)</span><br><span class="line">    con = content.decode(&apos;utf-8&apos;)</span><br><span class="line">    return con</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(a, b) = rsaEncrypt(&quot;hello&quot;)</span><br><span class="line">print(&apos;加密后密文：&apos;)</span><br><span class="line">print(a)</span><br><span class="line">content = rsaDecrypt(a, b)</span><br><span class="line">print(&apos;解密后明文：&apos;)</span><br><span class="line">print(content)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import rsa</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">def rsa_encrypt(rsa_n, rsa_e, message):</span><br><span class="line">    key = rsa.PublicKey(rsa_n, rsa_e)</span><br><span class="line">    message = rsa.encrypt(message.encode(), key)</span><br><span class="line">    message = binascii.b2a_hex(message)</span><br><span class="line">    return message.decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pubkey_n = &apos;8d7e6949d411ce14d7d233d7160f5b2cc753930caba4d5ad24f923a505253b9c39b09a059732250e56c594d735077cfcb0c3508e9f544f101bdf7e97fe1b0d97f273468264b8b24caaa2a90cd9708a417c51cf8ba35444d37c514a0490441a773ccb121034f29748763c6c4f76eb0303559c57071fd89234d140c8bb965f9725&apos;</span><br><span class="line">pubkey_e = &apos;10001&apos;</span><br><span class="line">rsa_n = int(pubkey_n, 16)</span><br><span class="line">rsa_e = int(pubkey_e, 16)</span><br><span class="line">message = &apos;南北今天很忙&apos;</span><br><span class="line">print(&quot;公钥n值长度：&quot;, len(pubkey_n))</span><br><span class="line"></span><br><span class="line">aa = rsa_encrypt(rsa_n, rsa_e, message)</span><br><span class="line">print(aa)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">RSA算法</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">from Cryptodome.PublicKey import RSA</span><br><span class="line"></span><br><span class="line">from Cryptodome.Cipher import PKCS1_OAEP, PKCS1_v1_5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyRSA():</span><br><span class="line">    def create_rsa_key(self, password):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        创建RSA密钥</span><br><span class="line"></span><br><span class="line">        步骤说明：</span><br><span class="line"></span><br><span class="line">        1、从 Crypto.PublicKey 包中导入 RSA，创建一个密码</span><br><span class="line"></span><br><span class="line">        2、生成 1024/2048 位的 RSA 密钥</span><br><span class="line"></span><br><span class="line">        3、调用 RSA 密钥实例的 exportKey 方法，传入密码、使用的 PKCS 标准以及加密方案这三个参数。</span><br><span class="line"></span><br><span class="line">        4、将私钥写入磁盘的文件。</span><br><span class="line"></span><br><span class="line">        5、使用方法链调用 publickey 和 exportKey 方法生成公钥，写入磁盘上的文件。</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        key = RSA.generate(1024)</span><br><span class="line"></span><br><span class="line">        encrypted_key = key.exportKey(passphrase=password.encode(&quot;utf-8&quot;), pkcs=8,</span><br><span class="line"></span><br><span class="line">                                      protection=&quot;scryptAndAES128-CBC&quot;)</span><br><span class="line"></span><br><span class="line">        with open(&quot;my_private_rsa_key.bin&quot;, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(encrypted_key)</span><br><span class="line"></span><br><span class="line">        with open(&quot;my_rsa_public.pem&quot;, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(key.publickey().exportKey())</span><br><span class="line"></span><br><span class="line">    def encrypt(self, plaintext):</span><br><span class="line">        # 加载公钥</span><br><span class="line"></span><br><span class="line">        recipient_key = RSA.import_key(</span><br><span class="line"></span><br><span class="line">            open(&quot;my_rsa_public.pem&quot;).read()</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        cipher_rsa = PKCS1_v1_5.new(recipient_key)</span><br><span class="line"></span><br><span class="line">        en_data = cipher_rsa.encrypt(plaintext.encode(&quot;utf-8&quot;))</span><br><span class="line"></span><br><span class="line">        return en_data</span><br><span class="line"></span><br><span class="line">        # print(len(en_data), en_data)</span><br><span class="line"></span><br><span class="line">    def decrypt(self, en_data, password):</span><br><span class="line">        # 读取密钥</span><br><span class="line"></span><br><span class="line">        private_key = RSA.import_key(</span><br><span class="line"></span><br><span class="line">            open(&quot;my_private_rsa_key.bin&quot;).read(),</span><br><span class="line"></span><br><span class="line">            passphrase=password</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        cipher_rsa = PKCS1_v1_5.new(private_key)</span><br><span class="line"></span><br><span class="line">        data = cipher_rsa.decrypt(en_data, None)</span><br><span class="line"></span><br><span class="line">        return data</span><br><span class="line"></span><br><span class="line">        # print(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mrsa = MyRSA()</span><br><span class="line"></span><br><span class="line">mrsa.create_rsa_key(&apos;123456&apos;)</span><br><span class="line"></span><br><span class="line">e = mrsa.encrypt(&apos;hello&apos;)</span><br><span class="line"></span><br><span class="line">d = mrsa.decrypt(e, &apos;123456&apos;)</span><br><span class="line"></span><br><span class="line">print(e)</span><br><span class="line"></span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure><p>不错网站  <a href="https://blog.csdn.net/cuick2013/article/details/52539555" target="_blank" rel="noopener">https://blog.csdn.net/cuick2013/article/details/52539555</a> </p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 加密 </tag>
            
            <tag> base64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哪吒之魔童降世-申公豹</title>
      <link href="/2019/07/29/%E5%93%AA%E5%90%92%E4%B9%8B%E9%AD%94%E7%AB%A5%E9%99%8D%E4%B8%96-%E7%94%B3%E5%85%AC%E8%B1%B9/"/>
      <url>/2019/07/29/%E5%93%AA%E5%90%92%E4%B9%8B%E9%AD%94%E7%AB%A5%E9%99%8D%E4%B8%96-%E7%94%B3%E5%85%AC%E8%B1%B9/</url>
      
        <content type="html"><![CDATA[<p>每一个申公豹，都曾经是哪吒，这是一个极典型的悲剧性角色。</p><p>“人心中的成见是一座大山,任你如何努力都不可能搬动。”这是申公豹在剧中仅有的一口气说完的长台词，以他的口吃程度来看，能说的如此流畅，只有一个原因：他早在内心中重复了无数次。</p><p>每在心底默念一次，就是在他的心上割一刀，鲜血淋漓。</p><p>申公豹的前半生，是哪吒。</p><p>身为妖族，在被人族和飞升后的人族（仙神）为主要统治的时代，天生就是低等的，被歧视的，被警惕的。</p><p>妖族在凡间，没有修炼洗去兽身，是被凡人狩猎的野兽，餐桌上的鱼肉。</p><p>妖族修炼得道，飞升天界，就成为了神仙的坐骑，更有甚者，成为炼丹材料，法宝原料。</p><p>君不见，堂堂四海龙族，妖族中最高贵的一支，被囚禁在龙宫之中，一面镇压海底其他妖族，一面反被妖族牵制，锁链加身，不得解脱。</p><p>“如果你问我,人能否改变自己的命运,我也不晓得,但我晓得,不认命,就是哪吒的命。”——太乙真人。</p><p>而在不认命的道路上，哪吒并不比申公豹走得更远。</p><p>申公豹并非金翅大鹏鸟、孔雀那种天生神兽，他只是一只普通的野兽。</p><p>他的命运，本来是身的一部分变成某个猎户身上的取暖皮毛，另一部分变成一户人家的食物，剩下的，变成药店里的几味药材。</p><p>但他却走出了深山，修炼得道。这是他第一次不认命，摆脱食粮的身份，他成功了。</p><p>之后，他拜在了阐教元始天尊门下，成为了和十二金仙同一级别的二代弟子。</p><p>申公豹拜在元始门下，这是一个什么概念呢？可能很多朋友不会理解。</p><p>以十二金仙中的几位为例，黄龙真人的坐骑是仙鹤，普贤的坐骑是白象，慈航道人的坐骑是金毛吼，文殊的坐骑更多，有青狮、鸾、鹤和梅花鹿。</p><p>也就是说申公豹的出身，在阐教本来只配当坐骑，但却让原始破格收取他为亲传弟子，地位不输其他人族。</p><p>论励志程度，放到现代社会，只有在种族歧视极其严重的美国社会，黑人奥巴马当选为总统有的一比。</p><p>这是他第二次不认命，他又成功了。</p><p>以元始天尊的境界，我相信是不会区别对待申公豹的，但是其他人呢？</p><p>其他师兄弟，在看待这个低等的妖族和自己平起平坐时，会是何种眼光？</p><p>而身为妖族，当他看到其他同类凄惨地沦为坐骑、材料、食材时，他又会是何种心情？而在其他阐教门徒看来，只是天经地义的事情，绝不会顾忌到申公豹的存在。</p><p>平日的非议，内心里的煎熬，一年两年还能忍受，但是如果是一百年，两百年，而且还将持续到一千年，一万年呢？</p><p>元始天尊自然不屑于出手来解决弟子之间的矛盾，在他看来，万事万物自有命数，灵珠转世就收到门下，灵珠变成魔丸就以天劫灭杀之，如果你申公豹看不透，挣不脱命数，那你便命该如此。</p><p>而申公豹虽是妖兽，但亦向往人心的温存，他此时并非后来的冷血枭雄，他也期待师尊的关心与爱护。</p><p>当龙三太子敖丙为了救李靖夫妇等无辜之人，向他求取乾坤圈时，他明知道会破坏自己的计划，仍然将乾坤圈给了敖丙。</p><p>彼时彼刻，抬头看着陈塘关的烈焰冲天，申公豹可能心中也在默念：师尊，若你能如此对我，又该多好？</p><p>摆脱了妖族身份，却最终没能摆脱妖族待遇，年复一年承受着各方的压力，又得不到师父的开解，但申公豹仍然在黑暗中坚持着，苦苦抓住悬崖突出的石块，不让自己坠入深渊，相信自己的努力，元始天尊会看得到。</p><p>但当元始天尊决定将引导转世灵珠的太乙真人选为十二金仙最后一位时，申公豹死死抓住的那颗石块，彻底滑落了，而他也伴着这石块一起，开始堕落。</p><p>“我命由我不由天，是魔是仙我说了算”！这是哪吒的台词，但更像申公豹的悲愤嘶吼。</p><p>我要让师尊看到，我才是十二金仙最适合的人选！这是当时申公豹的内心写照。</p><p>申公豹因此变成了一个阴谋家，和龙族合谋，抢夺灵珠，培养敖丙，让变成魔丸的哪吒杀死太乙、李靖夫妇，让弟子敖丙斩杀魔丸，立下功劳，以此成为晋升十二金仙的资本。</p><p>在阴谋彻底破灭前，在敖丙义无反顾地冲天而起，迎向天雷前，他都没有想过要背叛师门。</p><p>为什么同样不认命，同样的一次次努力，申公豹最后堕入了无尽的黑暗，而哪吒在天雷中却迎来了新生？</p><p>当整个陈塘关都要铲除哪吒这个妖孽时，李靖夫妇以自己多年来的名誉作保。</p><p>当哪吒成为孤苦的留守儿童时，殷夫人即便刚卸下盔甲，也要赶过来陪他踢一会毽子。</p><p>当哪吒被陈塘关所有人唾弃孤立时，在海边，那个白衣飘飘的龙三太子，成为了他唯一的朋友。</p><p>当哪吒注定要被天劫毁灭时，李靖在云仙前深深拜下，求来血亲之人一命换一命的换命符。</p><p>当哪吒斩妖后被村民误会，李靖亲手擒来了海夜叉，做好准备在生辰宴上还他清白。</p><p>当哪吒在天雷下即将丧生时，太乙真人以自身三花聚顶的修行被削掉为代价，保住了他的魂魄。</p><p>……</p><p>不管这个世界对哪吒有多少不公，但哪吒一直是被爱着的那一个。</p><p>于哪吒而言，人生一世，只要自己亲近的人是真心爱自己，哪怕整个世界与自己为敌，那又如何？</p><p>即便是背负整个龙族希望，被迫黑化的敖丙，也有哪吒的友情温暖着他的心。</p><p>但申公豹，一无所有。</p><p>曾经我不认命，现在我同样不认命，我要让你们看看，我申公豹的命。</p><p>当内心中没有了感情的羁绊，申公豹就这么走向了另一个极端，只想向师师尊和师兄弟们证明自己，只想报复这几百年来受到的委屈。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 的构造器</title>
      <link href="/2018/09/07/Vue%20%E7%9A%84%E6%9E%84%E9%80%A0%E9%80%A0-extend%E4%B8%8E%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BD-$mount/"/>
      <url>/2018/09/07/Vue%20%E7%9A%84%E6%9E%84%E9%80%A0%E9%80%A0-extend%E4%B8%8E%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BD-$mount/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue-的构造器——extend-与手动挂载——-mount"><a href="#Vue-的构造器——extend-与手动挂载——-mount" class="headerlink" title="Vue 的构造器——extend 与手动挂载——$mount"></a>Vue 的构造器——extend 与手动挂载——$mount</h1><p>本节介绍两个 Vue.js 内置但却不常用的 API——extend 和 $mount，它们经常一起使用。不常用，是因为在业务开发中，基本没有它们的用武之地，但在独立组件开发时，在一些特定的场景它们是至关重要的。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>我们在写 Vue.js 时，不论是用 CDN 的方式还是在 Webpack 里用 npm 引入的 Vue.js，都会有一个根节点，并且创建一个根实例，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app = new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Webpack 也类似，一般在入口文件 main.js 里，最后会创建一个实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import App from &apos;./app.vue&apos;;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为用 Webpack 基本都是前端路由的，它的 html 里一般都只有一个根节点 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，其余都是通过 JavaScript 完成，也就是许多的 Vue.js 组件（每个页面也是一个组件）。</p><p>有了初始化的实例，之后所有的页面，都由 vue-router 帮我们管理，组件也都是用 <code>import</code> 导入后局部注册（也有在 main.js 全局注册的），不管哪种方式，组件（或页面）的创建过程我们是无需关心的，只是写好 <code>.vue</code> 文件并导入即可。这样的组件使用方式，有几个特点：</p><ol><li>所有的内容，都是在 <code>#app</code> 节点内渲染的；</li><li>组件的模板，是事先定义好的；</li><li>由于组件的特性，注册的组件只能在当前位置渲染。</li></ol><p>比如你要使用一个组件 <code>&lt;i-date-picker&gt;</code>，渲染时，这个自定义标签就会被替换为组件的内容，而且在哪写的自定义标签，就在哪里被替换。换句话说，常规的组件使用方式，只能在规定的地方渲染组件，这在一些特殊场景下就比较局限了，例如：</p><ol><li>组件的模板是通过调用接口从服务端获取的，需要动态渲染组件；</li><li>实现类似原生 <code>window.alert()</code> 的提示框组件，它的位置是在 <code>&lt;body&gt;</code> 下，而非 <code>&lt;div id=&quot;app&quot;&gt;</code>，并且不会通过常规的组件自定义标签的形式使用，而是像 JS 调用函数一样使用。</li></ol><p>一般来说，在我们访问页面时，组件就已经渲染就位了，对于场景 1，组件的渲染是异步的，甚至预先不知道模板是什么。对于场景 2，其实并不陌生，在 jQuery 时代，通过操作 DOM，很容易就能实现，你可以沿用这种思路，只是这种做法不那么 Vue，既然使用 Vue.js 了，就应该用 Vue 的思路来解决问题。对于这两种场景，Vue.extend 和 vm.$mount 语法就派上用场了。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>上文我们说到，创建一个 Vue 实例时，都会有一个选项 <code>el</code>，来指定实例的根节点，如果不写 <code>el</code> 选项，那组件就处于未挂载状态。<code>Vue.extend</code> 的作用，就是基于 Vue 构造器，创建一个“子类”，它的参数跟 <code>new Vue</code> 的基本一样，但 <code>data</code> 要跟组件一样，是个函数，再配合 <code>$mount</code> ，就可以让组件渲染，并且挂载到任意指定的节点上，比如 body。</p><p>比如上文的场景，就可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">const AlertComponent = Vue.extend(&#123;</span><br><span class="line">  template: &apos;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &apos;Hello, Aresn&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这一步，我们创建了一个构造器，这个过程就可以解决异步获取 template 模板的问题，下面要手动渲染组件，并把它挂载到 body 下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const component = new AlertComponent().$mount();</span><br></pre></td></tr></table></figure><p>这一步，我们调用了 <code>$mount</code> 方法对组件进行了手动渲染，但它仅仅是被渲染好了，并没有挂载到节点上，也就显示不了组件。此时的 <code>component</code> 已经是一个标准的 Vue 组件实例，因此它的 <code>$el</code> 属性也可以被访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.appendChild(component.$el);</span><br></pre></td></tr></table></figure><p>当然，除了 body，你还可以挂载到其它节点上。</p><p><code>$mount</code> 也有一些快捷的挂载方式，以下两种都是可以的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 在 $mount 里写参数来指定挂载的节点</span><br><span class="line">new AlertComponent().$mount(&apos;#app&apos;);</span><br><span class="line">// 不用 $mount，直接在创建实例时指定 el 选项</span><br><span class="line">new AlertComponent(&#123; el: &apos;#app&apos; &#125;);</span><br></pre></td></tr></table></figure><p>实现同样的效果，除了用 extend 外，也可以直接创建 Vue 实例，并且用一个 Render 函数来渲染一个 .vue 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line">import Notification from &apos;./notification.vue&apos;;</span><br><span class="line"></span><br><span class="line">const props = &#123;&#125;;  // 这里可以传入一些组件的 props 选项</span><br><span class="line"></span><br><span class="line">const Instance = new Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    return h(Notification, &#123;</span><br><span class="line">      props: props</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const component = Instance.$mount();</span><br><span class="line">document.body.appendChild(component.$el);</span><br></pre></td></tr></table></figure><p>这样既可以使用 .vue 来写复杂的组件（毕竟在 template 里堆字符串很痛苦），还可以根据需要传入适当的 props。渲染后，如果想操作 Render 的 <code>Notification</code> 实例，也是很简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const notification = Instance.$children[0];</span><br></pre></td></tr></table></figure><p>因为 Instance 下只 Render 了 Notification 一个子组件，所以可以用 <code>$children[0]</code> 访问到。</p><blockquote><p>如果你还不理解这样做的目的，没有关系，后面小节的两个实战你会感受到它的用武之地。</p></blockquote><p>需要注意的是，我们是用 <code>$mount</code> 手动渲染的组件，如果要销毁，也要用 <code>$destroy</code> 来手动销毁实例，必要时，也可以用 <code>removeChild</code> 把节点从 DOM 中移除。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这两个 API 并不难理解，只是不常使用罢了，因为多数情况下，我们只关注在业务层，并使用现成的组件库。</p><p>使用 Vue.js 也有二八原则，即 80% 的人看过 <a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue.js 文档教程篇</a>，20% 的人看过 <a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener">Vue.js 文档 API</a>。</p><p>下一节，我们来做点有趣的东西。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/59da1c116fb9a00a4a4cf6dd" target="_blank" rel="noopener">聊聊 Vue.js 的 template 编译</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署GitHub</title>
      <link href="/2018/09/07/hexo%E9%83%A8%E7%BD%B2GitHub/"/>
      <url>/2018/09/07/hexo%E9%83%A8%E7%BD%B2GitHub/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo部署Git"><a href="#Hexo部署Git" class="headerlink" title="Hexo部署Git"></a>Hexo部署Git</h1><p><strong>让你拥有属于自己的博客请按照下面一下几步走！</strong></p><h3>原贴：[刘悦老师](https://v3u.cn/a_id_93)<h3><h1 id="使用Hexo建立一个轻量、简易、高逼格的博客"><a href="#使用Hexo建立一个轻量、简易、高逼格的博客" class="headerlink" title="使用Hexo建立一个轻量、简易、高逼格的博客"></a>使用Hexo建立一个轻量、简易、高逼格的博客</h1><p>在之前的一篇文章中，介绍了如何使用Hugo在<a href="https://v3u.cn/a_id_81" target="_blank" rel="noopener">三分钟之内建立一个简单的个人博客系统</a>，它是基于go lang的，其实，市面上还有一款类似的静态页生成器，就是Hexo 读音/hækso/ ，它是基于node.js的，和Hugo一样，Hexo 正常来说，不需要部署到我们的服务器上，我们的服务器上保存的，其实是基于在hexo通过markdown编写的文章，然后hexo帮我们生成静态的html页面，然后，将生成的html上传到我们的服务器。简而言之：hexo是个静态页面生成、上传的工具。 </p><blockquote><p>首先安装Hugo，在此之前，请确保电脑里已经安装好新版的node.js </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><blockquote><p> 如果感觉安装速度比较慢，可以为npm指定国内的源 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><blockquote><p> 安装完成后，创建博客项目 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><blockquote><p>   这样，就建立起了一个blog文件夹，进入到blog目录下 cd blog，建立第一篇文章 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new myfirst</span><br></pre></td></tr></table></figure><blockquote><p>然后运行hexo服务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><blockquote><p>就可以在本地访问你的博客网站了，默认端口号是4000 </p></blockquote><p>那么如何将博客网站打包呢？直接运行打包命令，这样就能使用 Hexo 引擎将 Markdown 格式的文件解析成可以使用浏览器查看的 HTML 文件，HTML 文件存储在 blog/public 目录下 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>下面我们可以配置一下hexo主题，Hexo 提供了默认主题 landscape，主题的位置在 blog -&gt;themes 文件夹下。主题根据自己喜好可以在网上找到:<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> </p><blockquote><p>主题都放在blog/themes文件夹下面，这我们下载一个新的主题 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir themes/next</span><br><span class="line">git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><blockquote><p> 然后在修改 /blog/config.yml 文件，将其中的 theme 改成 next</p></blockquote><p>​    最后，将打包好的public目录上传到服务器，使用nginx代理访问就可以了，具体配置请移步：<a href="https://v3u.cn/a_id_81" target="_blank" rel="noopener">https://v3u.cn/a_id_81</a></p><p>​    如果没有自己的域名和服务器怎么办？没关系，可以申请 Github 免费静态内容空间，在github.com注册一个账号，然后创建一个新的仓库</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190625/20190625080452_43440.png" alt></p><hr><p><strong>仓库名称一定要定义成 账号名.github.io，这种形式，注意账号名一定要和你的github当前登录的账号吻合</strong> </p><hr><p>ps：非常建议库名和当前账号吻合，可以省去很多麻烦</p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190625/20190625080756_40947.png" alt></p><p>这样你的静态内容空间就已经创建好了，在浏览器输入你的 <a href="https://zcxey2911.github.io/" target="_blank" rel="noopener">https://你的账号.github.io/</a> 就可以访问了。</p><p>​    将之前打包好的public中的文件push到刚刚创建好的github仓库中去</p><p>​    访问静态空间网址<a href="https://zcxey2911.github.io/" target="_blank" rel="noopener">https://zcxey2911.github.io</a></p><p><img src="https://v3u.cn/v3u/Public/js/editor/attached/image/20190625/20190625082305_49762.png" alt></p><p>没有问题，搞定收工 ！！！</p></h3></h3>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 部署 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo部署码云</title>
      <link href="/2018/09/07/hexo%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/"/>
      <url>/2018/09/07/hexo%E9%83%A8%E7%BD%B2%E7%A0%81%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-码云-免费搭建个人blog-windows系统"><a href="#Hexo-码云-免费搭建个人blog-windows系统" class="headerlink" title="Hexo + 码云 免费搭建个人blog windows系统"></a>Hexo + 码云 免费搭建个人blog windows系统</h1><p>前言 使用软件：git bash，Atom编辑器 最近想写一些博客，就想自己也代建一个个人的站点，经过朋友介绍知道了hexo这么个好东西，今天我就给大家分享一下我个人的搭建经验。 这篇博客虽然写的是码云，但是里边的东西依然适用于github和coding等代码托管网站。 </p><h2 id="Hexo什么鬼？"><a href="#Hexo什么鬼？" class="headerlink" title="Hexo什么鬼？"></a>Hexo什么鬼？</h2><p><a href="https://link.jianshu.com?t=https%3A%2F%2Fhexo.io%2F" target="_blank" rel="noopener">https://hexo.io/</a><br> A fast, simple &amp; powerful blog framework<br> 一个快捷、简单并且强大的博客框架。<br> 他是基于Node.js的一个静态博客框架。支持Markdown解析文章，能够很快的生成特定主题的静态网页。<br> <a href="https://link.jianshu.com?t=https%3A%2F%2Fhexo.io%2Fthemes%2F" target="_blank" rel="noopener">https://hexo.io/themes/</a><br> 废话不多说，开整。</p><h2 id="前序工作"><a href="#前序工作" class="headerlink" title="前序工作"></a>前序工作</h2><ol><li>安装完Node.js <a href="https://link.jianshu.com?t=https%3A%2F%2Fnodejs.org%2Fen%2F" target="_blank" rel="noopener">https://nodejs.org/en/</a> </li><li>安装git bash工具 <a href="https://link.jianshu.com?t=https%3A%2F%2Fgitforwindows.org%2F" target="_blank" rel="noopener">https://gitforwindows.org/</a><br> （ps：安装完Node.js 和Gitbash不需要任何多余的配置，一路next就好）</li><li>安装hexo</li></ol><ul><li>先新建一个存放blog所有东西的文件夹</li><li>在文件夹内右键 是不是看到git bash here，点他</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3241580-7f6e6c2d5f6c0fa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/257/format/webp" alt></p><ul><li><p>直接输入安装hexo的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>安装完成后，查看版本，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p>恭喜你安装完成</p></li></ul><p><a href="https://upload-images.jianshu.io/upload_images/3241580-298e524479f5e53f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/375/format/webp![]()" target="_blank" rel="noopener">https://upload-images.jianshu.io/upload_images/3241580-298e524479f5e53f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/375/format/webp![]()</a></p><p> <strong>查看版本</strong></p><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><p>可以参考官方文档 <a href="https://link.jianshu.com?t=https%3A%2F%2Fhexo.io%2Fzh-cn%2Fdocs%2F" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></p><ol><li><p>初始化hexo，在刚才的文件夹中打开git bash输入命令（git bash打开后<br> 因为一直要用，所以不要动不动就关闭掉）：<br> <code>hexo init</code><br> 初始化可能比较慢，稍安勿躁（要下载hexo框架的很多资源，还有默认主题），完成之后</p><p><img src="https://upload-images.jianshu.io/upload_images/3241580-7ec9539cb26fd253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/581/format/webp" alt></p></li></ol><p> 你会看到一下文件</p><p><img src="https://upload-images.jianshu.io/upload_images/3241580-7dcb862f572a0e2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/498/format/webp" alt></p><p> <strong>根目录下的文件结构</strong></p><p> 解释一下（目前不需要管他们） </p><ul><li>node_modules：为hexo的插件目录，作用是利用此目录的插件生成<br> 对应功能的静态HTML等脚本代码。</li><li>scaffolds：模版文件。每次新建文章时，Hexo 会尝试在 scaffolds 文件夹中寻找同名文件，并根据其内容建立文章。所以可以在这里添加自己的 layout，作为常用的新建模板使用。</li><li>source：这个文件夹是放文章和图片等资源文件的。</li><li>themes：存放主题的文件夹</li><li>_config.yml：站点配置文件，很多全局配置都在这个文件中。</li></ul><p> 做完第一步，来先看看效果，<br>git bash中输入命令：<br><code>hexo server</code><br>（或者懒人模式，直接输入<code>hexo s</code>）</p><ul><li>在浏览器中输入<a href="https://link.jianshu.com/?t=http%3A%2F%2Flocalhost%3A4000" target="_blank" rel="noopener">http://localhost:4000</a><br>就可以看到效果。如下图</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3241580-519f07ae3bb433fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><ul><li>在git bash窗口中按 ctrl + c 退出本地服务</li></ul><p>生成静态文件<br> 此步是为了上传到码云做的。因为目前只能自己在本地访问博客，但是想让其他人看到就要结合码云（github或者coding）来做了。<br> 还是在咱们blog的文件夹中打开git bash输入命令：<br> <code>hexo generate</code>（或懒人模式直接输入<code>hexo g</code>）<br> 目录中就会多出一个public文件夹</p><p> <img src="https://upload-images.jianshu.io/upload_images/3241580-f9aa7d104ff0e168.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/489/format/webp" alt></p><p> 这个文件夹就是我们托管到码云上用的文件夹。 </p><p>部署静态Html文件到码云</p><ul><li>首先我们要有一个码云账号（小伙伴们用自己的邮箱手机等注册一个）<br><a href="https://link.jianshu.com/?t=https%3A%2F%2Fgitee.com%2F" target="_blank" rel="noopener">https://gitee.com/</a></li><li>创建一个项目</li><li>创建完项目后得到项目的Https的地址后面要用。地址获取如下图</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3241580-d73e5b94b3c7bd6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/815/format/webp" alt></p><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。但是我们要先安装一个插件。<br> 在git bash输入命令：<br> <code>npm install hexo-deployer-git --save</code><br> 接下来是配置根目录_config.jml文件（用记事本或者各种编辑器打开），<br> 修改deploy的值，修改前如下图：</p><p> <img src="https://upload-images.jianshu.io/upload_images/3241580-d5658bfb27ff0214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/241/format/webp" alt></p><p> 修改后如下图 </p><p> <img src="https://upload-images.jianshu.io/upload_images/3241580-cc6bc1e88d633393.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/434/format/webp" alt></p><p>其中repo: 跟的地址就是刚才码云仓库的地址 </p><p><img src="https://upload-images.jianshu.io/upload_images/3241580-b6cf52e822ffd9ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/815/format/webp" alt></p><ul><li>(以防有些小伙伴找不到，赘余一下)(最后修改完千万别忘了保存一下)<br> 还有 branch和message这两个写不写都可以，默认也会帮你补上，知道git命令的小伙伴都会知道这两个字段是干嘛的，不知道的忽略就好，不影响使用，有强迫症的学霸可以自行百度 :)</li></ul><p>开始部署 在blog文件夹中打开git bash输入命令：<br> <code>hexo deploy</code><br> 之后会弹出输入码云账号密码的对话框。<br> 部署成功之后进入自己的码云账号，查看之前创建的项目中出现了本地项目中public文件夹中的文件</p><p> <img src="https://upload-images.jianshu.io/upload_images/3241580-2a602c1f250b7da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/936/format/webp" alt></p><p> 这时候就代表部署成功了。 </p><p>然后开启码云的Pages功能： </p><p><img src="https://upload-images.jianshu.io/upload_images/3241580-2cc0d1f81ccf4afd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/905/format/webp" alt></p><p>启动服务   </p><p><img src="https://upload-images.jianshu.io/upload_images/3241580-81f78946b27a5e12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/933/format/webp" alt></p><p>访问连接   </p><p><img src="https://upload-images.jianshu.io/upload_images/3241580-18c414ad84055aa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/886/format/webp" alt></p><p>擦，什么鬼，怎么和本地服务器看到的不一样，样式全无 </p><p><img src="https://upload-images.jianshu.io/upload_images/3241580-11d071f5d713c820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/947/format/webp" alt></p><p>不要慌，我也在这里郁闷了好久，所以写出来分享给大家</p><p>原因：<br> 网上各种说法都有，有绑定自己域名的，有什么什么的，我觉得都没有抓住本质，其实就是需要修改一下_config.yml配置文件，之前在本地跑服务器有样式，是因为所有的资源都在本地，都能找到，现在资源都上传到云端了，资源的对应关系肯定有所改变，因为找不到对应的资源了所以没有样式了。</p><p>解决办法：修改_config.yml<br> 还是用记事本或者各种编辑器打开_config.yml找到</p><p><img src="https://upload-images.jianshu.io/upload_images/3241580-c2bf19b225d46018.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/451/format/webp" alt> </p><p>  注释写的也很清楚，需要修改url和root，根据刚才Page服务中看到的网址 </p><p> <img src="https://upload-images.jianshu.io/upload_images/3241580-695e82b7c47ba812.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/886/format/webp" alt></p><p>然后再进入blog的文件夹执行命令：</p><ul><li><code>hexo clean</code></li><li><code>hexo generate</code></li><li><code>hexo deploy</code><br>建议，以后每次进行修改然后重新部署到码云时，都执行这三句命令 或者偷懒直接输入<code>hexo generate --deploy</code> </li></ul><p>然后咱们再回到码云的Pages页面，点开链接，如果看到</p><p> <img src="https://upload-images.jianshu.io/upload_images/3241580-0188c03a28cf509d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/938/format/webp" alt></p><p> 大吉大利，今晚吃鸡， </p><p>但是如果看到的还是 </p><p><img src="https://upload-images.jianshu.io/upload_images/3241580-eb1ea8fe8a962d83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/947/format/webp" alt></p><p>擦，还是老样子，有没有搞错，惊不惊喜，意不意外，大家不要慌，该做的咱们都已经做完了。 出现这种情况， </p><ul><li><ul><li>1.码云部署没有反应过来</li><li>2.就是浏览器保留了之前的缓存，清除一下缓存，或者直接换一个浏览器再打开我们的网址</li></ul></li><li>当你看到</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/3241580-0188c03a28cf509d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/938/format/webp" alt></p><p>一片极乐净土，恭喜你，终于费了九牛二虎之力完成了部署，自此我们拥有了一个自己的小天地 </p><p><strong>如果以上方法并没有解决找不到样式的问题请移步github部署！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 部署 </tag>
            
            <tag> Hex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE.js组件精讲-写在最后</title>
      <link href="/2018/09/07/%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E/"/>
      <url>/2018/09/07/%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>亲爱的读者，到这里本小册就要结束了，你是否从中学习到了属于你的知识呢？我们来回顾一下小册的内容吧。</p><p>Vue.js 在开发独立组件时，由于它的特殊性，无法使用 Vuex、Bus 这样的第三方插件来做组件通信，因此小册提到了 3 种组件间的通信方法，都是支持跨多级的：</p><ol><li>provide / inject：由父组件通过 <code>provide</code> 向下提供一个数据，子组件在需要时，通过 <code>inject</code> 注入这个依赖，就可以直接访问父级的数据了。</li><li>dispatch / broadcast：组件向上派发或向下广播一个自定义事件，组件通过 <code>$on</code> 来监听。</li><li>findComponents 系列：共包含 5 个方法，通过组件的 <code>name</code> 选项，遍历找到对应的实例，这是组件通信的终极方案，适用于所有场景。</li></ol><p>本册总共讲解了 7 个组件的实例：</p><ol><li>具有数据校验功能的 Form 组件，它用到了第 1 种组件通信；</li><li>组合多选框 Checkbox 组件，它用到了第 2 种和第 3 种组件通信；</li><li>Display 组件，它利用 Vue.js 的构造器 extend 和手动挂载 $mount API；</li><li>全局通知 $Alert 组件，也是利用了 $mount API，与传统组件不同的是，它基于 Vue.js 组件开发，但却是以 JavaScript 的形式调用的，并且组件会在 body 节点下渲染；</li><li>表格组件 Table，典型的数据驱动型组件，使用了函数式组件（Functional Render）来自定义列模板；</li><li>表格组件 Table，与上例不同的是，它的自定义列模板使用了 <code>slot-scope</code>；</li><li>树形控件 Tree，典型的数据驱动型组件，也是典型的递归组件，其中利用 computed 做父子节点联动是精髓。</li></ol><p>最后的拓展部分，对 Vue.js 组件的常见 API 做了详细介绍，以及常见的 Vue.js 面试题分析和对开源的一些见解。</p><p>Vue.js 组件开发，归根到底拼的是 JavaScript 的功底，Vue.js 在其中只是决定了开发模式，所以，打好 JavaScript 基础才是最重要的。</p><p>最后，祝愿亲爱的读者能在编程的道路上越走越远。</p><p><strong>另外，如果您有关于 Vue.js 或其它前端相关的问题，可以通过 <a href="https://dev.iviewui.com/issues" target="_blank" rel="noopener">iView 社区</a> 付费向笔者提问，希望能对一部分人有所帮助。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 组件的三个 API</title>
      <link href="/2018/09/07/%E5%9F%BA%E7%A1%80%EF%BC%9AVue.js%20%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%20API%EF%BC%9Aprop%E3%80%81event%E3%80%81slot/"/>
      <url>/2018/09/07/%E5%9F%BA%E7%A1%80%EF%BC%9AVue.js%20%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%20API%EF%BC%9Aprop%E3%80%81event%E3%80%81slot/</url>
      
        <content type="html"><![CDATA[<h1 id="基础：Vue-js-组件的三个-API：prop、event、slot"><a href="#基础：Vue-js-组件的三个-API：prop、event、slot" class="headerlink" title="基础：Vue.js 组件的三个 API：prop、event、slot"></a>基础：Vue.js 组件的三个 API：prop、event、slot</h1><blockquote><p>如果您已经对 Vue.js 组件的基础用法了如指掌，可以跳过本小节，不过当做复习稍读一下也无妨。</p></blockquote><h2 id="组件的构成"><a href="#组件的构成" class="headerlink" title="组件的构成"></a>组件的构成</h2><p>一个再复杂的组件，都是由三部分组成的：prop、event、slot，它们构成了 Vue.js 组件的 API。如果你开发的是一个通用组件，那一定要事先设计好这三部分，因为组件一旦发布，后面再修改 API 就很困难了，使用者都是希望不断新增功能，修复 bug，而不是经常变更接口。如果你阅读别人写的组件，也可以从这三个部分展开，它们可以帮助你快速了解一个组件的所有功能。</p><h3 id="属性-prop"><a href="#属性-prop" class="headerlink" title="属性 prop"></a>属性 prop</h3><p><code>prop</code> 定义了这个组件有哪些可配置的属性，组件的核心功能也都是它来确定的。写通用组件时，props 最好用<strong>对象</strong>的写法，这样可以针对每个属性设置类型、默认值或自定义校验属性的值，这点在组件开发中很重要，然而很多人却忽视，直接使用 props 的数组用法，这样的组件往往是不严谨的。比如我们封装一个按钮组件 <code>&lt;i-button&gt;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button :class=&quot;&apos;i-button-size&apos; + size&quot; :disabled=&quot;disabled&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 判断参数是否是其中之一</span><br><span class="line">  function oneOf (value, validList) &#123;</span><br><span class="line">    for (let i = 0; i &lt; validList.length; i++) &#123;</span><br><span class="line">      if (value === validList[i]) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      size: &#123;</span><br><span class="line">        validator (value) &#123;</span><br><span class="line">          return oneOf(value, [&apos;small&apos;, &apos;large&apos;, &apos;default&apos;]);</span><br><span class="line">        &#125;,</span><br><span class="line">        default: &apos;default&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      disabled: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;i-button size=&quot;large&quot;&gt;&lt;/i-button&gt;</span><br><span class="line">&lt;i-button disabled&gt;&lt;/i-button&gt;</span><br></pre></td></tr></table></figure><p>组件中定义了两个属性：尺寸 size 和 是否禁用 disabled。其中 size 使用 <code>validator</code> 进行了值的自定义验证，也就是说，从父级传入的 size，它的值必须是指定的 <strong>small、large、default</strong> 中的一个，默认值是 default，如果传入这三个以外的值，都会抛出一条警告。</p><p>要注意的是，组件里定义的 props，都是<strong>单向数据流</strong>，也就是只能通过父级修改，组件自己不能修改 props 的值，只能修改定义在 data 里的数据，非要修改，也是通过后面介绍的自定义事件通知父级，由父级来修改。</p><p>在使用组件时，也可以传入一些标准的 html 特性，比如 <strong>id</strong>、<strong>class</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i-button id=&quot;btn1&quot; class=&quot;btn-submit&quot;&gt;&lt;/i-button&gt;</span><br></pre></td></tr></table></figure><p>这样的 html 特性，在组件内的 <code>&lt;button&gt;</code> 元素上会继承，并不需要在 props 里再定义一遍。这个特性是默认支持的，如果不期望开启，在组件选项里配置 <code>inheritAttrs: false</code> 就可以禁用了。</p><h3 id="插槽-slot"><a href="#插槽-slot" class="headerlink" title="插槽 slot"></a>插槽 slot</h3><p>如果要给上面的按钮组件 <code>&lt;i-button&gt;</code> 添加一些文字内容，就要用到组件的第二个 API：插槽 slot，它可以分发组件的内容，比如在上面的按钮组件中定义一个插槽：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button :class=&quot;&apos;i-button-size&apos; + size&quot; :disabled=&quot;disabled&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>&lt;slot&gt;</code> 节点就是指定的一个插槽的位置，这样在组件内部就可以扩展内容了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;i-button&gt;按钮 1&lt;/i-button&gt;</span><br><span class="line">&lt;i-button&gt;</span><br><span class="line">  &lt;strong&gt;按钮 2&lt;/strong&gt;</span><br><span class="line">&lt;/i-button&gt;</span><br></pre></td></tr></table></figure><p>当需要多个插槽时，会用到具名 slot，比如上面的组件我们再增加一个 slot，用于设置另一个图标组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button :class=&quot;&apos;i-button-size&apos; + size&quot; :disabled=&quot;disabled&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;icon&quot;&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;i-button&gt;</span><br><span class="line">  &lt;i-icon slot=&quot;icon&quot; type=&quot;checkmark&quot;&gt;&lt;/i-icon&gt;</span><br><span class="line">  按钮 1</span><br><span class="line">&lt;/i-button&gt;</span><br></pre></td></tr></table></figure><p>这样，父级内定义的内容，就会出现在组件对应的 slot 里，没有写名字的，就是默认的 slot。</p><p>在组件的 <code>&lt;slot&gt;</code> 里也可以写一些默认的内容，这样在父级没有写任何 slot 时，它们就会出现，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot&gt;提交&lt;/slot&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义事件-event"><a href="#自定义事件-event" class="headerlink" title="自定义事件 event"></a>自定义事件 event</h3><p>现在我们给组件 <code>&lt;i-button&gt;</code> 加一个点击事件，目前有两种写法，我们先看自定义事件 event（部分代码省略）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;handleClick&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick (event) &#123;</span><br><span class="line">        this.$emit(&apos;on-click&apos;, event);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过 <code>$emit</code>，就可以触发自定义的事件 <code>on-click</code> ，在父级通过 <code>@on-click</code> 来监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i-button @on-click=&quot;handleClick&quot;&gt;&lt;/i-button&gt;</span><br></pre></td></tr></table></figure><p>上面的 click 事件，是在组件内部的 <code>&lt;button&gt;</code> 元素上声明的，这里还有另一种方法，直接在父级声明，但为了区分原生事件和自定义事件，要用到事件修饰符 <code>.native</code>，所以上面的示例也可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i-button @click.native=&quot;handleClick&quot;&gt;&lt;/i-button&gt;</span><br></pre></td></tr></table></figure><p>如果不写 <code>.native</code> 修饰符，那上面的 <code>@click</code> 就是<strong>自定义事件</strong> click，而非<strong>原生事件</strong> click，但我们在组件内只触发了 <code>on-click</code> 事件，而不是 <code>click</code>，所以直接写 <code>@click</code> 会监听不到。</p><h2 id="组件的通信"><a href="#组件的通信" class="headerlink" title="组件的通信"></a>组件的通信</h2><p>一般来说，组件可以有以下几种关系：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/18/166864d066bbcf69?w=790&h=632&f=png&s=36436" alt="组件关系"></p><p>A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。组件间经常会通信，Vue.js 内置的通信手段一般有两种：</p><ul><li><code>ref</code>：给元素或组件注册引用信息；</li><li><code>$parent</code> / <code>$children</code>：访问父 / 子实例。</li></ul><p>这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据，比如下面的示例中，用 ref 来访问组件（部分代码省略）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// component-a</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &apos;Vue.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      window.alert(&apos;Hello&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      const comA = this.$refs.comA;</span><br><span class="line">      console.log(comA.title);  // Vue.js</span><br><span class="line">      comA.sayHello();  // 弹窗</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>$parent</code> 和 <code>$children</code> 类似，也是基于当前上下文访问父组件或全部子组件的。</p><p>这两种方法的弊端是，无法在<strong>跨级</strong>或<strong>兄弟</strong>间通信，比如下面的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// parent.vue</span><br><span class="line">&lt;component-a&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br></pre></td></tr></table></figure><p>我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案，本小册不再做它们的介绍，读者可以自行阅读相关内容。不过，它们都是依赖第三方插件的存在，这在开发独立组件时是不可取的，而在小册的后续章节，会陆续介绍一些黑科技，它们完全不依赖任何三方插件，就可以轻松得到任意的组件实例，或在任意组件间进行通信，且适用于任意场景。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本小节带您复习了 Vue.js 组件的核心知识点，虽然这并没有完全覆盖 Vue.js 的 API，但对于组件开发来说已经足够了，后续章节也会陆续扩展更多的用法。</p><p>基于 Vue.js 开发独立组件，并不是新奇的挑战，坦率地讲，它本质上还是 JavaScript。掌握了 Vue.js 组件的这三个 API 后，剩下的便是程序的设计。在组件开发中，最难的环节应当是解耦组件的交互逻辑，尽量把复杂的逻辑分发到不同的子组件中，然后彼此建立联系，在这其中，计算属性（computed）和混合（mixins）是两个重要的技术点，合理利用，就能发挥出 Vue.js 语言的最大特点：把状态（数据）的维护交给 Vue.js 处理，我们只专注在交互上。</p><p>当您最终读完本小册时，应该会总结出和笔者一样的感悟：Vue.js 组件开发，玩到最后还是在拼 JavaScript 功底。对于每一位使用 Vue.js 的开发者来说，阅读完本小册都可以尝试开发和维护一套属于自己的组件库，并乐在其中，而且你会越发觉得，一个组件或一套组件库，就是融合了前端精髓的产出。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/5a4353766fb9a044fb080927" target="_blank" rel="noopener">Vue 组件通信之 Bus</a></li><li><a href="https://juejin.im/entry/58cb4c36b123db00532076a2" target="_blank" rel="noopener">Vuex 通俗版教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据校验功能的表单组件</title>
      <link href="/2018/09/07/%E5%AE%9E%E6%88%98%201%EF%BC%9A%E5%85%B7%E6%9C%89%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Form/"/>
      <url>/2018/09/07/%E5%AE%9E%E6%88%98%201%EF%BC%9A%E5%85%B7%E6%9C%89%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E5%8A%9F%E8%83%BD%E7%9A%84%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Form/</url>
      
        <content type="html"><![CDATA[<h1 id="实战-1：具有数据校验功能的表单组件——Form"><a href="#实战-1：具有数据校验功能的表单组件——Form" class="headerlink" title="实战 1：具有数据校验功能的表单组件——Form"></a>实战 1：具有数据校验功能的表单组件——Form</h1><p>在第 3 节和第 4 节中，我们介绍了组件间的两种通信方法：provide / inject 和 dispatch / broadcast，前者是 Vue.js 内置的，主要用于子组件获取父组件（包括跨级）的状态；后者是自行实现的一种混合，用于父子组件（包括跨级）间通过自定义事件通信。本小节则基于这两种通信方法，来实现一个具有数据校验功能的表单组件——Form。</p><h2 id="Form-组件概览"><a href="#Form-组件概览" class="headerlink" title="Form 组件概览"></a>Form 组件概览</h2><p>表单类组件在项目中会大量使用，比如输入框（Input）、单选（Radio）、多选（Checkbox）、下拉选择器（Select）等。在使用表单类组件时，也会经常用到数据校验，如果每次都写校验程序来对每一个表单控件校验，会很低效，因此需要一个能够校验基础表单控件的组件，也就是本节要完成的 Form 组件。一般的组件库都提供了这个组件，比如 iView，它能够校验内置的 15 种控件，且支持校验自定义组件，如下图所示：</p><p>（也可以在线访问本示例体验：<a href="https://run.iviewui.com/jwrqnFss" target="_blank" rel="noopener">https://run.iviewui.com/jwrqnFss</a>）</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c3b75c37ef9a8?w=900&h=958&f=gif&s=1820338" alt></p><p>Form 组件分为两个部分，一个是外层的 <code>Form</code> 表单域组件，一组表单控件只有一个 Form，而内部包含了多个 <code>FormItem</code> 组件，每一个表单控件都被一个 FormItem 包裹。基本的结构看起来像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;i-form&gt;</span><br><span class="line">  &lt;i-form-item&gt;</span><br><span class="line">    &lt;i-input v-model=&quot;form.name&quot;&gt;&lt;/i-input&gt;</span><br><span class="line">  &lt;/i-form-item&gt;</span><br><span class="line">  &lt;i-form-item&gt;</span><br><span class="line">    &lt;i-input v-model=&quot;form.mail&quot;&gt;&lt;/i-input&gt;</span><br><span class="line">  &lt;/i-form-item&gt;</span><br><span class="line">&lt;/i-form&gt;</span><br></pre></td></tr></table></figure><p>Form 要用到数据校验，并在对应的 FormItem 中给出校验失败的提示，校验我们会用到一个开源库：<a href="https://github.com/yiminghe/async-validator" target="_blank" rel="noopener">async-validator</a>，基本主流的组件库都是基于它做的校验。使用它很简单，只需按要求写好一个校验规则就好，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; required: true, message: &apos;邮箱不能为空&apos;, trigger: &apos;blur&apos; &#125;,</span><br><span class="line">  &#123; type: &apos;email&apos;, message: &apos;邮箱格式不正确&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这个代表要校验的数据先判断是否为空（required: true），如果为空，则提示“邮箱不能为空”，触发校验的事件为失焦（trigger: ‘blur’），如果第一条满足要求，再进行第二条的验证，判断是否为邮箱格式（type: ‘email’）等等，还支持自定义校验规则。更详细的用法可以参看它的文档。</p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>我们先使用最新的 Vue CLI 3 创建一个空白的项目（如果你还不清楚 Vue CLI 3 的用法，需要先补习一下了，可以阅读文末的扩展阅读 1），并使用 <code>vue-router</code> 插件，同时安装好 <code>async-validator</code> 库。</p><p>在 <code>src/components</code> 下新建一个 <code>form</code> 文件夹，并初始化两个组件 <code>form.vue</code> 和 <code>form-item.vue</code>，然后初始化项目，配置路由，创建一个页面能够被访问到。</p><blockquote><p>本节所有代码可以在 <a href="https://github.com/icarusion/vue-component-book" target="_blank" rel="noopener">https://github.com/icarusion/vue-component-book</a> 中查看，你可以一边看源码，一边阅读本节；也可以边阅读，边动手实现一遍，遇到问题再参考完整的源码。</p></blockquote><p>第 2 节我们介绍到，编写一个 Vue.js 组件，最重要的是设计好它的接口，一个 Vue.js 组件的接口来自三个部分：props、slots、events。而 Form 和 FormItem 两个组件主要做数据校验，用不到 events。Form 的 slot 就是一系列的 FormItem，FormItem 的 slot 就是具体的表单控件，比如输入框 <code>&lt;i-input&gt;</code> 。那主要设计的就是 props 了。</p><p>在 <code>Form</code> 组件中，定义两个 props：</p><ul><li>model：表单控件绑定的数据对象，在校验或重置时会访问该数据对象下对应的表单数据，类型为 Object。</li><li>rules：表单验证规则，即上面介绍的 async-validator 所使用的校验规则，类型为 Object。</li></ul><p>在 <code>FormItem</code> 组件中，也定义两个 props：</p><ul><li>label：单个表单组件的标签文本，类似原生的 <code>&lt;label&gt;</code> 元素，类型为 String。</li><li>prop：对应表单域 Form 组件 model 里的字段，用于在校验或重置时访问表单组件绑定的数据，类型为 String。</li></ul><p>定义好 props，就可以写出大概的用例了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;i-form :model=&quot;formValidate&quot; :rules=&quot;ruleValidate&quot;&gt;</span><br><span class="line">      &lt;i-form-item label=&quot;用户名&quot; prop=&quot;name&quot;&gt;</span><br><span class="line">        &lt;i-input v-model=&quot;formValidate.name&quot;&gt;&lt;/i-input&gt;</span><br><span class="line">      &lt;/i-form-item&gt;</span><br><span class="line">      &lt;i-form-item label=&quot;邮箱&quot; prop=&quot;mail&quot;&gt;</span><br><span class="line">        &lt;i-input v-model=&quot;formValidate.mail&quot;&gt;&lt;/i-input&gt;</span><br><span class="line">      &lt;/i-form-item&gt;</span><br><span class="line">    &lt;/i-form&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import iForm from &apos;../components/form/form.vue&apos;;</span><br><span class="line">  import iFormItem from &apos;../components/form/form-item.vue&apos;;</span><br><span class="line">  import iInput from &apos;../components/input/input.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; iForm, iFormItem, iInput &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        formValidate: &#123;</span><br><span class="line">          name: &apos;&apos;,</span><br><span class="line">          mail: &apos;&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        ruleValidate: &#123;</span><br><span class="line">          name: [</span><br><span class="line">            &#123; required: true, message: &apos;用户名不能为空&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">          mail: [</span><br><span class="line">            &#123; required: true, message: &apos;邮箱不能为空&apos;, trigger: &apos;blur&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;email&apos;, message: &apos;邮箱格式不正确&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>有两点需要注意的是：</p><ol><li>这里的 <code>&lt;i-input&gt;</code> 并不是原生的 <code>&lt;input&gt;</code> 输入框，而是一个特制的输入框组件，之后会介讲解的功能和代码；</li><li><code>&lt;i-form-item&gt;</code> 的属性 <code>prop</code> 是字符串，所以它前面没有冒号（即不是 <code>:prop=&quot;name&quot;</code>）。</li></ol><p>当前的两个组件只是个框框，还没有实现任何功能，不过万事开头难，定义好接口，剩下的就是补全组件的逻辑，而对于使用者，知道了 props、events、slots，就已经能写出上例的使用代码了。</p><p>到此，Form 和 FormItem 的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- form.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;form&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;iForm&apos;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      model: &#123;</span><br><span class="line">        type: Object</span><br><span class="line">      &#125;,</span><br><span class="line">      rules: &#123;</span><br><span class="line">        type: Object</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- form-item.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label v-if=&quot;label&quot;&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;iFormItem&apos;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      label: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &apos;&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      prop: &#123;</span><br><span class="line">        type: String</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="在-Form-中缓存-FormItem-实例"><a href="#在-Form-中缓存-FormItem-实例" class="headerlink" title="在 Form 中缓存 FormItem 实例"></a>在 Form 中缓存 FormItem 实例</h2><p><code>Form</code> 组件的核心功能是数据校验，一个 Form 中包含了多个 FormItem，当点击提交按钮时，要逐一对每个 FormItem 内的表单组件校验，而校验是由使用者发起，并通过 <code>Form</code> 来调用每一个 <code>FormItem</code> 的验证方法，再将校验结果汇总后，通过 <code>Form</code> 返回出去。大致的流程如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c3b7f124cb84a?w=1046&h=610&f=png&s=42610" alt></p><p>因为要在 Form 中逐一调用 FormItem 的验证方法，而 Form 和 FormItem 是独立的，需要预先将 FormItem 的每个实例缓存在 Form 中，这个操作就需要用到第 4 节的组件通信方法。当每个 FormItem 渲染时，将其自身（this）作为参数通过 <code>dispatch</code> 派发到 Form 组件中，然后通过一个数组缓存起来；同理当 FormItem 销毁时，将其从 Form 缓存的数组中移除。相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// form-item.vue，部分代码省略</span><br><span class="line"></span><br><span class="line">import Emitter from &apos;../../mixins/emitter.js&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;iFormItem&apos;,</span><br><span class="line">  mixins: [ Emitter ],</span><br><span class="line">  // 组件渲染时，将实例缓存在 Form 中</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    // 如果没有传入 prop，则无需校验，也就无需缓存</span><br><span class="line">    if (this.prop) &#123;</span><br><span class="line">      this.dispatch(&apos;iForm&apos;, &apos;on-form-item-add&apos;, this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 组件销毁前，将实例从 Form 的缓存中移除</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    this.dispatch(&apos;iForm&apos;, &apos;on-form-item-remove&apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，Vue.js 的组件渲染顺序是由内而外的，所以 FormItem 要先于 Form 渲染，在 FormItem 的 mounted 触发时，我们向 Form 派发了事件 <code>on-form-item-add</code>，并将当前 FormItem 的实例（this）传递给了 Form，而此时，Form 的 mounted 尚未触发，因为 Form 在最外层，如果在 Form 的 mounted 里监听事件，是不可以的，所以要在其 created 内监听自定义事件，Form 的 created 要先于 FormItem 的 mounted。所以 Form 的相关代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// form.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;iForm&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      fields: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    this.$on(&apos;on-form-item-add&apos;, (field) =&gt; &#123;</span><br><span class="line">      if (field) this.fields.push(field);</span><br><span class="line">    &#125;);</span><br><span class="line">    this.$on(&apos;on-form-item-remove&apos;, (field) =&gt; &#123;</span><br><span class="line">      if (field.prop) this.fields.splice(this.fields.indexOf(field), 1);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的数据 <code>fields</code> 就是用来缓存所有 FormItem 实例的。</p><h2 id="触发校验"><a href="#触发校验" class="headerlink" title="触发校验"></a>触发校验</h2><p>Form 支持两种事件来触发校验：</p><ul><li><strong>blur</strong>：失去焦点时触发，常见的有输入框失去焦点时触发校验；</li><li><strong>change</strong>：实时输入时触发或选择时触发，常见的有输入框实时输入时触发校验、下拉选择器选择项目时触发校验等。</li></ul><p>以上两个事件，都是有具体的表单组件来触发的，我们先来编写一个简单的输入框组件 <code>i-input</code>。在 <code>components</code> 下新建目录 <code>input</code>，并创建文件 <code>input.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- input.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">         type=&quot;text&quot;</span><br><span class="line">         :value=&quot;currentValue&quot;</span><br><span class="line">         @input=&quot;handleInput&quot;</span><br><span class="line">         @blur=&quot;handleBlur&quot;</span><br><span class="line">         /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Emitter from &apos;../../mixins/emitter.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;iInput&apos;,</span><br><span class="line">    mixins: [ Emitter ],</span><br><span class="line">    props: &#123;</span><br><span class="line">      value: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &apos;&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        currentValue: this.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      value (val) &#123;</span><br><span class="line">        this.currentValue = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleInput (event) &#123;</span><br><span class="line">        const value = event.target.value;</span><br><span class="line">        this.currentValue = value;</span><br><span class="line">        this.$emit(&apos;input&apos;, value);</span><br><span class="line">        this.dispatch(&apos;iFormItem&apos;, &apos;on-form-change&apos;, value);</span><br><span class="line">      &#125;,</span><br><span class="line">      handleBlur () &#123;</span><br><span class="line">        this.dispatch(&apos;iFormItem&apos;, &apos;on-form-blur&apos;, this.currentValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Input 组件中，绑定在 <code>&lt;input&gt;</code> 元素上的原生事件 <code>@input</code>，每当输入一个字符，都会调用句柄 <code>handleInput</code>，并通过 <code>dispatch</code> 方法向上级的 FormItem 组件派发自定义事件 <code>on-form-change</code>；同理，绑定的原生事件 <code>@blur</code> 会在 input 失焦时触发，并传递事件 <code>on-form-blur</code>。</p><p>基础组件有了，接下来要做的，是在 FormItem 中监听来自 Input 组件派发的自定义事件。这里可以在 mounted 中监听，因为你的手速远赶不上组件渲染的速度，不过在 created 中监听也是没任何问题的。相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// form-item.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    setRules () &#123;</span><br><span class="line">      this.$on(&apos;on-form-blur&apos;, this.onFieldBlur);</span><br><span class="line">      this.$on(&apos;on-form-change&apos;, this.onFieldChange);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    if (this.prop) &#123;</span><br><span class="line">      this.dispatch(&apos;iForm&apos;, &apos;on-form-item-add&apos;, this);</span><br><span class="line">      this.setRules();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>setRules</code> 方法，监听表单组件的两个事件，并绑定了句柄函数 <code>onFieldBlur</code> 和 <code>onFieldChange</code>，分别对应 blur 和 change 两种事件类型。当 onFieldBlur 或 onFieldChange 函数触发时，就意味着 FormItem 要对<strong>当前的数据</strong>进行一次校验。当前的数据，指的就是通过表单域 Form 中定义的 props：model，结合当前 FormItem 定义的 props：prop 来确定的数据，可以回顾上文写过的用例。</p><p>因为 FormItem 中只定义了数据源的某个 key 名称（即属性 prop），要拿到 Form 中 model 里的数据，需要用到第 3 节的通信方法 provide / inject。所以在 Form 中，把整个实例（this）向下提供，并在 FormItem 中注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// form.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      form : this</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// form-item.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&apos;form&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备好这些，接着就是最核心的校验功能了。blur 和 change 事件都会触发校验，它们调用同一个方法，只是参数不同。相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// form-item.vue，部分代码省略</span><br><span class="line">import AsyncValidator from &apos;async-validator&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&apos;form&apos;],</span><br><span class="line">  props: &#123;</span><br><span class="line">    prop: &#123;</span><br><span class="line">      type: String</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      validateState: &apos;&apos;,  // 校验状态</span><br><span class="line">      validateMessage: &apos;&apos;,  // 校验不通过时的提示信息</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 从 Form 的 model 中动态得到当前表单组件的数据</span><br><span class="line">    fieldValue () &#123;</span><br><span class="line">      return this.form.model[this.prop];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 从 Form 的 rules 属性中，获取当前 FormItem 的校验规则</span><br><span class="line">    getRules () &#123;</span><br><span class="line">      let formRules = this.form.rules;</span><br><span class="line"></span><br><span class="line">      formRules = formRules ? formRules[this.prop] : [];</span><br><span class="line"></span><br><span class="line">      return [].concat(formRules || []);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 只支持 blur 和 change，所以过滤出符合要求的 rule 规则</span><br><span class="line">    getFilteredRule (trigger) &#123;</span><br><span class="line">      const rules = this.getRules();</span><br><span class="line">      return rules.filter(rule =&gt; !rule.trigger || rule.trigger.indexOf(trigger) !== -1);</span><br><span class="line">    &#125;,</span><br><span class="line">    /**</span><br><span class="line">     * 校验数据</span><br><span class="line">     * @param trigger 校验类型</span><br><span class="line">     * @param callback 回调函数</span><br><span class="line">     */</span><br><span class="line">    validate(trigger, callback = function () &#123;&#125;) &#123;</span><br><span class="line">      let rules = this.getFilteredRule(trigger);</span><br><span class="line"></span><br><span class="line">      if (!rules || rules.length === 0) &#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 设置状态为校验中</span><br><span class="line">      this.validateState = &apos;validating&apos;;</span><br><span class="line"></span><br><span class="line">      // 以下为 async-validator 库的调用方法</span><br><span class="line">      let descriptor = &#123;&#125;;</span><br><span class="line">      descriptor[this.prop] = rules;</span><br><span class="line"></span><br><span class="line">      const validator = new AsyncValidator(descriptor);</span><br><span class="line">      let model = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      model[this.prop] = this.fieldValue;</span><br><span class="line"></span><br><span class="line">      validator.validate(model, &#123; firstFields: true &#125;, errors =&gt; &#123;</span><br><span class="line">        this.validateState = !errors ? &apos;success&apos; : &apos;error&apos;;</span><br><span class="line">        this.validateMessage = errors ? errors[0].message : &apos;&apos;;</span><br><span class="line"></span><br><span class="line">        callback(this.validateMessage);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    onFieldBlur() &#123;</span><br><span class="line">      this.validate(&apos;blur&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    onFieldChange() &#123;</span><br><span class="line">      this.validate(&apos;change&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 FormItem 的 <code>validate()</code> 方法中，最终做了两件事：</p><ol><li>设置了当前的校验状态 <code>validateState</code> 和校验不通过提示信息 <code>validateMessage</code>（通过值为空）；</li><li>将 validateMessage 通过回调 callback 传递给调用者，这里的调用者是 onFieldBlur 和 onFieldChange，它们只传入了第一个参数 <code>trigger</code>，callback 并未传入，因此也不会触发回调，而这个回调主要是给 Form 用的，因为 Form 中可以通过提交按钮一次性校验所有的 FormItem（后文会介绍）这里只是表单组件触发事件时，对当前 FormItem 做校验。</li></ol><p>除了校验，还可以对当前数据进行重置。重置是指将表单组件的数据还原到最初绑定的值，而不是清空，因此需要预先缓存一份初始值。同时我们将校验信息也显示在模板中，并加一些样式。相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- form-item.vue，部分代码省略 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label v-if=&quot;label&quot; :class=&quot;&#123; &apos;i-form-item-label-required&apos;: isRequired &#125;&quot;&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">      &lt;div v-if=&quot;validateState === &apos;error&apos;&quot; class=&quot;i-form-item-message&quot;&gt;&#123;&#123; validateMessage &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      label: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &apos;&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      prop: &#123;</span><br><span class="line">        type: String</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        isRequired: false,  // 是否为必填</span><br><span class="line">        validateState: &apos;&apos;,  // 校验状态</span><br><span class="line">        validateMessage: &apos;&apos;,  // 校验不通过时的提示信息</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      // 如果没有传入 prop，则无需校验，也就无需缓存</span><br><span class="line">      if (this.prop) &#123;</span><br><span class="line">        this.dispatch(&apos;iForm&apos;, &apos;on-form-item-add&apos;, this);</span><br><span class="line"></span><br><span class="line">        // 设置初始值，以便在重置时恢复默认值</span><br><span class="line">        this.initialValue = this.fieldValue;</span><br><span class="line"></span><br><span class="line">        this.setRules();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      setRules () &#123;</span><br><span class="line">        let rules = this.getRules();</span><br><span class="line">        if (rules.length) &#123;</span><br><span class="line">          rules.every((rule) =&gt; &#123;</span><br><span class="line">            // 如果当前校验规则中有必填项，则标记出来</span><br><span class="line">            this.isRequired = rule.required;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.$on(&apos;on-form-blur&apos;, this.onFieldBlur);</span><br><span class="line">        this.$on(&apos;on-form-change&apos;, this.onFieldChange);</span><br><span class="line">      &#125;,</span><br><span class="line">      // 从 Form 的 rules 属性中，获取当前 FormItem 的校验规则</span><br><span class="line">      getRules () &#123;</span><br><span class="line">        let formRules = this.form.rules;</span><br><span class="line"></span><br><span class="line">        formRules = formRules ? formRules[this.prop] : [];</span><br><span class="line"></span><br><span class="line">        return [].concat(formRules || []);</span><br><span class="line">      &#125;,</span><br><span class="line">      // 重置数据</span><br><span class="line">      resetField () &#123;</span><br><span class="line">        this.validateState = &apos;&apos;;</span><br><span class="line">        this.validateMessage = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">        this.form.model[this.prop] = this.initialValue;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .i-form-item-label-required:before &#123;</span><br><span class="line">    content: &apos;*&apos;;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  .i-form-item-message &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>至此，FormItem 代码已经完成，不过它只具有单独校验的功能，也就是说，只能对自己的一个表单组件验证，不能对一个表单域里的所有组件一次性全部校验。而实现全部校验和全部重置的功能，要在 Form 中完成。</p><p>上文已经介绍到，在 <code>Form</code> 组件中，预先缓存了全部的 FormItem 实例，自然也能在 Form 中调用它们。通过点击提交按钮全部校验，或点击重置按钮全部重置数据，只需要在 Form 中，逐一调用缓存的 FormItem 实例中的 <code>validate</code> 或 <code>resetField</code> 方法。相关代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// form.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      fields: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 公开方法：全部重置数据</span><br><span class="line">    resetFields() &#123;</span><br><span class="line">      this.fields.forEach(field =&gt; &#123;</span><br><span class="line">        field.resetField();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    // 公开方法：全部校验数据，支持 Promise</span><br><span class="line">    validate(callback) &#123;</span><br><span class="line">      return new Promise(resolve =&gt; &#123;</span><br><span class="line">        let valid = true;</span><br><span class="line">        let count = 0;</span><br><span class="line">        this.fields.forEach(field =&gt; &#123;</span><br><span class="line">          field.validate(&apos;&apos;, errors =&gt; &#123;</span><br><span class="line">            if (errors) &#123;</span><br><span class="line">              valid = false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (++count === this.fields.length) &#123;</span><br><span class="line">              // 全部完成</span><br><span class="line">              resolve(valid);</span><br><span class="line">              if (typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">                callback(valid);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然说 Vue.js 的 API 只来自 prop、event、slot 这三个部分，但一些场景下，需要通过 <code>ref</code> 来访问这个组件，调用它的一些内置方法，比如上面的 <code>validate</code> 和 <code>resetFields</code> 方法，就需要使用者来主动调用。</p><p>resetFields 很简单，就是通过循环逐一调用 FormItem 的 resetField 方法来重置数据。validate 稍显复杂，它支持两种使用方法，一种是普通的回调，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;i-form ref=&quot;form&quot;&gt;&lt;/i-form&gt;</span><br><span class="line">    &lt;button @click=&quot;handleSubmit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleSubmit () &#123;</span><br><span class="line">        this.$refs.form.validate((valid) =&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            window.alert(&apos;提交成功&apos;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            window.alert(&apos;表单校验失败&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>同时也支持 Promise，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleSubmit () &#123;</span><br><span class="line">  const validate = this.$refs.form.validate();</span><br><span class="line">  </span><br><span class="line">  validate.then((valid) =&gt; &#123;</span><br><span class="line">    if (valid) &#123;</span><br><span class="line">      window.alert(&apos;提交成功&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      window.alert(&apos;表单校验失败&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Form 组件定义的 Promise 中，只调用了 resolve(valid)，没有调用 reject()，因此不能直接使用 <code>.catch()</code> ，不过聪明的你稍作修改，肯定能够支持到！</p><p>完整的用例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;具有数据校验功能的表单组件——Form&lt;/h3&gt;</span><br><span class="line">    &lt;i-form ref=&quot;form&quot; :model=&quot;formValidate&quot; :rules=&quot;ruleValidate&quot;&gt;</span><br><span class="line">      &lt;i-form-item label=&quot;用户名&quot; prop=&quot;name&quot;&gt;</span><br><span class="line">        &lt;i-input v-model=&quot;formValidate.name&quot;&gt;&lt;/i-input&gt;</span><br><span class="line">      &lt;/i-form-item&gt;</span><br><span class="line">      &lt;i-form-item label=&quot;邮箱&quot; prop=&quot;mail&quot;&gt;</span><br><span class="line">        &lt;i-input v-model=&quot;formValidate.mail&quot;&gt;&lt;/i-input&gt;</span><br><span class="line">      &lt;/i-form-item&gt;</span><br><span class="line">    &lt;/i-form&gt;</span><br><span class="line">    &lt;button @click=&quot;handleSubmit&quot;&gt;提交&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;handleReset&quot;&gt;重置&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import iForm from &apos;../components/form/form.vue&apos;;</span><br><span class="line">  import iFormItem from &apos;../components/form/form-item.vue&apos;;</span><br><span class="line">  import iInput from &apos;../components/input/input.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; iForm, iFormItem, iInput &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        formValidate: &#123;</span><br><span class="line">          name: &apos;&apos;,</span><br><span class="line">          mail: &apos;&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        ruleValidate: &#123;</span><br><span class="line">          name: [</span><br><span class="line">            &#123; required: true, message: &apos;用户名不能为空&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">          mail: [</span><br><span class="line">            &#123; required: true, message: &apos;邮箱不能为空&apos;, trigger: &apos;blur&apos; &#125;,</span><br><span class="line">            &#123; type: &apos;email&apos;, message: &apos;邮箱格式不正确&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleSubmit () &#123;</span><br><span class="line">        this.$refs.form.validate((valid) =&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            window.alert(&apos;提交成功&apos;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            window.alert(&apos;表单校验失败&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      handleReset () &#123;</span><br><span class="line">        this.$refs.form.resetFields();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c3b8a77e382ec?w=1417&h=550&f=png&s=60805" alt></p><p>完整的示例源码可通过 GitHub 查看：</p><p><a href="https://github.com/icarusion/vue-component-book" target="_blank" rel="noopener">https://github.com/icarusion/vue-component-book</a></p><blockquote><p>项目基于 Vue CLI 3 构建，下载安装依赖后，通过 npm run serve 可访问。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>组件最终的效果看起来有点 “low”，但它实现的功能却不简单。通过这个实战，你或许已经感受到本小册一开始说的，组件写到最后，都是在拼 JavaScript 功底。的确，Vue.js 组件为我们提供了一种新的代码组织形式，但归根到底，是离不开 JS 的。</p><p>这个实战，你应该对独立组件间的通信用法有进一步的认知了吧，不过，这还不是组件通信的终极方案，下一节，我们就来看看适用于任何场景的组件通信方案。</p><p>注：本节部分代码参考 <a href="https://github.com/iview/iview/tree/2.0/src/components/form" target="_blank" rel="noopener">iView</a>。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/5bdec6e8e51d4505327a8952" target="_blank" rel="noopener">一份超级详细的Vue-cli3.0使用教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态渲染 .vue 文件的组件</title>
      <link href="/2018/09/07/%E5%AE%9E%E6%88%98%203%EF%BC%9A%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%20.vue%20%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94%20Display/"/>
      <url>/2018/09/07/%E5%AE%9E%E6%88%98%203%EF%BC%9A%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%20.vue%20%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94%20Display/</url>
      
        <content type="html"><![CDATA[<h1 id="实战-3：动态渲染-vue-文件的组件——-Display"><a href="#实战-3：动态渲染-vue-文件的组件——-Display" class="headerlink" title="实战 3：动态渲染 .vue 文件的组件—— Display"></a>实战 3：动态渲染 .vue 文件的组件—— Display</h1><p>你可能用过 <a href="https://jsfiddle.net/" target="_blank" rel="noopener">jsfiddle</a> 或 <a href="https://jsbin.com" target="_blank" rel="noopener">jsbin</a> 之类的网站，在里面你可以用 CDN 的形式引入 Vue.js，然后在线写示例，实时运行，比如下面这个例子：</p><p><a href="https://jsfiddle.net/c87yh92v/" target="_blank" rel="noopener">https://jsfiddle.net/c87yh92v/</a></p><p>不过，这类网站主要是一个 html，里面包含 js、css 部分，渲染侧是用 iframe 嵌入你编写的 html，并实时更新。在这些网站写示例，是不能直接写 <code>.vue</code> 文件的，因为没法进行编译。</p><p>再来看另一个网站 <a href="https://run.iviewui.com/" target="_blank" rel="noopener">iView Run</a>（之前小节也有提到），它是能够在线编写一个标准的 <code>.vue</code> 文件，并及时渲染的，它也预置了 iView 环境，你可以使用 iView 组件库全部的组件。本小节，我们就来实现这样一个能够动态渲染 .vue 文件的 <code>Display</code> 组件，当然，用到的核心技术就是上一节的 <code>extend</code> 和 <code>$mount</code>。</p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>一个常规的 <code>.vue</code> 文件一般都会包含 3 个部分：</p><ul><li><code>&lt;template&gt;</code>：组件的模板；</li><li><code>&lt;script&gt;</code>：组件的选项，不包含 <code>el</code>；</li><li><code>&lt;style&gt;</code>：CSS 样式。</li></ul><p>回忆一下用 <code>extend</code> 来构造一个组件实例，它的选项 <code>template</code> 其实就是上面 <code>&lt;template&gt;</code> 的内容，其余选项对应的是 <code>&lt;script&gt;</code>，样式 <code>&lt;style&gt;</code> 事实上与 Vue.js 无关，我们可以先不管。这样的话，当拿到一个 .vue 的文件（整体其实是字符串），只需要把 <code>&lt;template&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code> 使用正则分割，把对应的部分传递给 extend 创建的实例就可以。</p><p>Display 是一个功能型的组件，没有交互和事件，只需要一个 prop：code 将 .vue 的内容传递过来，其余工作都是在组件内完成的，这对使用者很友好。当然，你也可以设计成三个 props，分别对应 html、js、css，那分割的工作就要使用者来完成。出于使用者优先原则，苦活累活当然是在组件内完成了，因此推荐第一个方案。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在 <code>src/components</code> 目录下创建 <code>display</code> 目录，并新建 <code>display.vue</code> 文件，基本结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- display.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;display&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      code: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        html: &apos;&apos;,</span><br><span class="line">        js: &apos;&apos;,</span><br><span class="line">        css: &apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>父级传递 <code>code</code> 后，将其分割，并保存在 data 的 html、js、css 中，后续使用。</p><p>我们使用正则，基于 <code>&lt;&gt;</code> 和 <code>&lt;/&gt;</code> 的特性进行分割：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// display.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getSource (source, type) &#123;</span><br><span class="line">      const regex = new RegExp(`&lt;$&#123;type&#125;[^&gt;]*&gt;`);</span><br><span class="line">      let openingTag = source.match(regex);</span><br><span class="line"></span><br><span class="line">      if (!openingTag) return &apos;&apos;;</span><br><span class="line">      else openingTag = openingTag[0];</span><br><span class="line"></span><br><span class="line">      return source.slice(source.indexOf(openingTag) + openingTag.length, source.lastIndexOf(`&lt;/$&#123;type&#125;&gt;`));</span><br><span class="line">    &#125;,</span><br><span class="line">    splitCode () &#123;</span><br><span class="line">      const script = this.getSource(this.code, &apos;script&apos;).replace(/export default/, &apos;return &apos;);</span><br><span class="line">      const style = this.getSource(this.code, &apos;style&apos;);</span><br><span class="line">      const template = &apos;&lt;div id=&quot;app&quot;&gt;&apos; + this.getSource(this.code, &apos;template&apos;) + &apos;&lt;/div&gt;&apos;;</span><br><span class="line"></span><br><span class="line">      this.js = script;</span><br><span class="line">      this.css = style;</span><br><span class="line">      this.html = template;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSource 方法接收两个参数：</p><ul><li>source：.vue 文件代码，即 props: code；</li><li>type：分割的部分，也就是 template、script、style。</li></ul><p>分割后，返回的内容不再包含 <code>&lt;template&gt;</code> 等标签，直接是对应的内容，在 splitCode 方法中，把分割好的代码分别赋值给 data 中声明的 html、js、css。有两个细节需要注意：</p><ol><li>.vue 的 <code>&lt;script&gt;</code> 部分一般都是以 <code>export default</code> 开始的，可以看到在 splitCode 方法中将它替换为了 <code>return</code>，这个在后文会做解释，当前只要注意，我们分割完的代码，仍然是字符串；</li><li>在分割的 <code>&lt;template&gt;</code> 外层套了一个 <code>&lt;div id=&quot;app&quot;&gt;</code>，这是为了容错，有时使用者传递的 <code>code</code> 可能会忘记在外层包一个节点，没有根节点的组件，是会报错的。</li></ol><p>准备好这些基础工作后，就可以用 <code>extend</code> 渲染组件了，在这之前，我们先思考一个问题：上文说到，当前的 <code>this.js</code> 是字符串，而 extend 接收的选项可不是字符串，而是一个对象类型，那就要先把 this.js 转为一个对象。</p><p>不卖关子，来介绍 <code>new Function</code> 用法，先看个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sum = new Function(&apos;a&apos;, &apos;b&apos;, &apos;return a + b&apos;);</span><br><span class="line"></span><br><span class="line">console.log(sum(2, 6)); // 8</span><br></pre></td></tr></table></figure><p>new Function 的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Function ([arg1[, arg2[, ...argN]],] functionBody)</span><br></pre></td></tr></table></figure><p>arg1, arg2, … argN 是被函数使用的参数名称，<strong>functionBody</strong> 是一个含有包括函数定义的 JavaScript 语句的<strong>字符串</strong>。也就是说，示例中的字符串 <code>return a + b</code> 被当做语句执行了。</p><p>上文说到，<code>this.js</code> 中是将 <em>export default</em> 替换为 <em>return</em> 的，如果将 this.js 传入 new Function 里，那么 this.js 就执行了，这时因为有 return，返回的就是一个对象类型的 this.js 了。</p><p>如果你还不是很理解 new Function，可以到文末的扩展阅读进一步了解。除了 new Function，你熟悉的 <code>eval</code> 函数也可以使用，它与 new Function 功能类似。</p><p>知道了这些，下面的内容就容易理解了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- display.vue，部分代码省略 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;display&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Vue from &apos;vue&apos;;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        component: null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      renderCode () &#123;</span><br><span class="line">        this.splitCode();</span><br><span class="line"></span><br><span class="line">        if (this.html !== &apos;&apos; &amp;&amp; this.js !== &apos;&apos;) &#123;</span><br><span class="line">          const parseStrToFunc = new Function(this.js)();</span><br><span class="line"></span><br><span class="line">          parseStrToFunc.template =  this.html;</span><br><span class="line">          const Component = Vue.extend( parseStrToFunc );</span><br><span class="line">          this.component = new Component().$mount();</span><br><span class="line"></span><br><span class="line">          this.$refs.display.appendChild(this.component.$el);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      this.renderCode();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>extend 构造的实例通过 $mount 渲染后，挂载到了组件唯一的一个节点 <code>&lt;div ref=&quot;display&quot;&gt;</code> 上。</p><p>现在 html 和 js 都有了，还剩下 css。加载 css 没有什么奇技淫巧，就是创建一个 <code>&lt;style&gt;</code> 标签，然后把 css 写进去，再插入到页面的 <code>&lt;head&gt;</code> 中，这样 css 就被浏览器解析了。为了便于后面在 <code>this.code</code> 变化或组件销毁时移除动态创建的 <code>&lt;style&gt;</code> 标签，我们给每个 style 标签加一个随机 id 用于标识。</p><p>在 <code>src/utils</code> 目录下新建 <code>random_str.js</code> 文件，并写入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 生成随机字符串</span><br><span class="line">export default function (len = 32) &#123;</span><br><span class="line">  const $chars = &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890&apos;;</span><br><span class="line">  const maxPos = $chars.length;</span><br><span class="line">  let str = &apos;&apos;;</span><br><span class="line">  for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    str += $chars.charAt(Math.floor(Math.random() * maxPos));</span><br><span class="line">  &#125;</span><br><span class="line">  return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难理解，这个方法是从指定的 a-zA-Z0-9 中随机生成 32 位的字符串。</p><p>补全 renderCode 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// display.vue，部分代码省略</span><br><span class="line">import randomStr from &apos;../../utils/random_str.js&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      id: randomStr()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    renderCode () &#123;</span><br><span class="line">      if (this.html !== &apos;&apos; &amp;&amp; this.js !== &apos;&apos;) &#123;</span><br><span class="line">        // ...</span><br><span class="line">        if (this.css !== &apos;&apos;) &#123;</span><br><span class="line">          const style = document.createElement(&apos;style&apos;);</span><br><span class="line">          style.type = &apos;text/css&apos;;</span><br><span class="line">          style.id = this.id;</span><br><span class="line">          style.innerHTML = this.css;</span><br><span class="line">          document.getElementsByTagName(&apos;head&apos;)[0].appendChild(style);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Display 组件销毁时，也要手动销毁 extend 创建的实例以及上面的 css：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// display.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    destroyCode () &#123;</span><br><span class="line">      const $target = document.getElementById(this.id);</span><br><span class="line">      if ($target) $target.parentNode.removeChild($target);</span><br><span class="line"></span><br><span class="line">      if (this.component) &#123;</span><br><span class="line">        this.$refs.display.removeChild(this.component.$el);</span><br><span class="line">        this.component.$destroy();</span><br><span class="line">        this.component = null;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    this.destroyCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>this.code</code> 更新时，整个过程要重新来一次，所以要对 <code>code</code> 进行 watch 监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// display.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    code () &#123;</span><br><span class="line">      this.destroyCode();</span><br><span class="line">      this.renderCode();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 Display 组件的所有内容。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>新建一条路由，并在 <code>src/views</code> 下新建页面 <code>display.vue</code> 来使用 Display 组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/views/display.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;动态渲染 .vue 文件的组件—— Display&lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">    &lt;i-display :code=&quot;code&quot;&gt;&lt;/i-display&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import iDisplay from &apos;../components/display/display.vue&apos;;</span><br><span class="line">  import defaultCode from &apos;./default-code.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; iDisplay &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        code: defaultCode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// src/views/default-code.js</span><br><span class="line">const code =</span><br><span class="line">`&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input v-model=&quot;message&quot;&gt;</span><br><span class="line">        &#123;&#123; message &#125;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message: &apos;&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;`;</span><br><span class="line"></span><br><span class="line">export default code;</span><br></pre></td></tr></table></figure><p>如果使用的是 Vue CLI 3 默认的配置，直接运行时，会抛出下面的错误：</p><blockquote><p>[Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</p></blockquote><p>这涉及到另一个知识点，就是 Vue.js 的版本。在使用 Vue.js 2 时，有独立构建（standalone）和运行时构建（runtime-only）两种版本可供选择，详细的介绍请阅读文末扩展阅读 2。</p><p>Vue CLI 3 默认使用了 vue.runtime.js，它不允许编译 template 模板，因为我们在 Vue.extend 构造实例时，用了 <code>template</code> 选项，所以会报错。解决方案有两种，一是手动将 template 改写为 Render 函数，但这成本太高；另一种是对 Vue CLI 3 创建的工程做简单的配置。我们使用后者。</p><p>在项目根目录，新建文件 <code>vue.config.js</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  runtimeCompiler: true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它的作用是，是否使用包含运行时编译器的 Vue 构建版本。设置为 <code>true</code> 后就可以在 Vue 组件中使用 <code>template</code> 选项了，但是应用额外增加 10kb 左右（还好吧）。</p><p>加了这个配置，报错就消失了，组件也能正常显示。</p><p>以上就是 Display 组件所有的内容，如果你感兴趣，可以把它进一步封装，做成 iView Run 这样的产品。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这个小小的 Display 组件，能做的事还有很多，比如要写一套 Vue 组件库的文档，传统方法是在开发环境写一个个的 .vue 文件，然后编译打包、上传资源、上线，如果要修改，哪怕一个标点符号，都要重新编译打包、上传资源、上线。有了 Display 组件，只需要提供一个服务来在线修改文档的 .vue，就能实时更新，不用打包、上传、上线。</p><p>还有一点很重要的是，可以看到，在 iView Run 里，默认是直接可以写 iView 组件库的全部组件，并没有额外引入，这是因为 Display 所在的工程，已经将 iView 安装在了全局，Vue.extend 在构造实例时，已经可以使用全局安装的插件了，如果你还全局安装了其它插件，比如 axios，都是可以直接使用的。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener">new Function</a></li><li><a href="https://jingsam.github.io/2016/10/23/standalone-vs-runtime-only-build-in-vuejs2.html" target="_blank" rel="noopener">Vue.js 2.0 独立构建和运行时构建的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合多选框组件</title>
      <link href="/2018/09/07/%E5%AE%9E%E6%88%98%202%EF%BC%9A%E7%BB%84%E5%90%88%E5%A4%9A%E9%80%89%E6%A1%86%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94CheckboxGroup%20&amp;%20Checkbox/"/>
      <url>/2018/09/07/%E5%AE%9E%E6%88%98%202%EF%BC%9A%E7%BB%84%E5%90%88%E5%A4%9A%E9%80%89%E6%A1%86%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94CheckboxGroup%20&amp;%20Checkbox/</url>
      
        <content type="html"><![CDATA[<h1 id="实战-2：组合多选框组件——CheckboxGroup-amp-Checkbox"><a href="#实战-2：组合多选框组件——CheckboxGroup-amp-Checkbox" class="headerlink" title="实战 2：组合多选框组件——CheckboxGroup &amp; Checkbox"></a>实战 2：组合多选框组件——CheckboxGroup &amp; Checkbox</h1><p>在第 5 节，我们完成了具有数据校验功能的组件 Form，本小节继续开发一个新的组件——组合多选框 Checkbox。它作为基础组件，也能集成在 Form 内并应用其验证规则。</p><h2 id="Checkbox-组件概览"><a href="#Checkbox-组件概览" class="headerlink" title="Checkbox 组件概览"></a>Checkbox 组件概览</h2><p>多选框组件也是由两个组件组成：CheckboxGroup 和 Checkbox。单独使用时，只需要一个 Checkbox，组合使用时，两者都要用到。效果如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/2/166d39853b7facd8?w=562&h=334&f=png&s=29035" alt></p><p>单独使用，常见的场景有注册时勾选以同意注册条款，它只有一个独立的 Checkbox 组件，并且绑定一个布尔值，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;i-checkbox v-model=&quot;single&quot;&gt;单独选项&lt;/i-checkbox&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        single: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>而组合使用的场景就很多了，填写表单时会经常用到，它的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;i-checkbox-group v-model=&quot;multiple&quot;&gt;</span><br><span class="line">    &lt;i-checkbox label=&quot;option1&quot;&gt;选项 1&lt;/i-checkbox&gt;</span><br><span class="line">    &lt;i-checkbox label=&quot;option2&quot;&gt;选项 2&lt;/i-checkbox&gt;</span><br><span class="line">    &lt;i-checkbox label=&quot;option3&quot;&gt;选项 3&lt;/i-checkbox&gt;</span><br><span class="line">    &lt;i-checkbox label=&quot;option4&quot;&gt;选项 4&lt;/i-checkbox&gt;</span><br><span class="line">  &lt;/i-checkbox-group&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        multiple: [&apos;option1&apos;, &apos;option3&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>v-model</code> 用在了 CheckboxGroup 上，绑定的值为一个数组，数组的值就是内部 Checkbox 绑定的 label。</p><p>用法看起来比 Form 要简单多，不过也有两个个技术难点：</p><ul><li>Checkbox 要同时支持单独使用和组合使用的场景；</li><li>CheckboxGroup 和 Checkbox 内可能嵌套其它的布局组件。</li></ul><p>对于第一点，要在 Checkbox 初始化时判断是否父级有 CheckboxGroup，如果有就是组合使用的，否则就是单独使用。而第二点，正好可以用上一节的通信方法，很容易就能解决。</p><p>两个组件并行开发，会容易理不清逻辑，不妨我们先开发独立的 Checkbox 组件。</p><h2 id="单独使用的-Checkbox"><a href="#单独使用的-Checkbox" class="headerlink" title="单独使用的 Checkbox"></a>单独使用的 Checkbox</h2><p>设计一个组件时，还是要从它的 3 个 API 入手：prop、event、slot。</p><p>因为要在 Checkbox 组件上直接使用 <code>v-model</code> 来双向绑定数据，那必不可少的一个 prop 就是 <code>value</code>，还有 event <code>input</code>，因为 v-model 本质上是一个语法糖（如果你还不清楚这种用法，可以阅读最后的扩展阅读 1）。</p><p>理论上，我们只需要给 <code>value</code> 设置为布尔值即可，也就是 true / false，不过为了扩展性，我们再定义两个 props：<code>trueValue</code> 和 <code>falseValue</code>，它们允许用户指定 <code>value</code> 用什么值来判断是否选中。因为实际开发中，数据库中并不直接保存 true / false，而是 1 / 0 或其它字符串，如果强制使用 Boolean，使用者就要再额外转换一次，这样的 API 设计不太友好。</p><p>除此之外，还需要一个 <code>disabled</code> 属性来表示是否禁用。</p><p>自定义事件 events 上文已经说了一个 <code>input</code>，用于实现 v-model 语法糖；另一个就是 <code>on-change</code>，当选中 / 取消选中时触发，用于通知父级状态发生了变化。</p><p>slot 使用默认的就好，显示辅助文本。</p><p>理清楚了 API，先来写一个基础的 <code>v-model</code> 功能，这在大部分组件中都类似。</p><p>在 <code>src/components</code> 下新建目录 <code>checkbox</code>，并新建两个文件 <code>checkbox.vue</code> 和 <code>checkbox-group.vue</code>。我们先来看 Checkbox：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- checkbox.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;label&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">             type=&quot;checkbox&quot;</span><br><span class="line">             :disabled=&quot;disabled&quot;</span><br><span class="line">             :checked=&quot;currentValue&quot;</span><br><span class="line">             @change=&quot;change&quot;&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;iCheckbox&apos;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      disabled: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;,</span><br><span class="line">      value: &#123;</span><br><span class="line">        type: [String, Number, Boolean],</span><br><span class="line">        default: false</span><br><span class="line">      &#125;,</span><br><span class="line">      trueValue: &#123;</span><br><span class="line">        type: [String, Number, Boolean],</span><br><span class="line">        default: true</span><br><span class="line">      &#125;,</span><br><span class="line">      falseValue: &#123;</span><br><span class="line">        type: [String, Number, Boolean],</span><br><span class="line">        default: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        currentValue: this.value</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change (event) &#123;</span><br><span class="line">        if (this.disabled) &#123;</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const checked = event.target.checked;</span><br><span class="line">        this.currentValue = checked;</span><br><span class="line"></span><br><span class="line">        const value = checked ? this.trueValue : this.falseValue;</span><br><span class="line">        this.$emit(&apos;input&apos;, value);</span><br><span class="line">        this.$emit(&apos;on-change&apos;, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>因为 <code>value</code> 被定义为 prop，它只能由父级修改，本身是不能修改的，在 <code>&lt;input&gt;</code> 触发 change 事件，也就是点击选择时，不能由 Checkbox 来修改这个 value，所以我们在 data 里定义了一个 <code>currentValue</code>，并把它绑定在 <code>&lt;input :checked=&quot;currentValue&quot;&gt;</code>，这样就可以在 Checkbox 内修改 <code>currentValue</code>。这是自定义组件使用 <code>v-model</code> 的“惯用伎俩”。</p><p>代码看起来都很简单，但有三个细节需要额外说明：</p><ol><li>选中的控件，直接使用了 <code>&lt;input type=&quot;checkbox&quot;&gt;</code>，而没有用 div + css 来自己实现选择的逻辑和样式，这样的好处是，使用 input 元素，你的自定义组件仍然为 html 内置的基础组件，可以使用浏览器默认的行为和快捷键，也就是说，浏览器知道这是一个选择框，而换成 div + css，浏览器可不知道这是个什么鬼。如果你觉得原生的 input 丑，没关系，是可以用 css 美化的，不过这不是本小册的重点，在此就不介绍了。</li><li><code>&lt;input&gt;</code>、<code>&lt;slot&gt;</code> 都是包裹在一个 <code>&lt;label&gt;</code> 元素内的，这样做的好处是，当点击 <code>&lt;slot&gt;</code> 里的文字时，<code>&lt;input&gt;</code> 选框也会被触发，否则只有点击那个小框才会触发，那样不太容易选中，影响用户体验。</li><li><code>currentValue</code> 仍然是布尔值（true / false），因为它是组件 Checkbox 自己使用的，对于使用者无需关心，而 value 可以是 String、Number 或 Boolean，这取决于 <code>trueValue</code> 和 <code>falseValue</code> 的定义。</li></ol><p>现在实现的 <code>v-model</code>，只是由内而外的，也就是说，通过点击 <code>&lt;input&gt;</code>选择，会通知到使用者，而使用者手动修改了 prop <code>value</code> ，Checkbox 是没有做响应的，那继续补充代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- checkbox.vue，部分代码省略 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    watch: &#123;</span><br><span class="line">      value (val) &#123;</span><br><span class="line">        if (val === this.trueValue || val === this.falseValue) &#123;</span><br><span class="line">          this.updateModel();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          throw &apos;Value should be trueValue or falseValue.&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      updateModel () &#123;</span><br><span class="line">        this.currentValue = this.value === this.trueValue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>我们对 prop <code>value</code> 使用 watch 进行了监听，当父级修改它时，会调用 <code>updateModel</code> 方法，同步修改内部的 <code>currentValue</code> 。不过，不是所有的值父级都能修改的，所以用 if 条件判断了父级修改的值是否符合 trueValue / falseValue 所设置的，否则会抛错。</p><p>Checkbox 也是一个基础的表单类组件，它完全可以集成到 Form 里，所以，我们使用 Emitter 在 change 事件触发时，向 Form 派发一个事件，这样你就可以用第 5 节的 Form 组件来做数据校验了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- checkbox.vue，部分代码省略 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Emitter from &apos;../../mixins/emitter.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    mixins: [ Emitter ],</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change (event) &#123;</span><br><span class="line">        // ... </span><br><span class="line">        this.$emit(&apos;input&apos;, value);</span><br><span class="line">        this.$emit(&apos;on-change&apos;, value);</span><br><span class="line">        this.dispatch(&apos;iFormItem&apos;, &apos;on-form-change&apos;, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>至此，Checkbox 已经可以单独使用了，并支持 Form 的数据校验。下面来看组合使用。</p><h3 id="组合使用的-CheckboxGroup"><a href="#组合使用的-CheckboxGroup" class="headerlink" title="组合使用的 CheckboxGroup"></a>组合使用的 CheckboxGroup</h3><blockquote><p>友情提示：请先阅读 Vue.js 文档的 <a href="https://cn.vuejs.org/v2/guide/forms.html#%E5%A4%8D%E9%80%89%E6%A1%86" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/forms.html#复选框</a> 内容。</p></blockquote><p>CheckboxGroup 的 API 很简单：</p><ul><li>props：<code>value</code>，与 Checkbox 的类似，用于 v-model 双向绑定数据，格式为数组；</li><li>events：<code>on-change</code>，同 Checkbox；</li><li>slots：默认，用于放置 Checkbox。</li></ul><p>如果写了 CheckboxGroup，那就代表你要组合使用多选框，而非单独使用，两种模式，只能用其一，而判断的依据，就是是否用了 CheckboxGroup 组件。所以在 Checkbox 组件内，我们用上一节的 <code>findComponentUpward</code> 方法判断父组件是否有 <code>CheckboxGroup</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- checkbox.vue，部分代码省略 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;label&gt;</span><br><span class="line">    &lt;span&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">             v-if=&quot;group&quot;</span><br><span class="line">             type=&quot;checkbox&quot;</span><br><span class="line">             :disabled=&quot;disabled&quot;</span><br><span class="line">             :value=&quot;label&quot;</span><br><span class="line">             v-model=&quot;model&quot;</span><br><span class="line">             @change=&quot;change&quot;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">             v-else</span><br><span class="line">             type=&quot;checkbox&quot;</span><br><span class="line">             :disabled=&quot;disabled&quot;</span><br><span class="line">             :checked=&quot;currentValue&quot;</span><br><span class="line">             @change=&quot;change&quot;&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/label&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; findComponentUpward &#125; from &apos;../../utils/assist.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;iCheckbox&apos;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      label: &#123;</span><br><span class="line">        type: [String, Number, Boolean]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        model: [],</span><br><span class="line">        group: false,</span><br><span class="line">        parent: null</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      this.parent = findComponentUpward(this, &apos;iCheckboxGroup&apos;);</span><br><span class="line"></span><br><span class="line">      if (this.parent) &#123;</span><br><span class="line">        this.group = true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (this.group) &#123;</span><br><span class="line">        this.parent.updateModel(true);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.updateModel();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在 mounted 时，通过 findComponentUpward 方法，来判断父级是否有 CheckboxGroup 组件，如果有，就将 <code>group</code> 置为 true，并触发 CheckboxGroup 的 <code>updateModel</code> 方法，下文会介绍它的作用。</p><p>在 template 里，我们又写了一个 <code>&lt;input&gt;</code> 来区分是否是 group 模式。Checkbox 的 data 里新增加的 <code>model</code> 数据，其实就是父级 CheckboxGroup 的 <code>value</code>，会在下文的 <code>updateModel</code> 方法里给 Checkbox 赋值。</p><p>Checkbox 新增的 prop： <code>label</code> 只会在组合使用时有效，结合 <code>model</code> 来使用，用法已在 Vue.js 文档中介绍了 <a href="https://cn.vuejs.org/v2/guide/forms.html#%E5%A4%8D%E9%80%89%E6%A1%86" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/forms.html#复选框</a>。</p><p>在组合模式下，Checkbox 选中，就不用对 Form 派发事件了，应该在 CheckboxGroup 中派发，所以对 Checkbox 做最后的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- checkbox.vue，部分代码省略 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change (event) &#123;</span><br><span class="line">        if (this.disabled) &#123;</span><br><span class="line">          return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const checked = event.target.checked;</span><br><span class="line">        this.currentValue = checked;</span><br><span class="line"></span><br><span class="line">        const value = checked ? this.trueValue : this.falseValue;</span><br><span class="line">        this.$emit(&apos;input&apos;, value);</span><br><span class="line"></span><br><span class="line">        if (this.group) &#123;</span><br><span class="line">          this.parent.change(this.model);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.$emit(&apos;on-change&apos;, value);</span><br><span class="line">          this.dispatch(&apos;iFormItem&apos;, &apos;on-form-change&apos;, value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      updateModel () &#123;</span><br><span class="line">        this.currentValue = this.value === this.trueValue;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>剩余的工作，就是完成 checkbox-gourp.vue 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- checkbox-group.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; findComponentsDownward &#125; from &apos;../../utils/assist.js&apos;;</span><br><span class="line">  import Emitter from &apos;../../mixins/emitter.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;iCheckboxGroup&apos;,</span><br><span class="line">    mixins: [ Emitter ],</span><br><span class="line">    props: &#123;</span><br><span class="line">      value: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default () &#123;</span><br><span class="line">          return [];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        currentValue: this.value,</span><br><span class="line">        childrens: []</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      updateModel (update) &#123;</span><br><span class="line">        this.childrens = findComponentsDownward(this, &apos;iCheckbox&apos;);</span><br><span class="line">        if (this.childrens) &#123;</span><br><span class="line">          const &#123; value &#125; = this;</span><br><span class="line">          this.childrens.forEach(child =&gt; &#123;</span><br><span class="line">            child.model = value;</span><br><span class="line"></span><br><span class="line">            if (update) &#123;</span><br><span class="line">              child.currentValue = value.indexOf(child.label) &gt;= 0;</span><br><span class="line">              child.group = true;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      change (data) &#123;</span><br><span class="line">        this.currentValue = data;</span><br><span class="line">        this.$emit(&apos;input&apos;, data);</span><br><span class="line">        this.$emit(&apos;on-change&apos;, data);</span><br><span class="line">        this.dispatch(&apos;iFormItem&apos;, &apos;on-form-change&apos;, data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      this.updateModel(true);</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      value () &#123;</span><br><span class="line">        this.updateModel(true);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>代码很容易理解，需要介绍的就是 <code>updateModel</code> 方法。可以看到，一共有 3 个地方调用了 <code>updateModel</code>，其中两个是 CheckboxGroup 的 mounted 初始化和 watch 监听的 value 变化时调用；另一个是在 Checkbox 里的 mounted 初始化时调用。这个方法的作用就是在 CheckboxGroup 里通过 <code>findComponentsDownward</code> 方法找到所有的 Checkbox，然后把 CheckboxGroup 的 <code>value</code>，赋值给 Checkbox 的 <code>model</code>，并根据 Checkbox 的 <code>label</code>，设置一次当前 Checkbox 的选中状态。这样无论是由内而外选择，或由外向内修改数据，都是双向绑定的，而且支持动态增加 Checkbox 的数量。</p><p>以上就是组合多选组件——CheckboxGroup &amp; Checkbox 的全部内容，不知道你是否 get 到了呢！</p><p>留两个小作业：</p><ol><li>将 CheckboxGroup 和 Checkbox 组件集成在 Form 里完成一个数据校验的示例；</li><li>参考本节的代码，实现一个单选组件 Radio 和 RadioGroup。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>你看到的简单组件，其实都不简单。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/598bf7a3f265da3e252a1d6a" target="_blank" rel="noopener">v-model 指令在组件中怎么玩</a></li></ul><p>注：本节部分代码参考 <a href="https://github.com/iview/iview/tree/2.0/src/components/checkbox" target="_blank" rel="noopener">iView</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Render 自定义列的表格组件</title>
      <link href="/2018/09/07/%E5%AE%9E%E6%88%98%205%EF%BC%9A%E5%8F%AF%E7%94%A8%20Render%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E7%9A%84%E8%A1%A8%E6%A0%BC%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Table/"/>
      <url>/2018/09/07/%E5%AE%9E%E6%88%98%205%EF%BC%9A%E5%8F%AF%E7%94%A8%20Render%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E7%9A%84%E8%A1%A8%E6%A0%BC%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Table/</url>
      
        <content type="html"><![CDATA[<h1 id="实战-5：可用-Render-自定义列的表格组件——Table"><a href="#实战-5：可用-Render-自定义列的表格组件——Table" class="headerlink" title="实战 5：可用 Render 自定义列的表格组件——Table"></a>实战 5：可用 Render 自定义列的表格组件——Table</h1><p>表格组件 Table 是中后台产品中最常用的组件之一，用于展示大量结构化的数据。大多数组件库都提供了表格组件，比如 <a href="https://www.iviewui.com/components/table" target="_blank" rel="noopener">iView</a>，功能也是非常强大。正规的表格，是由 <code>&lt;table&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;td&gt;</code> 这些标签组成，一般分为表头 <strong>columns</strong> 和数据 <strong>data</strong>。本小节就来开发一个最基本的表格组件 Table，它支持使用 Render 函数来自定义某一列。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果表格只是呈现数据，是比较简单的，比如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16716c44a664e7f1?w=1876&h=502&f=png&s=60848" alt></p><p>因为结构简单，我们甚至不需要组件，直接使用标准的 table 系列标签就可以。但有的时候，除了呈现数据，也会带有一些交互，比如有一列操作栏，可以编辑整行的数据：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16716c54fc74a1a5?w=2088&h=456&f=gif&s=520544" alt></p><p>写一个个的 table 系列标签是很麻烦并且重复的，而组件的好处就是省去这些基础的工作，我们直接给 Table 组件传递列的配置 <strong>columns</strong> 和行数据 <strong>data</strong>，其余的都交给 Table 组件做了。</p><p>开发 Table 组件前，有必要先了解上文说到的一系列 table 标签。一般的 table 结构是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;thead&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">      &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/thead&gt;</span><br><span class="line">  &lt;tbody&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;王小明&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;18&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">      &lt;td&gt;张小刚&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;25&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><ul><li>table：定义 HTML 表格；</li><li>thead：定义表头；</li><li>tbody：定义表格主体；</li><li>tr：定义表格行；</li><li>th：定义表头单元格；</li><li>td：定义表格单元。</li></ul><p>标准的表格系列标签，跟 div+css 实现是有很大区别的，比如表格在做单元格合并时，有提供原生属性，用 div 就很麻烦了；再比如渲染原理上也有一定的区别，table 会在内容全部下载完后加载。详细的介绍可以阅读文末的扩展阅读 1。</p><p>知道了表格的结构，再来分析如何定制 API。可以看到，表格分为了两部分，表头 thead 和数据 tbody，那 props 也定义两个：</p><ul><li><p>columns：列配置，格式为数组，其中每一列 column 是一个对象，用来描述这一列的信息，它的具体说明如下：</p><ul><li>title：列头显示文字；</li><li>key：对应列内容的字段名；</li><li>render：自定义渲染列，使用 Vue 的 Render 函数，不定义则直接显示为文本。</li></ul><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    title: &apos;姓名&apos;,</span><br><span class="line">    key: &apos;name&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    title: &apos;年龄&apos;,</span><br><span class="line">    key: &apos;age&apos;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>data：显示的结构化数据，格式为数组，其中每一个对象，就是一行的数据，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    name: &apos;王小明&apos;,</span><br><span class="line">    age: 18</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: &apos;张小刚&apos;,</span><br><span class="line">    age: 25</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><p>column 定义的 <code>key</code> 值，与 data 是一一对应的，这是一种常见的数据接口定义规则，也是 Vue.js 组件中，用数据驱动而不是 slot 驱动的经典案例。</p><p>为什么 Table 组件要用数据驱动，而不是 slot 驱动呢？slot 在很多组件中的确很好用，不过 Table 组件包含了大量的基础表格标签，如果都交给使用者由 slot 承载的话，开发成本不亚于自己实现一个 table 了，而数据驱动就简单的多，数据一般从服务端获取后就可以直接使用（或简单处理），使用者主要来定义每列的配置 <strong>columns</strong> 就可以了。</p><p>因为不确定使用者要对某一列做什么交互，所以不能在 Table 内来实现自定义列。使用 Render 函数可以将复杂的自定义列模板的工作交给使用者来配置，Table 内只用一个 Functional Render 做中转。</p><h2 id="完成基础表格"><a href="#完成基础表格" class="headerlink" title="完成基础表格"></a>完成基础表格</h2><p>我们先来完成一个基础的表格组件，之后再接入 Render 来配置自定义列。</p><p>在 <code>src/components</code> 目录下新建 <code>table-render</code> 目录，并创建 <code>table.vue</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/table-render/table.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th v-for=&quot;col in columns&quot;&gt;&#123;&#123; col.title &#125;&#125;&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">      &lt;tr v-for=&quot;row in data&quot;&gt;</span><br><span class="line">        &lt;td v-for=&quot;col in columns&quot;&gt;&#123;&#123; row[col.key] &#125;&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      columns: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default () &#123;</span><br><span class="line">          return [];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default () &#123;</span><br><span class="line">          return [];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  table&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    border-collapse: collapse;</span><br><span class="line">    border-spacing: 0;</span><br><span class="line">    empty-cells: show;</span><br><span class="line">    border: 1px solid #e9e9e9;</span><br><span class="line">  &#125;</span><br><span class="line">  table th&#123;</span><br><span class="line">    background: #f7f7f7;</span><br><span class="line">    color: #5c6b77;</span><br><span class="line">    font-weight: 600;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">  &#125;</span><br><span class="line">  table td, table th&#123;</span><br><span class="line">    padding: 8px 16px;</span><br><span class="line">    border: 1px solid #e9e9e9;</span><br><span class="line">    text-align: left;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>props 中的 columns 和 data 的格式都是数组，这里要注意的是，如果 props 的类型是<strong>对象</strong>或<strong>数组</strong>，它的默认值必须从一个工厂函数获取。</p></blockquote><p>tbody 内嵌套使用了两次 <code>v-for</code>，外层循环数据 data，内层循环列 columns，这样就填充了每个单元格。</p><p>新建路由 <code>table-render</code>，并在 <code>src/views/</code> 目录下新建页面 <code>table-render.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/views/table-render.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;table-render :columns=&quot;columns&quot; :data=&quot;data&quot;&gt;&lt;/table-render&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import TableRender from &apos;../components/table-render/table.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; TableRender &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        columns: [</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;姓名&apos;,</span><br><span class="line">            key: &apos;name&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;年龄&apos;,</span><br><span class="line">            key: &apos;age&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;出生日期&apos;,</span><br><span class="line">            key: &apos;birthday&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;地址&apos;,</span><br><span class="line">            key: &apos;address&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;操作&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        data: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;王小明&apos;,</span><br><span class="line">            age: 18,</span><br><span class="line">            birthday: &apos;919526400000&apos;,</span><br><span class="line">            address: &apos;北京市朝阳区芍药居&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;张小刚&apos;,</span><br><span class="line">            age: 25,</span><br><span class="line">            birthday: &apos;696096000000&apos;,</span><br><span class="line">            address: &apos;北京市海淀区西二旗&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;李小红&apos;,</span><br><span class="line">            age: 30,</span><br><span class="line">            birthday: &apos;563472000000&apos;,</span><br><span class="line">            address: &apos;上海市浦东新区世纪大道&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;周小伟&apos;,</span><br><span class="line">            age: 26,</span><br><span class="line">            birthday: &apos;687024000000&apos;,</span><br><span class="line">            address: &apos;深圳市南山区深南大道&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>运行后的效果如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16716c5b99ef76ac?w=1986&h=416&f=png&s=88452" alt></p><p>表格已经能渲染出来了，但现在的单元格只是将 data 当作纯文本来显示，所以出生日期列显示为时间戳，因为服务端对日期有时会保存为时间戳格式。如果要显示正常的日期（如1991-5-14），目前可以另写一个计算属性（computed），手动将时间戳换算为标准日期格式后，来动态修改 data 里的 <code>birthday</code> 字段。这样做对于出生日期这样的数据还好，但对于<strong>操作</strong>这一列就不可取了，因为它带有业务逻辑，点击<strong>编辑</strong>按钮，是可以对当前行数据进行修改的。这时就要用到 Render 函数。</p><h2 id="使用-Render-自定义列模板"><a href="#使用-Render-自定义列模板" class="headerlink" title="使用 Render 自定义列模板"></a>使用 Render 自定义列模板</h2><p>上一节我们已经介绍过函数式组件 Functional Render 的用法，它没有状态和上下文，主要用于中转一个组件，用在本节的 Table 组件非常合适。</p><p>先在 <code>src/components/table-render</code> 目录下新建 <code>render.js</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// src/components/table-render/render.js</span><br><span class="line">export default &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  props: &#123;</span><br><span class="line">    row: Object,</span><br><span class="line">    column: Object,</span><br><span class="line">    index: Number,</span><br><span class="line">    render: Function</span><br><span class="line">  &#125;,</span><br><span class="line">  render: (h, ctx) =&gt; &#123;</span><br><span class="line">    const params = &#123;</span><br><span class="line">      row: ctx.props.row,</span><br><span class="line">      column: ctx.props.column,</span><br><span class="line">      index: ctx.props.index</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return ctx.props.render(h, params);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>render.js 定义了 4 个 props：</p><ul><li><strong>row</strong>：当前行的数据；</li><li><strong>column</strong>：当前列的数据；</li><li><strong>index</strong>：当前是第几行；</li><li><strong>render</strong>：具体的 render 函数内容。</li></ul><p>这里的 <code>render</code> 选项并没有渲染任何节点，而是直接返回 props 中定义的 render，并将 h 和当前的行、列、序号作为参数传递出去。然后在 table.vue 里就可以使用 render.js 组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- table.vue，部分代码省略 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th v-for=&quot;col in columns&quot;&gt;&#123;&#123; col.title &#125;&#125;&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">      &lt;tr v-for=&quot;(row, rowIndex) in data&quot;&gt;</span><br><span class="line">        &lt;td v-for=&quot;col in columns&quot;&gt;</span><br><span class="line">          &lt;template v-if=&quot;&apos;render&apos; in col&quot;&gt;</span><br><span class="line">            &lt;Render :row=&quot;row&quot; :column=&quot;col&quot; :index=&quot;rowIndex&quot; :render=&quot;col.render&quot;&gt;&lt;/Render&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template v-else&gt;&#123;&#123; row[col.key] &#125;&#125;&lt;/template&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Render from &apos;./render.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; Render &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      columns: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default () &#123;</span><br><span class="line">          return [];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default () &#123;</span><br><span class="line">          return [];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果 columns 中的某一列配置了 render 字段，那就通过 render.js 完成自定义模板，否则以字符串形式渲染。比如对出生日期这列显示为标准的日期格式，可以这样定义 column：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// src/views/table-render.vie，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      columns: [</span><br><span class="line">        // ...</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;出生日期&apos;,</span><br><span class="line">          render: (h, &#123; row, column, index &#125;) =&gt; &#123;</span><br><span class="line">            const date = new Date(parseInt(row.birthday));</span><br><span class="line">            const year = date.getFullYear();</span><br><span class="line">            const month = date.getMonth() + 1;</span><br><span class="line">            const day = date.getDate();</span><br><span class="line">            </span><br><span class="line">            const birthday = `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`;</span><br><span class="line">            </span><br><span class="line">            return h(&apos;span&apos;, birthday);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16716c604e151fa0?w=1738&h=418&f=png&s=77318" alt></p><p>需要注意的是，columns 里定义的 render，是有两个参数的，第一个是 createElement（即 h），第二个是从 render.js 传过来的对象，它包含了当前行数据（<code>row</code>）、当前列配置（<code>column</code>）、当前是第几行（<code>index</code>），使用者可以基于这 3 个参数得到任意想要的结果。由于是自定义列了，显示什么都是使用者决定的，因此在使用了 render 的 column 里可以不用写字段 <code>key</code> 。</p><p>如果你真正理解了，应该知道 columns 里定义的 render 字段，它仅仅是名字叫 render 的一个普通函数，并非 Vue.js 实例的 <em>render</em> 选项，只是我们恰巧把它叫做 render 而已，如果愿意，也可以改为其它名字，比如 renderRow。真正的 Render 函数只有一个地方，那就是 render.js 中的 render 选项，只是它代理了 column 中的 render。这里有点绕，理清这个关系，就对 Functional Render 彻底理解了。</p><h2 id="修改当前行"><a href="#修改当前行" class="headerlink" title="修改当前行"></a>修改当前行</h2><p>有了 render，Table 组件就已经完成了，剩余工作都是使用者来配置 columns 完成各种复杂的业务逻辑。本例来介绍最常见的表格中对整行数据编辑的功能。</p><p><strong>操作</strong>这一列，默认是一个<strong>修改</strong>按钮，点击后，变为<strong>保存</strong>和<strong>取消</strong>两个按钮，同时本行其它各列都变为了输入框，并且初始值就是刚才单元格的数据。变为输入框后，可以任意修改单元格数据，点击保存按钮保存整行数据，点击取消按钮，还原至修改前的数据。</p><p>当进入编辑状态时，每一列的输入框都要有一个临时的数据使用 <code>v-model</code> 双向绑定来响应修改，所以在 data 里再声明四个数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// table-render.vue，部分代码省略</span><br><span class="line">&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // ...</span><br><span class="line">      editName: &apos;&apos;,  // 第一列输入框</span><br><span class="line">      editAge: &apos;&apos;,  // 第二列输入框</span><br><span class="line">      editBirthday: &apos;&apos;,  // 第三列输入框</span><br><span class="line">      editAddress: &apos;&apos;,  // 第四列输入框</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还要知道是在修改第几行的数据，所以再加一个数据标识当前正在修改的行序号（从 0 开始）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// table-render.vue，部分代码省略</span><br><span class="line">&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // ...</span><br><span class="line">      editIndex: -1,  // 当前聚焦的输入框的行数</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>editIndex</code> 默认给了 -1，也就是一个不存在的行号，当点击修改按钮时，再将它置为正确的行号。我们先定义操作列的 render：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// table-render.vue，部分代码省略</span><br><span class="line">&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    columns: [</span><br><span class="line">      // ...</span><br><span class="line">      &#123;</span><br><span class="line">        title: &apos;操作&apos;,</span><br><span class="line">        render: (h, &#123; row, index &#125;) =&gt; &#123;</span><br><span class="line">          // 如果当前行是编辑状态，则渲染两个按钮</span><br><span class="line">          if (this.editIndex === index) &#123;</span><br><span class="line">            return [</span><br><span class="line">              h(&apos;button&apos;, &#123;</span><br><span class="line">                on: &#123;</span><br><span class="line">                  click: () =&gt; &#123;</span><br><span class="line">                    this.data[index].name = this.editName;</span><br><span class="line">                    this.data[index].age = this.editAge;</span><br><span class="line">                    this.data[index].birthday = this.editBirthday;</span><br><span class="line">                    this.data[index].address = this.editAddress;</span><br><span class="line">                    this.editIndex = -1;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;, &apos;保存&apos;),</span><br><span class="line">              h(&apos;button&apos;, &#123;</span><br><span class="line">                style: &#123;</span><br><span class="line">                  marginLeft: &apos;6px&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                on: &#123;</span><br><span class="line">                  click: () =&gt; &#123;</span><br><span class="line">                    this.editIndex = -1;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;, &apos;取消&apos;)</span><br><span class="line">            ];</span><br><span class="line">          &#125; else &#123;  // 当前行是默认状态，渲染为一个按钮</span><br><span class="line">            return h(&apos;button&apos;, &#123;</span><br><span class="line">              on: &#123;</span><br><span class="line">                click: () =&gt; &#123;</span><br><span class="line">                  this.editName = row.name;</span><br><span class="line">                  this.editAge = row.age;</span><br><span class="line">                  this.editAddress = row.address;</span><br><span class="line">                  this.editBirthday = row.birthday;</span><br><span class="line">                  this.editIndex = index;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;, &apos;修改&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>render 里的 <code>if / else</code> 可以先看 else，因为默认是非编辑状态，也就是说 <code>editIndex</code> 还是 -1。当点击<strong>修改</strong>按钮时，把 render 中第二个参数 <code>{ row }</code> 中的各列数据赋值给了之前在 data 中声明的 4 个数据，这样做是因为之后点击<strong>取消</strong>按钮时，editName 等值已经修改了，还没有还原，所以在开启编辑状态的同时，初始化各输入框的值（当然也可以在取消时重置）。最后再把 <code>editIndex</code> 置为了对应的行序号 <code>{ index }</code>，此时 render 的 <code>if</code> 条件 <code>this.editIndex === index</code> 为真，编辑列变成了两个按钮：保存和取消。点击保存，直接修改表格源数据 data 中对应的各字段值，并将 editIndex 置为 -1，退出编辑状态；点击取消，不保存源数据，直接退出编辑状态。</p><p>除编辑列，其它各数据列都有两种状态：</p><ol><li>当 editIndex 等于当前行号 index 时，呈现输入框状态；</li><li>当 editIndex 不等于当前行号 index 时，呈现默认数据。</li></ol><p>以姓名为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// table-render.vue，部分代码省略</span><br><span class="line">&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    columns: [</span><br><span class="line">      // ...</span><br><span class="line">      &#123;</span><br><span class="line">        title: &apos;姓名&apos;,</span><br><span class="line">        key: &apos;name&apos;,</span><br><span class="line">        render: (h, &#123; row, index &#125;) =&gt; &#123;</span><br><span class="line">          let edit;</span><br><span class="line"></span><br><span class="line">          // 当前行为聚焦行时</span><br><span class="line">          if (this.editIndex === index) &#123;</span><br><span class="line">            edit = [h(&apos;input&apos;, &#123;</span><br><span class="line">              domProps: &#123;</span><br><span class="line">                value: row.name</span><br><span class="line">              &#125;,</span><br><span class="line">              on: &#123;</span><br><span class="line">                input: (event) =&gt; &#123;</span><br><span class="line">                  this.editName = event.target.value;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)];</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            edit = row.name;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return h(&apos;div&apos;, [</span><br><span class="line">            edit</span><br><span class="line">          ]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量 <code>edit</code> 根据 editIndex 呈现不同的节点，还是先看 else，直接显示了对应字段的数据。在聚焦时（this.editIndex === index），渲染一个 <code>input</code> 输入框，初始值 <code>value</code> 通过 render 的 <code>domProps</code> 绑定了 <code>row.name</code>（这里也可绑定 editName），并监听了 input 事件，将输入的内容，实时缓存在数据 <code>editName</code> 中，供保存时使用。事实上，这里绑定的 value 和事件 input 就是语法糖 <code>v-model</code> 在 Render 函数中的写法，在 template 中，经常写作 <code>&lt;input v-model=&quot;editName&quot;&gt;</code>。</p><p>其它列与姓名类似，只是对于的字段不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">// table-render.vue，部分代码省略</span><br><span class="line">&#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      columns: [</span><br><span class="line">        // ...</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;年龄&apos;,</span><br><span class="line">          key: &apos;age&apos;,</span><br><span class="line">          render: (h, &#123; row, index &#125;) =&gt; &#123;</span><br><span class="line">            let edit;</span><br><span class="line"></span><br><span class="line">            // 当前行为聚焦行时</span><br><span class="line">            if (this.editIndex === index) &#123;</span><br><span class="line">              edit = [h(&apos;input&apos;, &#123;</span><br><span class="line">                domProps: &#123;</span><br><span class="line">                  value: row.age</span><br><span class="line">                &#125;,</span><br><span class="line">                on: &#123;</span><br><span class="line">                  input: (event) =&gt; &#123;</span><br><span class="line">                    this.editAge = event.target.value;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              edit = row.age;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return h(&apos;div&apos;, [</span><br><span class="line">              edit</span><br><span class="line">            ]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;出生日期&apos;,</span><br><span class="line">          render: (h, &#123; row, index &#125;) =&gt; &#123;</span><br><span class="line">            let edit;</span><br><span class="line"></span><br><span class="line">            // 当前行为聚焦行时</span><br><span class="line">            if (this.editIndex === index) &#123;</span><br><span class="line">              edit = [h(&apos;input&apos;, &#123;</span><br><span class="line">                domProps: &#123;</span><br><span class="line">                  value: row.birthday</span><br><span class="line">                &#125;,</span><br><span class="line">                on: &#123;</span><br><span class="line">                  input: (event) =&gt; &#123;</span><br><span class="line">                    this.editBirthday = event.target.value;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              const date = new Date(parseInt(row.birthday));</span><br><span class="line">              const year = date.getFullYear();</span><br><span class="line">              const month = date.getMonth() + 1;</span><br><span class="line">              const day = date.getDate();</span><br><span class="line"></span><br><span class="line">              edit = `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return h(&apos;div&apos;, [</span><br><span class="line">              edit</span><br><span class="line">            ]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          title: &apos;地址&apos;,</span><br><span class="line">          key: &apos;address&apos;,</span><br><span class="line">          render: (h, &#123; row, index &#125;) =&gt; &#123;</span><br><span class="line">            let edit;</span><br><span class="line"></span><br><span class="line">            // 当前行为聚焦行时</span><br><span class="line">            if (this.editIndex === index) &#123;</span><br><span class="line">              edit = [h(&apos;input&apos;, &#123;</span><br><span class="line">                domProps: &#123;</span><br><span class="line">                  value: row.address</span><br><span class="line">                &#125;,</span><br><span class="line">                on: &#123;</span><br><span class="line">                  input: (event) =&gt; &#123;</span><br><span class="line">                    this.editAddress = event.target.value;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              edit = row.address;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return h(&apos;div&apos;, [</span><br><span class="line">              edit</span><br><span class="line">            ]);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完整的代码见：<a href="https://github.com/icarusion/vue-component-book/blob/master/src/views/table-render.vue" target="_blank" rel="noopener">https://github.com/icarusion/vue-component-book/blob/master/src/views/table-render.vue</a></p></blockquote><p>这样，可编辑行的表格示例就完成了：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/15/16716c54fc74a1a5?w=2088&h=456&f=gif&s=520544" alt></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本示例的 Table 组件，只展现了表格最核心的功能——自定义列模板，一个完整的 Table 组件功能要复杂的多，比如排序、筛选、列固定、表头固定、表头嵌套等。万事开头难，打好了 Table 的地基，后面的功能可以持续开发。</p><p>事实上，很多 Vue.js 的开发难题，都可以用 Render 函数来解决，它比 template 模板更灵活，可以完全发挥 JavaScript 的编程能力，因此很多 JS 的开发思想都可以借鉴。如果你习惯 JSX，那完全可以抛弃传统的 template 写法。</p><p>Render 函数虽好，但也是有弊端的，通过上面的示例可以发现，写出来的 VNode 对象是很难读的，维护性也比 template 差。下一节，我们将改写 Table 组件，用另一种思想来实现同样的功能。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.cnblogs.com/lovebear/archive/2012/04/18/2456081.html" target="_blank" rel="noopener">Div 和 Table 的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slot-scope 自定义列的表格组件</title>
      <link href="/2018/09/07/%E5%AE%9E%E6%88%98%206%EF%BC%9A%E5%8F%AF%E7%94%A8%20slot-scope%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E7%9A%84%E8%A1%A8%E6%A0%BC%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Table/"/>
      <url>/2018/09/07/%E5%AE%9E%E6%88%98%206%EF%BC%9A%E5%8F%AF%E7%94%A8%20slot-scope%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%97%E7%9A%84%E8%A1%A8%E6%A0%BC%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Table/</url>
      
        <content type="html"><![CDATA[<h1 id="实战-6：可用-slot-scope-自定义列的表格组件——Table"><a href="#实战-6：可用-slot-scope-自定义列的表格组件——Table" class="headerlink" title="实战 6：可用 slot-scope 自定义列的表格组件——Table"></a>实战 6：可用 slot-scope 自定义列的表格组件——Table</h1><p>上一节，我们基于 Render 函数实现了在表格中自定义列模板的组件 Table，虽说 Render 函数能够完全发挥 JavaScript 的编程能力，实现几乎所有的自定义工作，但本质上，使用者写的是一个庞大的 JS 对象，它不具备 DOM 结构，可读性和可维护性都比较差。对于大部分写 Vue.js 的开发者来说，更倾向于使用 template 的语法，毕竟它是 Vue.js 独有的特性。本小节则在上一节的 Table 组件基础上修改，实现一种达到同样渲染效果，但对使用者更友好的 slot-scope 写法。</p><h2 id="什么是-slot-scope"><a href="#什么是-slot-scope" class="headerlink" title="什么是 slot-scope"></a>什么是 slot-scope</h2><p>slot（插槽）我们都很熟悉，它是 Vue.js 组件的 3 个 API 之一，用于分发内容。那 slot-scope 是什么呢？先来看一个场景，比如某组件拥有下面的模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;book in books&quot; :key=&quot;book.id&quot;&gt;</span><br><span class="line">    &#123;&#123; book.name &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>使用者传递一个数组 <code>books</code>，由组件内的 <code>v-for</code> 循环显示，这里的 <code></code> 是纯文本输出，如果想自定义它的模板（即内容分发），就要用到 slot，但 slot 只能是固定的模板，没法自定义循环体中的一个具体的项，事实上这跟上一节的 Table 场景是类似的。</p><p>常规的 slot 无法实现对组件循环体的每一项进行不同的内容分发，这就要用到 slot-scope，它本质上跟 slot 一样，只不过可以传递参数。比如上面的示例，使用 slot-scope 封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;book in books&quot; :key=&quot;book.id&quot;&gt;</span><br><span class="line">    &lt;slot :book=&quot;book&quot;&gt;</span><br><span class="line">      &lt;!-- 默认内容 --&gt;</span><br><span class="line">      &#123;&#123; book.name &#125;&#125;</span><br><span class="line">    &lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>在 slot 上，传递了一个自定义的参数 <code>book</code>，它的值绑定的是当前循环项的数据 book，这样在父级使用时，就可以在 slot 中访问它了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;book-list :books=&quot;books&quot;&gt;</span><br><span class="line">  &lt;template slot-scope=&quot;slotProps&quot;&gt;</span><br><span class="line">    &lt;span v-if=&quot;slotProps.book.sale&quot;&gt;限时优惠&lt;/span&gt;</span><br><span class="line">    &#123;&#123; slotProps.book.name &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/book-list&gt;</span><br></pre></td></tr></table></figure><p>使用 slot-scope 指定的参数 <code>slotProps</code> 就是这个 slot 的全部参数，它是一个对象，在 slot-scope 中是可以传递多个参数的，上例我们只写了一个参数 <code>book</code>，所以访问它就是 <code>slotProps.book</code>。这里推荐使用 ES6 的解构，能让参数使用起来更方便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;book-list :books=&quot;books&quot;&gt;</span><br><span class="line">  &lt;template slot-scope=&quot;&#123; book &#125;&quot;&gt;</span><br><span class="line">    &lt;span v-if=&quot;book.sale&quot;&gt;限时优惠&lt;/span&gt;</span><br><span class="line">    &#123;&#123; book.name &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/book-list&gt;</span><br></pre></td></tr></table></figure><p>除了可以传递参数，其它用法跟 slot 是一样的，比如也可以“具名”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;slot :book=&quot;book&quot; name=&quot;book&quot;&gt;</span><br><span class="line">  &#123;&#123; book.name &#125;&#125;</span><br><span class="line">&lt;/slot&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template slot-scope=&quot;&#123; book &#125;&quot; slot=&quot;book&quot;&gt;</span><br><span class="line">  &lt;span v-if=&quot;book.sale&quot;&gt;限时优惠&lt;/span&gt;</span><br><span class="line">  &#123;&#123; book.name &#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>这就是作用域 slot（slot-scope），能够在组件的循环体中做内容分发，有了它，Table 组件的自定义列模板就不用写一长串的 Render 函数了。</p><p>为了把 Render 函数和 slot-scope 理解透彻，下面我们用 3 种方法来改写 Table，实现 slot-scope 自定义列模板。</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>第一种方案，用最简单的 slot-scope 实现，同时也兼容 Render 函数的旧用法。拷贝上一节的 Table 组件目录，更名为 <code>table-slot</code>，同时也拷贝路由，更名为 <code>table-slot.vue</code>。为了兼容旧的 Render 函数用法，在 columns 的列配置 column 中，新增一个字段 <code>slot</code> 来指定 slot-scope 的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/table-slot/table.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th v-for=&quot;col in columns&quot;&gt;&#123;&#123; col.title &#125;&#125;&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">      &lt;tr v-for=&quot;(row, rowIndex) in data&quot;&gt;</span><br><span class="line">        &lt;td v-for=&quot;col in columns&quot;&gt;</span><br><span class="line">          &lt;template v-if=&quot;&apos;render&apos; in col&quot;&gt;</span><br><span class="line">            &lt;Render :row=&quot;row&quot; :column=&quot;col&quot; :index=&quot;rowIndex&quot; :render=&quot;col.render&quot;&gt;&lt;/Render&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template v-else-if=&quot;&apos;slot&apos; in col&quot;&gt;</span><br><span class="line">            &lt;slot :row=&quot;row&quot; :column=&quot;col&quot; :index=&quot;rowIndex&quot; :name=&quot;col.slot&quot;&gt;&lt;/slot&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template v-else&gt;&#123;&#123; row[col.key] &#125;&#125;&lt;/template&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>相比原先的文件，只在 <code>&#39;render&#39; in col</code> 的条件下新加了一个 <code>template</code> 的标签，如果使用者的 column 配置了 render 字段，就优先以 Render 函数渲染，然后再判断是否用 slot-scope 渲染。在定义的作用域 slot 中，将行数据 <code>row</code>、列数据 <code>column</code> 和第几行 <code>index</code> 作为 slot 的参数，并根据 column 中指定的 slot 字段值，动态设置了具名 <code>name</code>。使用者在配置 columns 时，只要指定了某一列的 slot，那就可以在 Table 组件中使用 slot-scope。我们以上一节的可编辑整行数据为例，用 slot-scope 的写法实现完全一样的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/views/table-slot.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;table-slot :columns=&quot;columns&quot; :data=&quot;data&quot;&gt;</span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;name&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;editName&quot; v-if=&quot;editIndex === index&quot; /&gt;</span><br><span class="line">        &lt;span v-else&gt;&#123;&#123; row.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;age&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;editAge&quot; v-if=&quot;editIndex === index&quot; /&gt;</span><br><span class="line">        &lt;span v-else&gt;&#123;&#123; row.age &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;birthday&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;editBirthday&quot; v-if=&quot;editIndex === index&quot; /&gt;</span><br><span class="line">        &lt;span v-else&gt;&#123;&#123; getBirthday(row.birthday) &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;address&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;editAddress&quot; v-if=&quot;editIndex === index&quot; /&gt;</span><br><span class="line">        &lt;span v-else&gt;&#123;&#123; row.address &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;action&quot;&gt;</span><br><span class="line">        &lt;div v-if=&quot;editIndex === index&quot;&gt;</span><br><span class="line">          &lt;button @click=&quot;handleSave(index)&quot;&gt;保存&lt;/button&gt;</span><br><span class="line">          &lt;button @click=&quot;editIndex = -1&quot;&gt;取消&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div v-else&gt;</span><br><span class="line">          &lt;button @click=&quot;handleEdit(row, index)&quot;&gt;操作&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/table-slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import TableSlot from &apos;../components/table-slot/table.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; TableSlot &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        columns: [</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;姓名&apos;,</span><br><span class="line">            slot: &apos;name&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;年龄&apos;,</span><br><span class="line">            slot: &apos;age&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;出生日期&apos;,</span><br><span class="line">            slot: &apos;birthday&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;地址&apos;,</span><br><span class="line">            slot: &apos;address&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;操作&apos;,</span><br><span class="line">            slot: &apos;action&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        data: [</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;王小明&apos;,</span><br><span class="line">            age: 18,</span><br><span class="line">            birthday: &apos;919526400000&apos;,</span><br><span class="line">            address: &apos;北京市朝阳区芍药居&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;张小刚&apos;,</span><br><span class="line">            age: 25,</span><br><span class="line">            birthday: &apos;696096000000&apos;,</span><br><span class="line">            address: &apos;北京市海淀区西二旗&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;李小红&apos;,</span><br><span class="line">            age: 30,</span><br><span class="line">            birthday: &apos;563472000000&apos;,</span><br><span class="line">            address: &apos;上海市浦东新区世纪大道&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            name: &apos;周小伟&apos;,</span><br><span class="line">            age: 26,</span><br><span class="line">            birthday: &apos;687024000000&apos;,</span><br><span class="line">            address: &apos;深圳市南山区深南大道&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        editIndex: -1,  // 当前聚焦的输入框的行数</span><br><span class="line">        editName: &apos;&apos;,  // 第一列输入框，当然聚焦的输入框的输入内容，与 data 分离避免重构的闪烁</span><br><span class="line">        editAge: &apos;&apos;,  // 第二列输入框</span><br><span class="line">        editBirthday: &apos;&apos;,  // 第三列输入框</span><br><span class="line">        editAddress: &apos;&apos;,  // 第四列输入框</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleEdit (row, index) &#123;</span><br><span class="line">        this.editName = row.name;</span><br><span class="line">        this.editAge = row.age;</span><br><span class="line">        this.editAddress = row.address;</span><br><span class="line">        this.editBirthday = row.birthday;</span><br><span class="line">        this.editIndex = index;</span><br><span class="line">      &#125;,</span><br><span class="line">      handleSave (index) &#123;</span><br><span class="line">        this.data[index].name = this.editName;</span><br><span class="line">        this.data[index].age = this.editAge;</span><br><span class="line">        this.data[index].birthday = this.editBirthday;</span><br><span class="line">        this.data[index].address = this.editAddress;</span><br><span class="line">        this.editIndex = -1;</span><br><span class="line">      &#125;,</span><br><span class="line">      getBirthday (birthday) &#123;</span><br><span class="line">        const date = new Date(parseInt(birthday));</span><br><span class="line">        const year = date.getFullYear();</span><br><span class="line">        const month = date.getMonth() + 1;</span><br><span class="line">        const day = date.getDate();</span><br><span class="line"></span><br><span class="line">        return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>示例中在 <code>&lt;table-slot&gt;</code> 内的每一个 <code>&lt;template&gt;</code> 就对应某一列的 slot-scope 模板，通过配置的 <code>slot</code> 字段，指定具名的 slot-scope。可以看到，基本是把 Render 函数还原成了 html 的写法，这样看起来直接多了，渲染效果是完全一样的。在 slot-scope 中，平时怎么写组件，这里就怎么写，Vue.js 所有的 API 都是可以直接使用的。</p><p>方案一是最优解，一般情况下，使用这种方案就可以了，其余两种方案是基于 Render 的。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>第二种方案，不需要修改原先的 Table 组件代码，只是在使用层面修改即可。先来看具体的使用代码，然后再做分析。注意，这里使用的 Table 组件，仍然是上一节 <code>src/components/table-render</code> 的组件，它只有 Render 函数，没有定义 slot-scope：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/views/table-render.vue 的改写 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;table-render ref=&quot;table&quot; :columns=&quot;columns&quot; :data=&quot;data&quot;&gt;</span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;name&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;editName&quot; v-if=&quot;editIndex === index&quot; /&gt;</span><br><span class="line">        &lt;span v-else&gt;&#123;&#123; row.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;age&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;editAge&quot; v-if=&quot;editIndex === index&quot; /&gt;</span><br><span class="line">        &lt;span v-else&gt;&#123;&#123; row.age &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;birthday&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;editBirthday&quot; v-if=&quot;editIndex === index&quot; /&gt;</span><br><span class="line">        &lt;span v-else&gt;&#123;&#123; getBirthday(row.birthday) &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;address&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;editAddress&quot; v-if=&quot;editIndex === index&quot; /&gt;</span><br><span class="line">        &lt;span v-else&gt;&#123;&#123; row.address &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;template slot-scope=&quot;&#123; row, index &#125;&quot; slot=&quot;action&quot;&gt;</span><br><span class="line">        &lt;div v-if=&quot;editIndex === index&quot;&gt;</span><br><span class="line">          &lt;button @click=&quot;handleSave(index)&quot;&gt;保存&lt;/button&gt;</span><br><span class="line">          &lt;button @click=&quot;editIndex = -1&quot;&gt;取消&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div v-else&gt;</span><br><span class="line">          &lt;button @click=&quot;handleEdit(row, index)&quot;&gt;操作&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/table-render&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import TableRender from &apos;../components/table-render/table.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; TableRender &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        columns: [</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;姓名&apos;,</span><br><span class="line">            render: (h, &#123; row, column, index &#125;) =&gt; &#123;</span><br><span class="line">              return h(</span><br><span class="line">                &apos;div&apos;,</span><br><span class="line">                this.$refs.table.$scopedSlots.name(&#123;</span><br><span class="line">                  row: row,</span><br><span class="line">                  column: column,</span><br><span class="line">                  index: index</span><br><span class="line">                &#125;)</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;年龄&apos;,</span><br><span class="line">            render: (h, &#123; row, column, index &#125;) =&gt; &#123;</span><br><span class="line">              return h(</span><br><span class="line">                &apos;div&apos;,</span><br><span class="line">                this.$refs.table.$scopedSlots.age(&#123;</span><br><span class="line">                  row: row,</span><br><span class="line">                  column: column,</span><br><span class="line">                  index: index</span><br><span class="line">                &#125;)</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;出生日期&apos;,</span><br><span class="line">            render: (h, &#123; row, column, index &#125;) =&gt; &#123;</span><br><span class="line">              return h(</span><br><span class="line">                &apos;div&apos;,</span><br><span class="line">                this.$refs.table.$scopedSlots.birthday(&#123;</span><br><span class="line">                  row: row,</span><br><span class="line">                  column: column,</span><br><span class="line">                  index: index</span><br><span class="line">                &#125;)</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;地址&apos;,</span><br><span class="line">            render: (h, &#123; row, column, index &#125;) =&gt; &#123;</span><br><span class="line">              return h(</span><br><span class="line">                &apos;div&apos;,</span><br><span class="line">                this.$refs.table.$scopedSlots.address(&#123;</span><br><span class="line">                  row: row,</span><br><span class="line">                  column: column,</span><br><span class="line">                  index: index</span><br><span class="line">                &#125;)</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;操作&apos;,</span><br><span class="line">            render: (h, &#123; row, column, index &#125;) =&gt; &#123;</span><br><span class="line">              return h(</span><br><span class="line">                &apos;div&apos;,</span><br><span class="line">                this.$refs.table.$scopedSlots.action(&#123;</span><br><span class="line">                  row: row,</span><br><span class="line">                  column: column,</span><br><span class="line">                  index: index</span><br><span class="line">                &#125;)</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        data: [],</span><br><span class="line">        editIndex: -1,  // 当前聚焦的输入框的行数</span><br><span class="line">        editName: &apos;&apos;,  // 第一列输入框，当然聚焦的输入框的输入内容，与 data 分离避免重构的闪烁</span><br><span class="line">        editAge: &apos;&apos;,  // 第二列输入框</span><br><span class="line">        editBirthday: &apos;&apos;,  // 第三列输入框</span><br><span class="line">        editAddress: &apos;&apos;,  // 第四列输入框</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleEdit (row, index) &#123;</span><br><span class="line">        this.editName = row.name;</span><br><span class="line">        this.editAge = row.age;</span><br><span class="line">        this.editAddress = row.address;</span><br><span class="line">        this.editBirthday = row.birthday;</span><br><span class="line">        this.editIndex = index;</span><br><span class="line">      &#125;,</span><br><span class="line">      handleSave (index) &#123;</span><br><span class="line">        this.data[index].name = this.editName;</span><br><span class="line">        this.data[index].age = this.editAge;</span><br><span class="line">        this.data[index].birthday = this.editBirthday;</span><br><span class="line">        this.data[index].address = this.editAddress;</span><br><span class="line">        this.editIndex = -1;</span><br><span class="line">      &#125;,</span><br><span class="line">      getBirthday (birthday) &#123;</span><br><span class="line">        const date = new Date(parseInt(birthday));</span><br><span class="line">        const year = date.getFullYear();</span><br><span class="line">        const month = date.getMonth() + 1;</span><br><span class="line">        const day = date.getDate();</span><br><span class="line"></span><br><span class="line">        return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      this.data = [</span><br><span class="line">        &#123;</span><br><span class="line">          name: &apos;王小明&apos;,</span><br><span class="line">          age: 18,</span><br><span class="line">          birthday: &apos;919526400000&apos;,</span><br><span class="line">          address: &apos;北京市朝阳区芍药居&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: &apos;张小刚&apos;,</span><br><span class="line">          age: 25,</span><br><span class="line">          birthday: &apos;696096000000&apos;,</span><br><span class="line">          address: &apos;北京市海淀区西二旗&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: &apos;李小红&apos;,</span><br><span class="line">          age: 30,</span><br><span class="line">          birthday: &apos;563472000000&apos;,</span><br><span class="line">          address: &apos;上海市浦东新区世纪大道&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: &apos;周小伟&apos;,</span><br><span class="line">          age: 26,</span><br><span class="line">          birthday: &apos;687024000000&apos;,</span><br><span class="line">          address: &apos;深圳市南山区深南大道&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      ];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在 slot-scope 的使用上（即 template 的内容），与方案一是完全一致的，可以看到，在 column 的定义上，仍然使用了 render 字段，只不过每个 render 都渲染了一个 div 节点，而这个 div 的内容，是指定来在 <code>&lt;table-render&gt;</code> 中定义的 slot-scope：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render: (h, &#123; row, column, index &#125;) =&gt; &#123;</span><br><span class="line">  return h(</span><br><span class="line">    &apos;div&apos;,</span><br><span class="line">    this.$refs.table.$scopedSlots.name(&#123;</span><br><span class="line">      row: row,</span><br><span class="line">      column: column,</span><br><span class="line">      index: index</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这正是 Render 函数灵活的一个体现，使用 <code>$scopedSlots</code> 可以访问 slot-scope，所以上面这段代码的意思是，name 这一列仍然是使用 Functional Render，只不过 Render 的是一个预先定义好的 slot-scope 模板。</p><p>有一点需要注意的是，示例中的 <code>data</code> 默认是空数组，而在 mounted 里才赋值的，是因为这样定义的 slot-scope，初始时读取 <code>this.$refs.table.$scopedSlots</code> 是读不到的，会报错，当没有数据时，也就不会去渲染，也就避免了报错。</p><p>这种方案虽然可行，但归根到底是一种 hack，不是非常推荐，之所以列出来，是为了对 Render 和 slot-scope 有进一步的认识。</p><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>第 3 中方案的思路和第 2 种是一样的，它介于方案 1 与方案 2 之间。这种方案要修改 Table 组件代码，但是用例与方案 1 完全一致。</p><p>在方案 2 中，我们是通过修改用例使用 slot-scope 的，也就是说 Table 组件本身没有支持 slot-scope，是我们“强加”上去的，如果把强加的部分，集成到 Table 内，那对使用者就很友好了，同时也避免了初始化报错，不得不把 data 写在 mounted 的问题。</p><p>保持方案 1 的用例不变，修改 <code>src/components/table-render</code> 中的代码。为了同时兼容 Render 与 slot-scope，我们在 <code>table-render</code> 下新建一个 slot.js 的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// src/components/table-render/slot.js</span><br><span class="line">export default &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  inject: [&apos;tableRoot&apos;],</span><br><span class="line">  props: &#123;</span><br><span class="line">    row: Object,</span><br><span class="line">    column: Object,</span><br><span class="line">    index: Number</span><br><span class="line">  &#125;,</span><br><span class="line">  render: (h, ctx) =&gt; &#123;</span><br><span class="line">    return h(&apos;div&apos;, ctx.injections.tableRoot.$scopedSlots[ctx.props.column.slot](&#123;</span><br><span class="line">      row: ctx.props.row,</span><br><span class="line">      column: ctx.props.column,</span><br><span class="line">      index: ctx.props.index</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它仍然是一个 Functional Render，使用 <code>inject</code> 注入了父级组件 table.vue（下文改写） 中提供的实例 <code>tableRoot</code>。在 render 里，也是通过方案 2 中使用 <code>$scopedSlots</code> 定义的 slot，不过这是在组件级别定义，对用户来说是透明的，只要按方案 1 的用例来写就可以了。</p><p>table.vue 也要做一点修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/table-slot/table.vue 的改写，部分代码省略 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;table&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th v-for=&quot;col in columns&quot;&gt;&#123;&#123; col.title &#125;&#125;&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">      &lt;tr v-for=&quot;(row, rowIndex) in data&quot;&gt;</span><br><span class="line">        &lt;td v-for=&quot;col in columns&quot;&gt;</span><br><span class="line">          &lt;template v-if=&quot;&apos;render&apos; in col&quot;&gt;</span><br><span class="line">            &lt;Render :row=&quot;row&quot; :column=&quot;col&quot; :index=&quot;rowIndex&quot; :render=&quot;col.render&quot;&gt;&lt;/Render&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template v-else-if=&quot;&apos;slot&apos; in col&quot;&gt;</span><br><span class="line">            &lt;slot-scope :row=&quot;row&quot; :column=&quot;col&quot; :index=&quot;rowIndex&quot;&gt;&lt;/slot-scope&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template v-else&gt;&#123;&#123; row[col.key] &#125;&#125;&lt;/template&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Render from &apos;./render.js&apos;;</span><br><span class="line">  import SlotScope from &apos;./slot.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; Render, SlotScope &#125;,</span><br><span class="line">    provide () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        tableRoot: this</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      columns: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default () &#123;</span><br><span class="line">          return [];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default () &#123;</span><br><span class="line">          return [];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>因为 slot-scope 模板是写在 table.vue 中的（对使用者来说，相当于写在组件 <code>&lt;table-slot&gt;&lt;/table-slot&gt;</code> 之间），所以在 table.vue 中使用 provide 向下提供了 Table 的实例，这样在 slot.js 中就可以通过 inject 访问到它，继而通过 <code>$scopedSlots</code> 获取到 slot。需要注意的是，在 Functional Render 是没有 this 上下文的，都是通过 h 的第二个参数临时上下文 ctx 来访问 prop、inject 等的。</p><p>方案 3 也是推荐使用的，当 Table 的功能足够复杂，层级会嵌套的比较深，那时方案 1 的 slot 就不会定义在第一级组件中，中间可能会隔许多组件，slot 就要一层层中转，相比在任何地方都能直接使用的 Render 就要麻烦了。所以，如果你的组件层级简单，推荐用第一种方案；如果你的组件已经成型（某 API 基于 Render 函数），但一时间不方便支持 slot-scope，而使用者又想用，那就选方案 2；如果你的组件已经成型（某 API 基于 Render 函数），但组件层级复杂，要按方案 1 那样支持 slot-scope 可能改动较大，还有可能带来新的 bug，那就用方案 3，它不会破坏原有的任何内容，但会额外支持 slot-scope 用法，关键是改动简单。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>理论上，绝大多数能用 Render 的地方，都可以用 slot-scope。对于极客来说，喜欢挑战各种新奇的写法，所以会在 Vue.js 中大量使用 Render 函数、JSX 甚至 TS；而对于求稳的开发者来说，常规的 template、slot、slot-scope 写法会是好的选择。如果非要选一种，那要从你团队的整体情况来定，如果团队大部分是写后端为主的，那可能更倾向于 TS；如果写过 React，或许 JSX 是不错的选择；如果实在不知道选什么，那就求稳吧！</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全局提示组件</title>
      <link href="/2018/09/07/%E5%AE%9E%E6%88%98%204%EF%BC%9A%E5%85%A8%E5%B1%80%E6%8F%90%E7%A4%BA%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94$Alert/"/>
      <url>/2018/09/07/%E5%AE%9E%E6%88%98%204%EF%BC%9A%E5%85%A8%E5%B1%80%E6%8F%90%E7%A4%BA%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94$Alert/</url>
      
        <content type="html"><![CDATA[<h1 id="实战-4：全局提示组件——-Alert"><a href="#实战-4：全局提示组件——-Alert" class="headerlink" title="实战 4：全局提示组件——$Alert"></a>实战 4：全局提示组件——$Alert</h1><p>有一种 Vue.js 组件，它不同于常规的组件，但组件结构本身很简单，比如下面的全局提示组件：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fcc05107e987c?w=3187&h=2087&f=png&s=265274" alt></p><p>实现这样一个组件并不难，只需要简单的几行 div 和 css，但使用者可能要这样来显示组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Alert v-if=&quot;show&quot;&gt;这是一条提示信息&lt;/Alert&gt;</span><br><span class="line">    &lt;button @click=&quot;show = true&quot;&gt;显示&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Alert from &apos;../component/alert.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; Alert &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        show: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样的用法，有以下缺点：</p><ul><li>每个使用的地方，都得注册组件；</li><li>需要预先将 <code>&lt;Alert&gt;</code> 放置在模板中；</li><li>需要额外的 data 来控制 Alert 的显示状态；</li><li>Alert 的位置，是在当前组件位置，并非在 body 下，有可能会被其它组件遮挡。</li></ul><p>总之对使用者来说是很不友好的，那怎样才能优雅地实现这样一个组件呢？事实上，原生的 JavaScript 早已给出了答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全局提示</span><br><span class="line">window.alert(&apos;这是一条提示信息&apos;);</span><br><span class="line">// 二次确认</span><br><span class="line">const confirm = window.confirm(&apos;确认删除吗？&apos;);</span><br><span class="line">if (confirm) &#123;</span><br><span class="line">  // ok</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // cancel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，结论是：我们需要一个能用 JavaScript 调用组件的 API。</p><p>如果你使用过 iView 之类的组件库，一定对它内置的 $Message、$Notice、$Modal 等组件很熟悉，本节就来开发一个全局通知组件——$Alert。</p><h2 id="1-3-先把组件写好"><a href="#1-3-先把组件写好" class="headerlink" title="1/3 先把组件写好"></a>1/3 先把组件写好</h2><p>我们期望最终的 API 是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  handleShow () &#123;</span><br><span class="line">    this.$Alert(&#123;</span><br><span class="line">      content: &apos;这是一条提示信息&apos;,</span><br><span class="line">      duration: 3</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.$Alert</code> 可以在任何位置调用，无需单独引入。该方法接收两个参数：</p><ul><li>content：提示内容；</li><li>duration：持续时间，单位秒，默认 1.5 秒，到时间自动消失。</li></ul><p>最终效果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fcc09c43c2ad1?w=1208&h=314&f=gif&s=207241" alt></p><p>我们从最简单的入手，不考虑其它，先写一个基本的 Alert 组件。</p><p>在 <code>src/component</code> 下新建 <code>alert</code> 目录，并创建文件 <code>alert.vue</code>：</p><p>通知可以是多个，我们用一个数组 <code>notices</code> 来管理每条通知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- alert.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;alert&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;alert-main&quot; v-for=&quot;item in notices&quot; :key=&quot;item.name&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;alert-content&quot;&gt;&#123;&#123; item.content &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        notices: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .alert&#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    width: 100%;</span><br><span class="line">    top: 16px;</span><br><span class="line">    left: 0;</span><br><span class="line">    text-align: center;</span><br><span class="line">    pointer-events: none;</span><br><span class="line">  &#125;</span><br><span class="line">  .alert-content&#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">    padding: 8px 16px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    box-shadow: 0 1px 6px rgba(0, 0, 0, .2);</span><br><span class="line">    margin-bottom: 8px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>Alert 组件不同于常规的组件使用方式，它最终是通过 JS 来调用的，因此组件不用预留 props 和 events 接口。</p><p>接下来，只要给数组 <code>notices</code> 增加数据，这个提示组件就能显示内容了，我们先假设，最终会通过 JS 调用 Alert 的一个方法 <code>add</code>，并将 <code>content</code> 和 <code>duration</code> 传入进来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- alert.vue，部分代码省略 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let seed = 0;</span><br><span class="line"></span><br><span class="line">  function getUuid() &#123;</span><br><span class="line">    return &apos;alert_&apos; + (seed++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        notices: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      add (notice) &#123;</span><br><span class="line">        const name = getUuid();</span><br><span class="line"></span><br><span class="line">        let _notice = Object.assign(&#123;</span><br><span class="line">          name: name</span><br><span class="line">        &#125;, notice);</span><br><span class="line"></span><br><span class="line">        this.notices.push(_notice);</span><br><span class="line"></span><br><span class="line">        // 定时移除，单位：秒</span><br><span class="line">        const duration = notice.duration;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          this.remove(name);</span><br><span class="line">        &#125;, duration * 1000);</span><br><span class="line">      &#125;,</span><br><span class="line">      remove (name) &#123;</span><br><span class="line">        const notices = this.notices;</span><br><span class="line"></span><br><span class="line">        for (let i = 0; i &lt; notices.length; i++) &#123;</span><br><span class="line">          if (notices[i].name === name) &#123;</span><br><span class="line">            this.notices.splice(i, 1);</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在 <code>add</code> 方法中，给每一条传进来的提示数据，加了一个不重复的 <code>name</code> 字段来标识，并通过 <code>setTimeout</code> 创建了一个计时器，当到达指定的 <code>duration</code> 持续时间后，调用 <code>remove</code> 方法，将对应 <code>name</code> 的那条提示信息找到，并从数组中移除。</p><p>由这个思路，Alert 组件就可以无限扩展，只要在 add 方法中传递更多的参数，就能支持更复杂的组件，比如是否显示手动关闭按钮、确定 / 取消按钮，甚至传入一个 Render 函数都可以，完成本例后，读者可以尝试”改造“。</p><h2 id="2-3-实例化封装"><a href="#2-3-实例化封装" class="headerlink" title="2/3 实例化封装"></a>2/3 实例化封装</h2><p>这一步，我们对 Alert 组件进一步封装，让它能够实例化，而不是常规的组件使用方法。实例化组件我们在第 8 节中介绍过，可以使用 Vue.extend 或 new Vue，然后用 $mount 挂载到 body 节点下。</p><p>在 <code>src/components/alert</code> 目录下新建 <code>notification.js</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// notification.js</span><br><span class="line">import Alert from &apos;./alert.vue&apos;;</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">Alert.newInstance = properties =&gt; &#123;</span><br><span class="line">  const props = properties || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  const Instance = new Vue(&#123;</span><br><span class="line">    data: props,</span><br><span class="line">    render (h) &#123;</span><br><span class="line">      return h(Alert, &#123;</span><br><span class="line">        props: props</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const component = Instance.$mount();</span><br><span class="line">  document.body.appendChild(component.$el);</span><br><span class="line"></span><br><span class="line">  const alert = Instance.$children[0];</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    add (noticeProps) &#123;</span><br><span class="line">      alert.add(noticeProps);</span><br><span class="line">    &#125;,</span><br><span class="line">    remove (name) &#123;</span><br><span class="line">      alert.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Alert;</span><br></pre></td></tr></table></figure><p>notification.js 并不是最终的文件，它只是对 alert.vue 添加了一个方法 <code>newInstance</code>。虽然 alert.vue 包含了 template、script、style 三个标签，并不是一个 JS 对象，那怎么能够给它扩展一个方法 <code>newInstance</code> 呢？事实上，alert.vue 会被 Webpack 的 vue-loader 编译，把 template 编译为 Render 函数，最终就会成为一个 JS 对象，自然可以对它进行扩展。</p><p>Alert 组件没有任何 props，这里在 Render Alert 组件时，还是给它加了 props，当然，这里的 props 是空对象 {}，而且即使传了内容，也不起作用。这样做的目的还是为了扩展性，如果要在 Alert 上添加 props 来支持更多特性，是要在这里传入的。不过话说回来，因为能拿到 Alert 实例，用 data 或 props 都是可以的。</p><p>在第 8 节已经解释过，<code>const alert = Instance.$children[0];</code>，这里的 alert 就是 Render 的 Alert 组件实例。在 <code>newInstance</code> 里，使用闭包暴露了两个方法 <code>add</code> 和 <code>remove</code>。这里的 add 和 remove 可不是 alert.vue 里的 add 和 remove，它们只是名字一样。</p><h2 id="3-3-入口"><a href="#3-3-入口" class="headerlink" title="3/3 入口"></a>3/3 入口</h2><p>最后要做的，就是调用 notification.js 创建实例，并通过 <code>add</code> 把数据传递过去，这是组件开发的最后一步，也是最终的入口。在 <code>src/component/alert</code> 下创建文件 <code>alert.js</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// alert.js</span><br><span class="line">import Notification from &apos;./notification.js&apos;;</span><br><span class="line"></span><br><span class="line">let messageInstance;</span><br><span class="line"></span><br><span class="line">function getMessageInstance () &#123;</span><br><span class="line">  messageInstance = messageInstance || Notification.newInstance();</span><br><span class="line">  return messageInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function notice(&#123; duration = 1.5, content = &apos;&apos; &#125;) &#123;</span><br><span class="line">  let instance = getMessageInstance();</span><br><span class="line"></span><br><span class="line">  instance.add(&#123;</span><br><span class="line">    content: content,</span><br><span class="line">    duration: duration</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  info (options) &#123;</span><br><span class="line">    return notice(options);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMessageInstance</code> 函数用来获取实例，它不会重复创建，如果 messageInstance 已经存在，就直接返回了，只在第一次调用 Notification 的 <code>newInstance</code> 时来创建实例。</p><p>alert.js 对外提供了一个方法 <code>info</code>，如果需要各种显示效果，比如成功的、失败的、警告的，可以在 info 下面提供更多的方法，比如 success、fail、warning 等，并传递不同参数让 Alert.vue 知道显示哪种状态的图标。本例因为只有一个 info，事实上也可以省略掉，直接导出一个默认的函数，这样在调用时，就不用 <code>this.$Alert.info()</code> 了，直接 <code>this.$Alert()</code>。</p><p>来看一下显示一个信息提示组件的流程：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fcc0fe6df06d2?w=1800&h=180&f=png&s=47285" alt></p><p>最后把 alert.js 作为插件注册到 Vue 里就行，在入口文件 <code>src/main.js</code>中，通过 <code>prototype</code> 给 Vue 添加一个实例方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// src/main.js</span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line">import Alert from &apos;../src/components/alert/alert.js&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">Vue.prototype.$Alert = Alert</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><p>这样在项目任何地方，都可以通过 <code>this.$Alert</code> 来调用 Alert 组件了，我们创建一个 alert 的路由，并在 <code>src/views</code> 下创建页面 <code>alert.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/views/alert.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;handleOpen1&quot;&gt;打开提示 1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;handleOpen2&quot;&gt;打开提示 2&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleOpen1 () &#123;</span><br><span class="line">        this.$Alert.info(&#123;</span><br><span class="line">          content: &apos;我是提示信息 1&apos;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      handleOpen2 () &#123;</span><br><span class="line">        this.$Alert.info(&#123;</span><br><span class="line">          content: &apos;我是提示信息 2&apos;,</span><br><span class="line">          duration: 3</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>duration</code> 如果不传入，默认是 1.5 秒。</p><p>以上就是全局通知组件的全部内容。</p><h2 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h2><p>本示例算是一个 MVP（最小化可行方案），要开发一个完善的全局通知组件，还需要更多可维护性和功能性的设计，但离不开本例的设计思路。以下几点是同类组件中值得注意的：</p><ol><li>Alert.vue 的最外层是有一个 .alert 节点的，它会在第一次调用 <code>$Alert</code> 时，在 body 下创建，因为不在 <code>&lt;router-view&gt;</code> 内，它不受路由的影响，也就是说一经创建，除非刷新页面，这个节点是不会消失的，所以在 alert.vue 的设计中，并没有主动销毁这个组件，而是维护了一个子节点数组 <code>notices</code>。</li><li>.alert 节点是 <code>position: fixed</code> 固定的，因此要合理设计它的 <code>z-index</code>，否则可能被其它节点遮挡。</li><li>notification.js 和 alert.vue 是可以复用的，如果还要开发其它同类的组件，比如二次确认组件 <code>$Confirm</code>, 只需要再写一个入口 <code>confirm.js</code>，并将 <code>alert.vue</code> 进一步封装，将 <code>notices</code> 数组的循环体写为一个新的组件，通过配置来决定是渲染 Alert 还是 Confirm，这在可维护性上是友好的。</li><li>在 notification.js 的 new Vue 时，使用了 Render 函数来渲染 alert.vue，这是因为使用 template 在 runtime 的 Vue.js 版本下是会报错的。</li><li>本例的 content 只能是字符串，如果要显示自定义的内容，除了用 <code>v-html</code> 指令，也能用 Functional Render（之后章节会介绍）。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Vue.js 的精髓是组件，组件的精髓是 JavaScript。将 JavaScript 开发中的技巧结合 Vue.js 组件，就能玩出不一样的东西。</p><p>注：本节部分代码参考 <a href="https://github.com/iview/iview/tree/2.0/src/components/base/notification" target="_blank" rel="noopener">iView</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形控件——Tree</title>
      <link href="/2018/09/07/%E5%AE%9E%E6%88%98%207%EF%BC%9A%E6%A0%91%E5%BD%A2%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94Tree/"/>
      <url>/2018/09/07/%E5%AE%9E%E6%88%98%207%EF%BC%9A%E6%A0%91%E5%BD%A2%E6%8E%A7%E4%BB%B6%E2%80%94%E2%80%94Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="实战-7：树形控件——Tree"><a href="#实战-7：树形控件——Tree" class="headerlink" title="实战 7：树形控件——Tree"></a>实战 7：树形控件——Tree</h1><p>本小节基于 Vue.js 的递归组件知识，来开发一个常见的树形控件—Tree。</p><p>Tree 组件是递归类组件的典型代表，它常用于文件夹、组织架构、生物分类、国家地区等等，世间万物的大多数结构都是树形结构。使用树控件可以完整展现其中的层级关系，并具有展开收起选择等交互功能。</p><p>本节要实现的 Tree 组件具有以下功能：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16753fd7a86231b6?w=428&h=364&f=gif&s=112651" alt></p><ul><li>节点可以无限延伸（递归）；</li><li>可以展开 / 收起子节点；</li><li>节点可以选中，选中父节点，它的所有子节点也全部被选中，同样，反选父节点，其所有子节点也取消选择；</li><li>同一级所有子节点选中时，它的父级也自动选中，一直递归判断到根节点。</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Tree 是典型的数据驱动型组件，所以节点的配置就是一个 data，里面描述了所有节点的信息，比如图片中的示例数据为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">data: [</span><br><span class="line">  &#123;</span><br><span class="line">    title: &apos;parent 1&apos;,</span><br><span class="line">    expand: true,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        title: &apos;parent 1-1&apos;,</span><br><span class="line">        expand: true,</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;leaf 1-1-1&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;leaf 1-1-2&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title: &apos;parent 1-2&apos;,</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;leaf 1-2-1&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;leaf 1-2-1&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>每个节点的配置（props：data）描述如下：</p><ul><li><strong>title</strong>：节点标题（本例为纯文本输出，可参考 Table 的 Render 或 slot-scope 将其扩展）；</li><li><strong>expand</strong>：是否展开直子节点。开启后，其直属子节点将展开；</li><li><strong>checked</strong>：是否选中该节点。开启后，该节点的 Checkbox 将选中；</li><li><strong>children</strong>：子节点属性数组。</li></ul><p>如果一个节点没有 children 字段，那它就是最后一个节点，这也是递归组件终结的判断依据。</p><p>同时再提供一个是否显示多选框的 props：showCheckbox，以及两个 events：</p><ul><li><strong>on-toggle-expand</strong>：展开和收起子列表时触发；</li><li><strong>on-check-change</strong>：点击复选框时触发。</li></ul><p>因为是数据驱动，组件的 API 都比较简单，这一点跟 Table 组件是一样的，它们复杂的逻辑都在组件本身。</p><h2 id="入口-tree-vue"><a href="#入口-tree-vue" class="headerlink" title="入口 tree.vue"></a>入口 tree.vue</h2><p>在 <code>src/components</code> 中新建目录 <code>tree</code>，并在 tree 下创建两个组件 <code>tree.vue</code> 和 <code>node.vue</code>。tree.vue 是组件的入口，用于接收和处理数据，并将数据传递给 node.vue；node.vue 就是一个递归组件，它构成了每一个<strong>节点</strong>，即一个可展开 / 关闭的按钮（+或-）、一个多选框（使用第 7 节的 Checkbox 组件）、节点标题以及递归的下一级节点。可能现在听起来比较困惑，不要慌，下面逐一分解。</p><p>tree.vue 主要负责两件事：</p><ol><li>定义了组件的入口，即组件的 API；</li><li>对接收的数据 props：data 初步处理，为了在 tree.vue 中不破坏使用者传递的源数据 data，所以会克隆一份数据（cloneData）。</li></ol><p>因为传递的数据 data 是一个复杂的数组结构，克隆它要使用深拷贝，因为浅拷贝数据仍然是引用关系，会破坏源数据。所以在工具集 <code>src/utils/assist.js</code> 中新加一个深拷贝的工具函数 <code>deepCopy</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// assist.js，部分代码省略</span><br><span class="line">function typeOf(obj) &#123;</span><br><span class="line">  const toString = Object.prototype.toString;</span><br><span class="line">  const map = &#123;</span><br><span class="line">    &apos;[object Boolean]&apos;  : &apos;boolean&apos;,</span><br><span class="line">    &apos;[object Number]&apos;   : &apos;number&apos;,</span><br><span class="line">    &apos;[object String]&apos;   : &apos;string&apos;,</span><br><span class="line">    &apos;[object Function]&apos; : &apos;function&apos;,</span><br><span class="line">    &apos;[object Array]&apos;    : &apos;array&apos;,</span><br><span class="line">    &apos;[object Date]&apos;     : &apos;date&apos;,</span><br><span class="line">    &apos;[object RegExp]&apos;   : &apos;regExp&apos;,</span><br><span class="line">    &apos;[object Undefined]&apos;: &apos;undefined&apos;,</span><br><span class="line">    &apos;[object Null]&apos;     : &apos;null&apos;,</span><br><span class="line">    &apos;[object Object]&apos;   : &apos;object&apos;</span><br><span class="line">  &#125;;</span><br><span class="line">  return map[toString.call(obj)];</span><br><span class="line">&#125;</span><br><span class="line">// deepCopy</span><br><span class="line">function deepCopy(data) &#123;</span><br><span class="line">  const t = typeOf(data);</span><br><span class="line">  let o;</span><br><span class="line"></span><br><span class="line">  if (t === &apos;array&apos;) &#123;</span><br><span class="line">    o = [];</span><br><span class="line">  &#125; else if ( t === &apos;object&apos;) &#123;</span><br><span class="line">    o = &#123;&#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (t === &apos;array&apos;) &#123;</span><br><span class="line">    for (let i = 0; i &lt; data.length; i++) &#123;</span><br><span class="line">      o.push(deepCopy(data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if ( t === &apos;object&apos;) &#123;</span><br><span class="line">    for (let i in data) &#123;</span><br><span class="line">      o[i] = deepCopy(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123;deepCopy&#125;;</span><br></pre></td></tr></table></figure><p>deepCopy 函数会递归地对数组或对象进行逐一判断，如果某项是数组或对象，再拆分继续判断，而其它类型就直接赋值了，所以深拷贝的数据不会破坏原有的数据（更多深拷贝与浅拷贝的内容，可阅读扩展阅读 1）。</p><p>先来看 tree.vue 的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/tree/tree.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;tree-node</span><br><span class="line">      v-for=&quot;(item, index) in cloneData&quot;</span><br><span class="line">      :key=&quot;index&quot;</span><br><span class="line">      :data=&quot;item&quot;</span><br><span class="line">      :show-checkbox=&quot;showCheckbox&quot;</span><br><span class="line">    &gt;&lt;/tree-node&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import TreeNode from &apos;./node.vue&apos;;</span><br><span class="line">  import &#123; deepCopy &#125; from &apos;../../utils/assist.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;Tree&apos;,</span><br><span class="line">    components: &#123; TreeNode &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default () &#123;</span><br><span class="line">          return [];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      showCheckbox: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        cloneData: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">      this.rebuildData();</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      data () &#123;</span><br><span class="line">        this.rebuildData();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      rebuildData () &#123;</span><br><span class="line">        this.cloneData = deepCopy(this.data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在组件 created 时（以及 watch 监听 data 改变时），调用了 <code>rebuildData</code> 方法克隆源数据，并赋值给了 <code>cloneData</code>。</p><p>在 template 中，先是渲染了一个 node.vue 组件（<code>&lt;tree-node&gt;</code>），这一级是 Tree 的根节点，因为 cloneDate 是一个数组，所以这个根节点不一定只有一项，有可能是并列的多项。不过这里使用的 node.vue 还没有用到 Vue.js 的递归组件，它只处理第一级根节点。</p><p><code>&lt;tree-node&gt;</code> 组件（node.vue）接收两个 props：</p><ol><li>showCheckbox：与 tree.vue 的 showCheckbox 相同，只是进行传递；</li><li>data：node.vue 接收的 data 是一个 Object 而非 Array，因为它只负责渲染当前的一个节点，并递归渲染下一个子节点（即 children），所以这里对 cloneData 进行循环，将每一项节点数据赋给了 tree-node。</li></ol><h2 id="递归组件-node-vue"><a href="#递归组件-node-vue" class="headerlink" title="递归组件 node.vue"></a>递归组件 node.vue</h2><p>node.vue 是树组件 Tree 的核心，而一个 tree-node 节点包含 4 个部分：</p><ol><li>展开与关闭的按钮（+或-）；</li><li>多选框；</li><li>节点标题；</li><li>递归子节点。</li></ol><p>先来看 node.vue 的基本结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/tree/node.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul class=&quot;tree-ul&quot;&gt;</span><br><span class="line">    &lt;li class=&quot;tree-li&quot;&gt;</span><br><span class="line">      &lt;span class=&quot;tree-expand&quot; @click=&quot;handleExpand&quot;&gt;</span><br><span class="line">        &lt;span v-if=&quot;data.children &amp;&amp; data.children.length &amp;&amp; !data.expand&quot;&gt;+&lt;/span&gt;</span><br><span class="line">        &lt;span v-if=&quot;data.children &amp;&amp; data.children.length &amp;&amp; data.expand&quot;&gt;-&lt;/span&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">      &lt;i-checkbox</span><br><span class="line">        v-if=&quot;showCheckbox&quot;</span><br><span class="line">        :value=&quot;data.checked&quot;</span><br><span class="line">        @input=&quot;handleCheck&quot;</span><br><span class="line">      &gt;&lt;/i-checkbox&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; data.title &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;tree-node</span><br><span class="line">        v-if=&quot;data.expand&quot;</span><br><span class="line">        v-for=&quot;(item, index) in data.children&quot;</span><br><span class="line">        :key=&quot;index&quot;</span><br><span class="line">        :data=&quot;item&quot;</span><br><span class="line">        :show-checkbox=&quot;showCheckbox&quot;</span><br><span class="line">      &gt;&lt;/tree-node&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import iCheckbox from &apos;../checkbox/checkbox.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;TreeNode&apos;,</span><br><span class="line">    components: &#123; iCheckbox &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        type: Object,</span><br><span class="line">        default () &#123;</span><br><span class="line">          return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      showCheckbox: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .tree-ul, .tree-li&#123;</span><br><span class="line">    list-style: none;</span><br><span class="line">    padding-left: 10px;</span><br><span class="line">  &#125;</span><br><span class="line">  .tree-expand&#123;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><code>props：data</code> 包含了当前节点的所有信息，比如是否展开子节点（expand）、是否选中（checked）、子节点数据（children）等。</p><p>第一部分 expand，如果当前节点不含有子节点，也就是没有 children 字段或 children 的长度是 0，那就说明当前节点已经是最后一级节点，所以不含有展开 / 收起的按钮。</p><p>多选框直接使用了第 7 节的 Checkbox 组件（单用模式），这里将 prop: value 和事件 @input 分开绑定，没有使用 <code>v-model</code> 语法糖。value 绑定的数据 <code>data.checked</code> 表示当前节点是否选中，在点击多选框时，handleCheck 方法会修改 data.checked 数据，下文会分析。这里之所以不使用 <code>v-model</code> 而是分开绑定，是因为 @input 里要额外做一些处理，不是单纯的修改数据。</p><p>上一节我们说到，一个 Vue.js 递归组件有两个必要条件：name 特性和终结条件。name 已经指定为 <code>TreeNode</code>，而这个终结递归的条件，就是 <code>v-for=&quot;(item, index) in data.children&quot;</code>，当 <code>data.children</code> 不存在或为空数组时，自然就不会继续渲染子节点，递归也就停止了。</p><p>注意，这里的 <code>v-if=&quot;data.expand&quot;</code> 并不是递归组件的终结条件，虽然它看起来像是一个可以为 <code>false</code> 的判断语句，但它的用处是判断当前节点<strong>的子节点</strong>是否展开（渲染），如果当前节点不展开，那它所有的子节点也就不会展开（渲染）。</p><p>上面的代码保留了两个方法 <code>handleExpand</code> 与 <code>handleCheck</code>，先来看前者。</p><p>点击 + 号时，会展开直属子节点，点击 - 号关闭，这一步只需在 <code>handleExpand</code> 中修改 data 的 expand 数据即可，同时，我们通过 Tree 的根组件（tree.vue）触发一个自定义事件 <code>@on-toggle-expand</code>（上文已介绍）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// node.vue，部分代码省略</span><br><span class="line">import &#123; findComponentUpward &#125; from &apos;../../utils/assist.js&apos;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      tree: findComponentUpward(this, &apos;Tree&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleExpand () &#123;</span><br><span class="line">      this.$set(this.data, &apos;expand&apos;, !this.data.expand);</span><br><span class="line"></span><br><span class="line">      if (this.tree) &#123;</span><br><span class="line">        this.tree.emitEvent(&apos;on-toggle-expand&apos;, this.data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// tree.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    emitEvent (eventName, data) &#123;</span><br><span class="line">      this.$emit(eventName, data, this.cloneData);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 node.vue 中，通过 <code>findComponentUpward</code> 向上找到了 Tree 的实例，并调用它的 <code>emitEvent</code> 方法来触发自定义事件 <code>@on-toggle-expand</code>。之所以使用 <code>findComponentUpward</code> 寻找组件，而不是用 <code>$parent</code>，是因为当前的 node.vue，它的父级不一定就是 tree.vue，因为它是递归组件，父级有可能还是自己。</p><p>这里有一点需要注意，修改 data.expand，我们是通过 Vue 的 <code>$set</code> 方法来修改，并没有像下面这样修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.data.expand = !this.data.expand;</span><br></pre></td></tr></table></figure><p>这样有什么区别呢？如果直接用上面这行代码修改，发现数据虽然被修改了，但是视图并没有更新（原来是 + 号，点击后还是 + 号）。要理解这里，我们先看下，到底修改了什么。这里的 <code>this.data</code>，是一个 props，它是通过上一级传递的，这个上一级有两种可能，一种是递归的 node.vue，一种是根组件 tree.vue，但是递归的 node.vue，最终也是由 tree.vue 传递的，追根溯源，要修改的 <code>this.data</code> 事实上是 tree.vue 的 <code>cloneData</code>。cloneData 里的节点数据，是不一定含有 <code>expand</code> 或 <code>checked</code> 字段的，如果不含有，直接通过 <code>this.data.expand</code> 修改，这个 expand 就不是可响应的数据，Vue.js 是无法追踪到它的变化，视图自然不会更新，而 <code>$set</code> 的用法就是对可响应对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。总结来说，如果 expand 字段一开始是存在的（不管 true 或 false），不管用哪种方式修改都是可以的，否则必须用 <code>$set</code> 修改，结合起来，干脆直接用 $set 了。同理，后文的 <code>checked</code> 也是一样。</p><p>接下来是整个 Tree 组件最复杂的一部分，就是处理节点的响应状态。你可能会问，不就是选中或取消选中吗，跟 expand 一样，修改数据就行了？如果只是考虑一个节点，的确这样就可以了，但树组件是有上下级关系的，它们分为两种逻辑，当选中（或取消选中）一个节点时：</p><ol><li>它下面的所有子节点都会被选中；</li><li>如果同一级所有子节点选中时，它的父级也自动选中，一直递归判断到根节点。</li></ol><p>第 1 个逻辑相对简单，当选中一个节点时，只要递归地遍历它下面所属的所有子节点数据，修改所有的 <code>checked</code> 字段即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// node.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleCheck (checked) &#123;</span><br><span class="line">      this.updateTreeDown(this.data, checked);</span><br><span class="line"></span><br><span class="line">      if (this.tree) &#123;</span><br><span class="line">        this.tree.emitEvent(&apos;on-check-change&apos;, this.data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    updateTreeDown (data, checked) &#123;</span><br><span class="line">      this.$set(data, &apos;checked&apos;, checked);</span><br><span class="line"></span><br><span class="line">      if (data.children &amp;&amp; data.children.length) &#123;</span><br><span class="line">        data.children.forEach(item =&gt; &#123;</span><br><span class="line">          this.updateTreeDown(item, checked);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateTreeDown 只是向下修改了所有的数据，因为当前节点的数据里，是包含其所有子节点数据的，通过递归遍历可以轻松修改，这也是第 1 种逻辑简单的原因。</p><p>再来看第 2 个逻辑，它的难点在于，无法通过当前节点数据，修改到它的父节点，因为拿不到。写到这里，正常的思路应该是在 <code>this.updateTreeDown(this.data, checked);</code> 的下面再写一个 <code>updateTreeUp</code> 的方法，向上遍历，问题就是，怎样向上遍历，一种常规的思路是，把 <code>updateTreeUp</code> 方法写在 tree.vue 里，并且在 node.vue 的 <code>handleCheck</code> 方法里，通过 this.tree 调用根组件的 <code>updateTreeUp</code>，并且传递当前节点的数据，在 tree.vue 里，要找到当前节点的位置，那还需要一开始在 cloneData 里预先给每个节点设置一个唯一的 key，后面的逻辑读者应该能想到了，就是通过 key 找到节点位置，并向上递归判断……但是，这个方法想着就麻烦。</p><p>正常的思路不太好解决，我们就换个思路。一个节点，除了手动选中（或反选），还有就是第 2 种逻辑的被动选中（或反选），也就是说，如果这个节点的所有直属子节点（就是它的第一级子节点）都选中（或反选）时，这个节点就自动被选中（或反选），递归地，可以一级一级响应上去。有了这个思路，我们就可以通过 <code>watch</code> 来监听当前节点的子节点是否都选中，进而修改当前的 <code>checked</code> 字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// node.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &apos;data.children&apos;: &#123;</span><br><span class="line">      handler (data) &#123;</span><br><span class="line">        if (data) &#123;</span><br><span class="line">          const checkedAll = !data.some(item =&gt; !item.checked);</span><br><span class="line">          this.$set(this.data, &apos;checked&apos;, checkedAll);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      deep: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 watch 中，监听了 data.children 的改变，并且是深度监听的。这段代码的意思是，当 <code>data.children</code> 中的数据的某个字段发生变化时（这里当然是指 checked 字段）,也就是说它的某个子节点被选中（或反选）了，这时执行绑定的句柄 handler 中的逻辑。<code>const checkedAll = !data.some(item =&gt; !item.checked);</code> 也是一个巧妙的缩写，checkedAll 最终返回结果就是当前子节点是否都被选中了。</p><p>这里非常巧妙地利用了递归的特性，因为 node.vue 是一个递归组件，那每一个组件里都会有 watch 监听 <code>data.children</code>，要知道，当前的节点有两个”身份“，它既是下属节点的父节点，同时也是上级节点的子节点，它作为下属节点的父节点被修改的同时，也会触发上级节点中的 watch 监听函数。<strong>这就是递归</strong>。</p><p>以上就是 Tree 组件的所有内容，完整的代码见： <a href="https://github.com/icarusion/vue-component-book/tree/master/src/components/tree" target="_blank" rel="noopener">https://github.com/icarusion/vue-component-book/tree/master/src/components/tree</a></p><p>用例：<a href="https://github.com/icarusion/vue-component-book/blob/master/src/views/tree.vue" target="_blank" rel="noopener">https://github.com/icarusion/vue-component-book/blob/master/src/views/tree.vue</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>递归就像人类繁衍一样，蕴藏了无限可能，充满着神奇与智慧。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/5b5dcf8351882519790c9a2e" target="_blank" rel="noopener">浅拷贝与深拷贝</a></li></ul><p>注：本节部分代码参考 <a href="https://github.com/iview/iview/blob/2.0/src/utils/assist.js#L114" target="_blank" rel="noopener">iView</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发拓展篇 2：将 UI 界面交给第三方库</title>
      <link href="/2018/09/07/%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95%E7%AF%87%202%EF%BC%9A%E5%B0%86%20UI%20%E7%95%8C%E9%9D%A2%E4%BA%A4%E7%BB%99%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
      <url>/2018/09/07/%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95%E7%AF%87%202%EF%BC%9A%E5%B0%86%20UI%20%E7%95%8C%E9%9D%A2%E4%BA%A4%E7%BB%99%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="开发拓展篇-2：将-UI-界面交给第三方库"><a href="#开发拓展篇-2：将-UI-界面交给第三方库" class="headerlink" title="开发拓展篇 2：将 UI 界面交给第三方库"></a>开发拓展篇 2：将 UI 界面交给第三方库</h1><p>当你了解了 Vue 项目构建和开发的基本知识后，我认为接下来你一定想亲自在构建出的项目中填充自己的业务和功能逻辑，因为目前其还是空白的。</p><p>但是这里我不会教你如何实现一个具体的业务和功能模块，因为每个人想要实现的东西都可能不尽相同。如果你想快速开发一款应用，并且不想过多的操心页面 <code>UI</code> 层次的内容，比如你不想去实现一个下拉 UI 组件或设计一个 <code>icon</code> 图标，那么我想你有必要了解下 UI 库及图标库的应用。</p><h2 id="UI-库"><a href="#UI-库" class="headerlink" title="UI 库"></a>UI 库</h2><p>UI 库是脱离 JS 框架外的一种 “工具”，相比 JS 框架可以帮助你实现各种业务逻辑，其更关注于页面 UI 层面的实现，比如提供和业务无关的弹窗、导航、表单组件等，为项目 UI 层面的功能提供解决方案，比如 <a href="https://jqueryui.com/" target="_blank" rel="noopener">jQuery UI</a>。</p><p>而由于本小册介绍的 JS 框架是 Vue，所以在 Vue 项目中我们需要使用基于 Vue 开发的 UI 库。本文将以比较流行的 <a href="https://doc.vux.li/zh-CN/" target="_blank" rel="noopener">Vux</a> 为例，其目前 github star 数已在 14 k 左右。</p><blockquote><p>Vux 是一款是基于 <a href="https://weui.io" target="_blank" rel="noopener">WeUI</a> 和 <code>Vue(2.x)</code> 开发的移动端 UI 组件库，主要服务于微信页面。</p></blockquote><h3 id="Vux-的安装和配置"><a href="#Vux-的安装和配置" class="headerlink" title="Vux 的安装和配置"></a>Vux 的安装和配置</h3><p>那么我们如何在项目中使用 Vux 呢？首先我们先要进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add vux </span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">npm install vux --save</span><br></pre></td></tr></table></figure><p>同时我们还需要安装 <a href="https://doc.vux.li/zh-CN/vux-loader/about.html" target="_blank" rel="noopener">vux-loader</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add vux-loader --dev</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">npm install vux-loader --save-dev</span><br></pre></td></tr></table></figure><p>安装完成后，我们需要在项目中进行配置，而由于目前 Vux 官网的配置教程未对 Vue CLI 3.x 作出说明，我们先来看下其目前的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* build/webpack.base.conf.js */</span><br><span class="line">const vuxLoader = require(&apos;vux-loader&apos;)</span><br><span class="line">const webpackConfig = originalConfig // 原来的 module.exports 代码赋值给变量 webpackConfig</span><br><span class="line"></span><br><span class="line">module.exports = vuxLoader.merge(webpackConfig, &#123;</span><br><span class="line">    plugins: [&apos;vux-ui&apos;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>官方目前的配置是在 Vue CLI 2.x 的 <code>build/webpack.base.conf.js</code> 文件中进行修改，merge <code>vux-loader</code> 的配置项。那么在 Vue CLI 3.x 中其实原理是一样的，不一样的地方在于我们无法直接修改 webpack 配置文件，而需要通过 vue.config.js 中的 <code>configureWebpack</code> 配置项来进行修改罢了。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line">const vuxLoader = require(&apos;vux-loader&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        vuxLoader.merge(config, &#123;</span><br><span class="line">            plugins: [&apos;vux-ui&apos;]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configureWebpack 配置中提供的 <code>config</code> 参数便是 webpack 的配置内容，也可以看作是官方文档中提到的原来在 <code>webpack.base.conf.js</code> 中的 <code>module.exports</code> 代码。</p><h3 id="Vux-的使用"><a href="#Vux-的使用" class="headerlink" title="Vux 的使用"></a>Vux 的使用</h3><p>当我们配置好 Vux 后，我们便可以在项目中使用了。Vux 为我们提供了很多项目中常用的组件和工具函数等，比如我们在全局父组件 App.vue 中添加一个底部导航：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- App.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;router-view/&gt;</span><br><span class="line">        &lt;tabbar&gt;</span><br><span class="line">            &lt;tabbar-item :link=&quot;&#123;name: &apos;demo&apos;&#125;&quot;&gt;</span><br><span class="line">                &lt;span slot=&quot;label&quot;&gt;Demo&lt;/span&gt;</span><br><span class="line">            &lt;/tabbar-item&gt;</span><br><span class="line">            &lt;tabbar-item :link=&quot;&#123;name: &apos;laboratory&apos;&#125;&quot;&gt;</span><br><span class="line">                &lt;span slot=&quot;label&quot;&gt;实验室&lt;/span&gt;</span><br><span class="line">            &lt;/tabbar-item&gt;</span><br><span class="line">            &lt;tabbar-item :link=&quot;&#123;name: &apos;about&apos;&#125;&quot;&gt;</span><br><span class="line">                &lt;span slot=&quot;label&quot;&gt;关于&lt;/span&gt;</span><br><span class="line">            &lt;/tabbar-item&gt;</span><br><span class="line">        &lt;/tabbar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; Tabbar, TabbarItem &#125; from &apos;vux&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">        Tabbar,</span><br><span class="line">        TabbarItem,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot;&gt;</span><br><span class="line">@import &apos;~vux/src/styles/reset.less&apos;;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>我们通过引入组件的方式将导航组 <code>Tabbar</code>、<code>TabbarItem</code> 件引入并注册到页面中，这样通过 Vux 文档中的介绍我们便可以对相应组件进行配置。呈现效果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165bd384922ca66c?w=347&h=46&f=png&s=4883" alt></p><p>需要注意的是我们需要在 App.vue 中引入 Vux 的 <code>reset</code> 样式 less 文件以解决样式呈现不统一的问题。关于其他 Vux 组件的配置可以参考官方文档：<a href="https://doc.vux.li/zh-CN/components/actionsheet.html" target="_blank" rel="noopener">组件</a></p><h3 id="其他-UI-库（框架）"><a href="#其他-UI-库（框架）" class="headerlink" title="其他 UI 库（框架）"></a>其他 UI 库（框架）</h3><p>除了上方介绍的 Vux 外，类似的 Vue 的第三方 UI 库还有很多，这里我列举几个比较常用的：</p><ul><li><a href="https://www.iviewui.com/" target="_blank" rel="noopener">iview</a>：一套基于 Vue.js 的高质量 UI 组件库（PC端）</li><li><a href="https://github.com/iview/iview-admin" target="_blank" rel="noopener">iView Admin</a>：搭配使用iView UI组件库形成的一套后台集成解决方案（PC端）</li><li><a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">Element</a>：一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库（PC端）</li><li><a href="http://okoala.github.io/vue-antd/#!/docs/introduce" target="_blank" rel="noopener">Vue Antd</a>：Ant Design 的 Vue 实现，开发和服务于企业级后台产品（PC端）</li><li><a href="http://yuche.github.io/vue-strap/" target="_blank" rel="noopener">VueStrap</a>：一款 Bootstrap 风格的 Vue UI 库（PC端）</li><li><a href="http://mint-ui.github.io/#!/zh-cn" target="_blank" rel="noopener">Mint UI</a>：由饿了么前端开发的基于 Vue.js 的移动端组件库（移动端）</li><li><a href="https://wangdahoo.github.io/vonic-documents/#/?id=vonic" target="_blank" rel="noopener">Vonic</a>：一个基于 vue.js 和 ionic 样式的 UI 框架，用于快速构建移动端单页应用（移动端）</li><li><a href="https://youzan.github.io/vant/#/zh-CN/intro" target="_blank" rel="noopener">Vant</a>：轻量、可靠的移动端 Vue 组件库（移动端）</li><li><a href="https://didi.github.io/cube-ui/#/zh-CN/docs/introduction" target="_blank" rel="noopener">Cube UI</a>：基于 Vue.js 实现的精致移动端组件库（移动端）</li></ul><h2 id="图标库"><a href="#图标库" class="headerlink" title="图标库"></a>图标库</h2><p>了解完 UI 库，我们再来了解下图标库。图标库，顾名思义就是汇聚了大量图标的仓库，在这样的仓库中我们可以查找并下载我们想要的图标，甚至还可以制定颜色和大小。</p><p>在项目中使用图标库可以为我们的项目制定统一的图标管理标准，同时一定程度上也可以减少项目图片的数量。下面我们便来介绍下目前最流行的一款图标库 <a href="http://www.iconfont.cn" target="_blank" rel="noopener">Iconfont</a>。</p><h3 id="使用-Iconfont-下载管理图标"><a href="#使用-Iconfont-下载管理图标" class="headerlink" title="使用 Iconfont 下载管理图标"></a>使用 Iconfont 下载管理图标</h3><blockquote><p><code>Iconfont</code> 是阿里妈妈 <code>MUX</code> 倾力打造的矢量图标管理、交流平台。 设计师将图标上传到 Iconfont 平台，用户可以自定义下载多种格式的 icon，平台也可将图标转换为字体，便于前端工程师自由调整与调用。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165be177f5aae7ae?w=1170&h=497&f=png&s=88853" alt></p><p>在 Iconfont 首页，我们可以点击图标库来进行图标的搜索。这里我们可以点击官方图标库后选择 Ant Design 官方图标库进入。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165be30ebede83c8?w=1150&h=508&f=png&s=98564" alt></p><p>进入对应的图标库后，我们可以选择对应的图标加入购物车，同时购物车会更新添加后的图标数量。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165be34e414e5849?w=1178&h=386&f=png&s=104567" alt></p><p>选择完成后，为了使图标便于今后管理，我们可以新建一个项目并将图标移入项目中。在项目中，我们便可以进行图标的添加、删除和下载等操作（需要登录）。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165be3a4e7cf82e4?w=1167&h=528&f=png&s=139524" alt></p><p>这里我们采用将图标下载到本地的方式进行使用，当然你也可以使用在线链接，但这会受到网络的影响。</p><h3 id="Iconfont-的使用"><a href="#Iconfont-的使用" class="headerlink" title="Iconfont 的使用"></a>Iconfont 的使用</h3><p>下载到本地后，我们需要将文件夹中的 <code>iconfont.css</code>、<code>iconfont.eot</code>、<code>iconfont.svg</code>、<code>iconfont.ttf</code> 和 <code>iconfont.woff</code> 文件统一放到项目中去，比如我们可以放入新建的 assets 文件夹的 iconfont 中去。而 iconfont.css 便是管理这样图标字体的样式文件，我们可以将其引入到入口文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* main.js */</span><br><span class="line"></span><br><span class="line">import &apos;./assets/iconfont/iconfont.css&apos;</span><br></pre></td></tr></table></figure><p>引入后我们便可以在项目中通过给 html 标签添加样式名称的方式来进行图标的使用，比如我们在上方 Vux 的导航上添加图标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- App.vue --&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">        &lt;tabbar&gt;</span><br><span class="line">            &lt;tabbar-item :link=&quot;&#123;name: &apos;demo&apos;&#125;&quot;&gt;</span><br><span class="line">                &lt;span slot=&quot;icon&quot; class=&quot;iconfont icon-bulb&quot;&gt;&lt;/span&gt;</span><br><span class="line">                &lt;span slot=&quot;label&quot;&gt;Demo&lt;/span&gt;</span><br><span class="line">            &lt;/tabbar-item&gt;</span><br><span class="line">            &lt;tabbar-item&gt;</span><br><span class="line">                &lt;span slot=&quot;icon&quot; class=&quot;iconfont icon-experiment&quot;&gt;&lt;/span&gt;</span><br><span class="line">                &lt;span slot=&quot;label&quot;&gt;实验室&lt;/span&gt;</span><br><span class="line">            &lt;/tabbar-item&gt;</span><br><span class="line">            &lt;tabbar-item&gt;</span><br><span class="line">                &lt;span slot=&quot;icon&quot; class=&quot;iconfont icon-deploymentunit&quot;&gt;&lt;/span&gt;</span><br><span class="line">                &lt;span slot=&quot;label&quot;&gt;关于&lt;/span&gt;</span><br><span class="line">            &lt;/tabbar-item&gt;</span><br><span class="line">        &lt;/tabbar&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>按照 Vux 导航文档添加名称为 <code>icon</code> 的 <code>solt</code> 插槽后，我们还需要在标签上添加对应图标的 class 名称，比如 <code>iconfont icon-bulb</code>，最终我们的展示效果如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165be50abd042347?w=346&h=51&f=png&s=5571" alt></p><h3 id="其他图标库"><a href="#其他图标库" class="headerlink" title="其他图标库"></a>其他图标库</h3><p>除了 Iconfont，常用的图标库还有：</p><ul><li><a href="https://fontawesome.com" target="_blank" rel="noopener">Font Awesome</a>：世界上最受欢迎且最易于使用的图标集</li><li><a href="https://ionicons.com/" target="_blank" rel="noopener">Ionicons</a> ：精美的开源图标库，可以用于Web，iOS，Android和桌面应用程序</li><li><a href="https://themify.me/themify-icons" target="_blank" rel="noopener">Themify</a>：一套用于网页设计和应用程序的完整图标</li></ul><p>相信以上这些图标库就足以使你应付所有项目了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了 Vue 项目开发中可能会使用到的 UI 库与图标库的应用，以 Vux 和 Iconfont 为例讲解了它们在项目中的使用方法和注意事项，相信大家能够在项目构建和开发的基础上使用 UI 库与图标库快速实现自己的项目 UI 层面的功能和展示，为自己的项目添砖加瓦。</p><p>具体实例代码可以参考：<a href="https://github.com/luozhihao/vue-project-code/tree/master/ui-framework-project" target="_blank" rel="noopener">ui-framework-project</a></p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>查看 Vux 源码，尝试自己编写一个 UI 插件</p></li><li><p>Iconfont 是矢量图标库，其相比位图的主要区别是什么？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发拓展篇 3：尝试使用外部数据</title>
      <link href="/2018/09/07/%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95%E7%AF%87%203%EF%BC%9A%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE/"/>
      <url>/2018/09/07/%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95%E7%AF%87%203%EF%BC%9A%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="开发拓展篇-3：尝试使用外部数据"><a href="#开发拓展篇-3：尝试使用外部数据" class="headerlink" title="开发拓展篇 3：尝试使用外部数据"></a>开发拓展篇 3：尝试使用外部数据</h1><p>当你应用的 UI 层面已经趋于完善的时候，接下来你就需要去获取动态的数据来实现真实的应用场景。那么动态数据从哪里来呢？前端主要还是通过接口的形式获取。</p><p>如果有专业的接口开发人员和你一起完成一个应用，那么你只需要和他定义好接口的入参和出参，然后进行调用就好了，这也是公司中前端与后台的常见合作方式。</p><p>而在以下场景下，你可能并不需要或者并没有后台工程师提供接口给你：</p><ul><li>你个人开发的项目</li><li>你的应用数据来源于外部</li></ul><p>这时候你就需要通过调用<strong>第三方接口</strong>来实现应用的数据交互与展现。那么接下来我们就来介绍下第三方接口的使用。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>大多数情况下，我们调用的第三方接口都是完全或者部分开源及免费的，因此只要在合理的范围内使用我们便可以实现一些简单的数据交互。本文将以<a href="https://www.juhe.cn/docs" target="_blank" rel="noopener">聚合数据</a>提供的第三方接口 API 为例进行讲解。</p><h3 id="聚合数据"><a href="#聚合数据" class="headerlink" title="聚合数据"></a>聚合数据</h3><blockquote><p>聚合数据是国内领先的基础数据服务商， 以自有数据为基础，各种便捷服务整合以及第三方数据接入，为互联网开发全行业提供标准化 API 技术支撑服务的 DaaS 平台。</p></blockquote><p>在官网 API 首页（<a href="https://www.juhe.cn/docs" target="_blank" rel="noopener">https://www.juhe.cn/docs</a>）我们可以选择你想要的接口类型进行调用，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/16/165e11791a44f6ee?w=1331&h=680&f=png&s=128227" alt></p><p>其中包含了免费及付费的接口类型，如果只是用于单个的调用或测试，建议大家使用免费接口就可以了（非会员只能申请一个免费接口，比较坑），但如果你的应用准备上架或发布，你最好付费以获得更多的调用和使用接口的次数。</p><p>点击你想使用的接口后你便可以查看该接口的 API 文档，包括接口地址、请求方式、请求示例及返回示例等，比如这里我点击“笑话大全”：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/16/165e122c43a04e11?w=994&h=645&f=png&s=105039" alt></p><p>调用接口需要平台提供的 <code>AppKey</code>，在你注册登录个人中心的<strong>我的数据</strong>中可以查看对应接口的 <code>AppKey</code>：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/16/165e13bbbf50ff00?w=1384&h=466&f=png&s=93553" alt></p><p>获取到 AppKey 后我们便可以对接口进行测试了，这里我们可以直接通过对应接口的测试按钮进行测试，当然你也可以通过 <code>postman</code> 工具进行调试：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/16/165e14381021f3dd?w=1163&h=678&f=png&s=112920" alt></p><p>测试完毕后，我们便可以在 Vue 项目中接入我们的第三方接口，实现动态数据和功能。</p><h3 id="其他第三方接口"><a href="#其他第三方接口" class="headerlink" title="其他第三方接口"></a>其他第三方接口</h3><p>除了整合型的第三方接口聚合数据外，其他比较实用的第三方接口还有：</p><ul><li><a href="https://lbs.amap.com/" target="_blank" rel="noopener">高德地图</a>：访问高德地图的 Web API</li><li><a href="https://developer.github.com/v3/" target="_blank" rel="noopener">GitHub</a>：世界上领先的软件开发平台</li><li><a href="http://api.fanyi.baidu.com/api/trans/product/index" target="_blank" rel="noopener">百度翻译</a>：支持多种语言之间的相互翻译</li><li><a href="https://www.heweather.com/documents/" target="_blank" rel="noopener">和风天气</a>：中国天气信息</li><li><a href="https://www.avatardata.cn/Docs" target="_blank" rel="noopener">阿凡达数据</a> ：提供中国可用的 API</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>接下来，我们便可以在 Vue 项目中接入第三方接口来实现数据的交互。这里我们以接入聚合数据的<code>历史上的今天</code>接口为例。</p><p>首先我们来看一下该接口的请求详情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请求地址：http://api.juheapi.com/japi/toh</span><br><span class="line">请求参数：v=1.0&amp;month=10&amp;day=31&amp;key=你的AppKey</span><br><span class="line">请求方式：GET</span><br></pre></td></tr></table></figure><p>上方详情中我们可以看到请求参数主要有 4 个，分别为：</p><ul><li>v：string 类型。版本，当前：1.0</li><li>month：int 类型。月份，如：10</li><li>day：int 类型。日，如：1</li><li>key：string 类型。你的 AppKey</li></ul><p>通过接口入参的说明我们可以知道唯一可以变的数据便是月份和日期，所以我们页面中得有选择<strong>月日</strong>的功能。</p><p>另外我们再来看一下该接口的出参示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;error_code&quot;: 0,</span><br><span class="line">    &quot;reason&quot;: &quot;请求成功！&quot;,</span><br><span class="line">    &quot;result&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;day&quot;: 1, </span><br><span class="line">            &quot;des&quot;: &quot;1907年11月1日 电影导演吴永刚诞生 &amp;emsp;&amp;emsp;吴永刚，1907年11月1日生于江苏吴县。1932年后参加影片《三个摩登女性》、《母性之光》的拍摄工作。1934年在联华影片公司编导处女作《神女》，一举成名，...&quot;,  </span><br><span class="line">            &quot;id&quot;: 9000, </span><br><span class="line">            &quot;lunar&quot;: &quot;丁未年九月廿六&quot;,</span><br><span class="line">            &quot;month&quot;: 11, </span><br><span class="line">            &quot;pic&quot;: &quot;&quot;,  </span><br><span class="line">            &quot;title&quot;: &quot;电影导演吴永刚诞生&quot;,  </span><br><span class="line">            &quot;year&quot;: 1907  </span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上方示例，我们可以获取<strong>历史上的今天</strong>的标题、详情、图片等，这些数据可以用于页面展示。</p><p>这样经过接口入参和出参的分析，我们可以使用 Vux 构建一个简单的页面，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/16/165e2c1f6997c9cc?w=354&h=593&f=png&s=44709" alt></p><p>通过点击上图中“查看历史上的今天”按钮，便可以调用接口获取数据列表并渲染。主要代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;datetime-view v-model=&quot;value&quot; ref=&quot;datetime&quot; :format=&quot;format&quot;&gt;&lt;/datetime-view&gt;</span><br><span class="line">        &lt;p class=&quot;info&quot;&gt;选中值: &#123;&#123; value &#125;&#125;&lt;/p&gt;</span><br><span class="line">        &lt;div class=&quot;btn-padding&quot;&gt;</span><br><span class="line">            &lt;x-button type=&quot;primary&quot; @click.native=&quot;watchHistory&quot;&gt;查看历史上的今天&lt;/x-button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;panel header=&quot;历史上的今天&quot; :list=&quot;list&quot; type=&quot;1&quot;&gt;&lt;/panel&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; DatetimeView, XButton, Panel &#125; from &apos;vux&apos;</span><br><span class="line">import &#123; getHistory &#125; from &apos;_ser/moduleB&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">        value: &apos;10-31&apos;,</span><br><span class="line">        format: &apos;MM-DD&apos;,</span><br><span class="line">        list: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        watchHistory() &#123;</span><br><span class="line">            let data = this.value.split(&apos;-&apos;)</span><br><span class="line">        </span><br><span class="line">            this.list = [];</span><br><span class="line">        </span><br><span class="line">            getHistory(&#123;</span><br><span class="line">            v: &apos;1.0&apos;,</span><br><span class="line">            month: data[0],</span><br><span class="line">            day: data[1],</span><br><span class="line">            key: &apos;d6ceaf9be9f116ae45e7699845d87056&apos;</span><br><span class="line">            &#125;).then(response =&gt; &#123;</span><br><span class="line">                if (!response.error_code) &#123;</span><br><span class="line">                    response.result.map(e =&gt; &#123;</span><br><span class="line">                        this.list.push(&#123;</span><br><span class="line">                            title: e.title,</span><br><span class="line">                            desc: e.des,</span><br><span class="line">                            src: e.pic,</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">    DatetimeView,</span><br><span class="line">    XButton,</span><br><span class="line">    Panel</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上方我们通过调用封装的 <code>getHistory</code> 接口名称进行数据的获取，在本地调用的过程中需要注意跨域的问题，可以配置 devServer 的 proxy 代理来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            &apos;/juheapi&apos;: &#123;</span><br><span class="line">                target: &apos;http://api.juheapi.com/&apos;,</span><br><span class="line">                changeOrigin: true,</span><br><span class="line">                pathRewrite: &#123;&apos;^/juheapi&apos;: &apos;&apos;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实例代码可以参考：<a href="https://github.com/luozhihao/vue-project-code/tree/master/ui-framework-project" target="_blank" rel="noopener">ui-framework-project</a></p><p>这样我们便完成了使用第三方接口获取数据实现页面渲染的功能，为自己的应用填充了数据和功能。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>第三方接口的使用能够帮助我们快速的获取数据并实现应用的动态交互，同时也有助于解决接口开发的人力及服务器资源消耗，为部分 Vue 项目开发提供数据保障。</p><p>至此，本小册的开发部分章节也将告一段落。在这部分的内容中我们一起学习了 Vue 项目开发的实用技巧、方法和工具，并在构建出的项目基础上了解并实践了 Vue 开发的相关技术要点。希望这部分内容的介绍能够巩固大家对于 Vue 开发的基础知识，弥补 Vue 开发的技能空白。</p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>自己通过调用外部数据完成一个页面动态的数据渲染</p></li><li><p>devServer 的 proxy 代理是如何实现接口转换和重定向的？各配置项的作用是什么？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发指南篇 1：从编码技巧与规范开始</title>
      <link href="/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%201%EF%BC%9A%E4%BB%8E%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7%E4%B8%8E%E8%A7%84%E8%8C%83%E5%BC%80%E5%A7%8B/"/>
      <url>/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%201%EF%BC%9A%E4%BB%8E%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7%E4%B8%8E%E8%A7%84%E8%8C%83%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="开发指南篇-1：从编码技巧与规范开始"><a href="#开发指南篇-1：从编码技巧与规范开始" class="headerlink" title="开发指南篇 1：从编码技巧与规范开始"></a>开发指南篇 1：从编码技巧与规范开始</h1><p>当我们完成项目的构建，进入开发阶段的时候，除了你需要了解框架本身的知识点外，我们还需要提前掌握一些项目的编码技巧与规范，在根源上解决之后因编码缺陷而导致的项目维护困难、性能下降等常见问题，为项目多人开发提供编码的一致性。</p><p>本文将罗列项目中常用的一些编码技巧与规范来帮助大家提升代码质量，并会结合代码片段加强大家的理解与认知。当然不是所有实例都是针对 Vue.js 开发的，有些同样也适用于其他前端项目。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="1-使用对象代替-if-及-switch"><a href="#1-使用对象代替-if-及-switch" class="headerlink" title="1. 使用对象代替 if 及 switch"></a>1. 使用对象代替 if 及 switch</h3><p>在很多情况下，我们经常会遇到循环判断执行赋值操作的场景，一般我们都会使用 if 及 switch 的条件判断，如果符合则执行赋值，不符合则进入下个判断，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;lisi&apos;;</span><br><span class="line">let age = 18;</span><br><span class="line"></span><br><span class="line">if (name === &apos;zhangsan&apos;) &#123;</span><br><span class="line">    age = 21;</span><br><span class="line">&#125; else if (name === &apos;lisi&apos;) &#123;</span><br><span class="line">    age = 18;</span><br><span class="line">&#125; else if (name === &apos;wangwu&apos;) &#123;</span><br><span class="line">    age = 12;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">switch(name) &#123;</span><br><span class="line">    case &apos;zhangsan&apos;:</span><br><span class="line">        age = 21;</span><br><span class="line">        break</span><br><span class="line">    case &apos;lisi&apos;:</span><br><span class="line">        age = 18;</span><br><span class="line">        break</span><br><span class="line">    case &apos;wangwu&apos;:</span><br><span class="line">        age = 12;</span><br><span class="line">        break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法不仅冗余，而且代码执行效率不高，我们可以使用对象的形式简写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let name = &apos;lisi&apos;;</span><br><span class="line">let obj = &#123;</span><br><span class="line">    zhangsan: 21,</span><br><span class="line">    lisi: 18,</span><br><span class="line">    wangwu: 12</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let age = obj[name] || 18;</span><br></pre></td></tr></table></figure><p>以上这种技巧适用于循环判断一次赋值的情况，如果判断过后有较多处理逻辑的还需要使用 if 或 switch 等方法。</p><h3 id="2-使用-Array-from-快速生成数组"><a href="#2-使用-Array-from-快速生成数组" class="headerlink" title="2. 使用 Array.from 快速生成数组"></a>2. 使用 Array.from 快速生成数组</h3><p>一般我们生成一个有规律的数组会使用循环插入的方法，比如使用时间选择插件时，我们可能需要将小时数存放在数组中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let hours = [];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; 24; i++) &#123;</span><br><span class="line">    hours.push(i + &apos;时&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 Array.from 我们可以简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let hours = Array.from(&#123; length: 24 &#125;, (value, index) =&gt; index + &apos;时&apos;);</span><br></pre></td></tr></table></figure><h3 id="3-使用-router-beforeEach-来处理跳转前逻辑"><a href="#3-使用-router-beforeEach-来处理跳转前逻辑" class="headerlink" title="3. 使用 router.beforeEach 来处理跳转前逻辑"></a>3. 使用 router.beforeEach 来处理跳转前逻辑</h3><p>在某些情况下，我们需要在路由跳转前处理一些特定的业务逻辑，比如修改路由跳转、设置 title 等，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">// 首页</span><br><span class="line">const Home = (resolve =&gt; &#123;</span><br><span class="line">    require.ensure([&apos;../views/home.vue&apos;], () =&gt; &#123;</span><br><span class="line">        resolve(require(&apos;../views/home.vue&apos;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let base = `$&#123;process.env.BASE_URL&#125;`;</span><br><span class="line"></span><br><span class="line">let router =  new Router(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    base: base,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/&apos;,</span><br><span class="line">            name: &apos;home&apos;,</span><br><span class="line">            component: Home,</span><br><span class="line">            meta: &#123; title: &apos;首页&apos; &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    let title = to.meta &amp;&amp; to.meta.title;</span><br><span class="line">    </span><br><span class="line">    if (title) &#123;</span><br><span class="line">        document.title = title; // 设置页面 title</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (to.name === &apos;home&apos;) &#123;</span><br><span class="line">    </span><br><span class="line">        // 拦截并跳转至 page2 单页，$openRouter 方法在第 5 节中封装</span><br><span class="line">        Vue.$openRouter(&#123;</span><br><span class="line">            name: &apos;page2&apos;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default router</span><br></pre></td></tr></table></figure><p>注意最后需要调用 <code>next()</code> 方法执行路由跳转。</p><h3 id="4-使用-v-if-来优化页面加载"><a href="#4-使用-v-if-来优化页面加载" class="headerlink" title="4. 使用 v-if 来优化页面加载"></a>4. 使用 v-if 来优化页面加载</h3><p>在 Vue 页面中，一些模块可能需要用户主动触发才会显示，比如弹框组件等这样的子组件，那么我们可以使用 <code>v-if</code> 来进行按需渲染，没必要一进页面就渲染所有模块。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @click=&quot;showModuleB = true&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;module-b v-if=&quot;isShowModuleB&quot;&gt;&lt;/module-b&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import moduleB from &apos;components/moduleB&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            isShowModuleB: false</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        moduleB</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样当 isShowModuleB 为 false 的时候便不会加载该模块下的代码，包括一些耗时的接口调用。当然 v-if 主要适用于代码量较多、用户点击不是很频繁的模块的显示隐藏，同时如果涉及到权限问题的代码都需要使用 v-if，而不是 v-show。</p><h3 id="5-路由跳转尽量使用-name-而不是-path"><a href="#5-路由跳转尽量使用-name-而不是-path" class="headerlink" title="5. 路由跳转尽量使用 name 而不是 path"></a>5. 路由跳转尽量使用 name 而不是 path</h3><p>我们前期配置的路由路径后期难免会进行修改，如果我们页面跳转的地方全是使用的 <code>path</code>，那么我们需要修改所有涉及该 path 的页面，这样不利于项目的维护。而相对于 path，name 使用起来就方便多了，因为其具有唯一性，即使我们修改了 path，还可以使用原来的 <code>name</code> 值进行跳转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#123; </span><br><span class="line">    name: &apos;page1&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 而不是</span><br><span class="line">this.$router.push(&#123; </span><br><span class="line">    path: &apos;page1&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="6-使用-key-来优化-v-for-循环"><a href="#6-使用-key-来优化-v-for-循环" class="headerlink" title="6. 使用 key 来优化 v-for 循环"></a>6. 使用 key 来优化 v-for 循环</h3><p><code>v-for</code> 是 Vue 提供的基于源数据多次渲染元素或模板块的指令。正因为是数据驱动，所以在修改列表数据的时候，Vue 内部会根据 key 值去判断某个值是否被修改，其会重新渲染修改后的值，否则复用之前的元素。</p><p>这里如果数据中存在唯一表示 id，则推荐使用 id 作为 key，如果没有则可以使用数组的下标 index 作为 key。因为如果在数组中间插入值，其之后的 index 会发生改变，即使数据没变 Vue 也会进行重新渲染，所以最好的办法是使用数组中不会变化且唯一的那一项作为 key 值。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.data &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            arr: [</span><br><span class="line">                &#123;</span><br><span class="line">                    id: 1,</span><br><span class="line">                    data: &apos;a&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    id: 2,</span><br><span class="line">                    data: &apos;b&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    id: 3,</span><br><span class="line">                    data: &apos;c&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="7-使用-computed-代替-watch"><a href="#7-使用-computed-代替-watch" class="headerlink" title="7. 使用 computed 代替 watch"></a>7. 使用 computed 代替 watch</h3><p>很多时候页面会出现 <code>watch</code> 的滥用而导致一系列问题的产生，而通常更好的办法是使用 <code>computed</code> 属性，首先需要区别它们有什么区别：</p><ul><li>watch：当监测的属性变化时会自动执行对应的回调函数</li><li>computed：计算的属性只有在它的相关依赖发生改变时才会重新求值</li></ul><p>其实它们在功能上还是有所区别的，但是有时候可以实现同样的效果，而 computed 会更胜一筹，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; fullName &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; fullName2 &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        reurn &#123;</span><br><span class="line">            firstName: &apos;&apos;,</span><br><span class="line">            lastName: &apos;&apos;,</span><br><span class="line">            fullName2: &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    // 使用 computed</span><br><span class="line">    computed: &#123;</span><br><span class="line">        fullName() &#123;</span><br><span class="line">            return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    // 使用 watch</span><br><span class="line">    watch: &#123;</span><br><span class="line">        firstName: function(newVal, oldVal) &#123;</span><br><span class="line">            this.fullName2 = newVal + &apos; &apos; + this.lastName;</span><br><span class="line">        &#125;,</span><br><span class="line">        lastName: function(newVal, oldVal) &#123;</span><br><span class="line">            this.fullName2 = this.firstName + &apos; &apos; + newVal;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上方我们通过对比可以看到，在处理多数据联动的情况下，使用 computed 会更加合理一点。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/1/166cafdda21ccc5b?w=630&h=245&f=jpeg&s=22707" alt></p><p>computed 监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算；而 watch 监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。</p><h3 id="8-统一管理缓存变量"><a href="#8-统一管理缓存变量" class="headerlink" title="8. 统一管理缓存变量"></a>8. 统一管理缓存变量</h3><p>在项目中或多或少会使用浏览器缓存，比如 sessionStorage 和 localStorage，当一个项目中存在很多这样的缓存存取情况的时候就会变得难以维护和管理，因为其就像全局变量一样散落在项目的各个地方，这时候我们应该将这些变量统一管理起来，放到一个或多个文件中去，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* types.js */</span><br><span class="line"></span><br><span class="line">export const USER_NAME = &apos;userName&apos;;</span><br><span class="line">export const TOKEN = &apos;token&apos;;</span><br></pre></td></tr></table></figure><p>在需要存取的时候，直接引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; USER_NAME, TOKEN &#125; from &apos;../types.js&apos;</span><br><span class="line"></span><br><span class="line">sessionStorage[USER_NAME] = &apos;张三&apos;;</span><br><span class="line">localStorage[TOKEN] = &apos;xxx&apos;;</span><br></pre></td></tr></table></figure><p>使用这种方法的好处在于一旦我们需要修改变量名，直接修改管理文件中的值即可，无需修改使用它的页面，同时这也可以避免命名冲突等问题的出现，这类似于 vuex 中 mutations 变量的管理。</p><h3 id="9-使用-setTimeout-代替-setInterval"><a href="#9-使用-setTimeout-代替-setInterval" class="headerlink" title="9. 使用 setTimeout 代替 setInterval"></a>9. 使用 setTimeout 代替 setInterval</h3><p>一般情况下我们在项目里不建议使用 <code>setInterval</code>，因为其会存在代码的执行间隔比预期小以及 “丢帧” 的现象，原因在于其本身的实现逻辑。很多人会认为 setInterval 中第二个时间参数的作用是经过该毫秒数执行回调方法，其实不然，其真正的作用是<strong>经过该毫秒数将回调方法放置到队列中去</strong>，但是如果队列中存在正在执行的方法，其会等待之前的方法完毕再执行，如果存在还未执行的代码实例，其不会插入到队列中去，也就产生了 “丢帧”。</p><p>而 setTimeout 并不会出现这样的现象，因为每一次调用都会产生了一个新定时器，同时在前一个定时器代码执行完之前，不会向队列插入新的定时器代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 该定时器实际会在 3s 后立即触发下一次回调</span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    // 执行完这里的代码需要 2s</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">// 使用 setTimeout 改写，4秒后触发下一次回调</span><br><span class="line">let doSometing = () =&gt; &#123;</span><br><span class="line">    // 执行完这里的代码需要 2s</span><br><span class="line">    </span><br><span class="line">    setTimeout(doSometing, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSometing();</span><br></pre></td></tr></table></figure><p>延伸阅读：<a href="https://segmentfault.com/a/1190000011282175" target="_blank" rel="noopener">对于“不用setInterval，用setTimeout”的理解</a></p><h3 id="10-不要使用-for-in-循环来遍历数组"><a href="#10-不要使用-for-in-循环来遍历数组" class="headerlink" title="10. 不要使用 for in 循环来遍历数组"></a>10. 不要使用 for in 循环来遍历数组</h3><p>大家应该都知道 <code>for in</code> 循环是用于遍历对象的，但它可以用来遍历数组吗？答案是可以的，因为数组在某种意义上也是对象，但是如果用其遍历数组会存在一些隐患：其会遍历数组原型链上的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2];</span><br><span class="line"></span><br><span class="line">for (let key in arr) &#123;</span><br><span class="line">    console.log(arr[key]); // 会正常打印 1, 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 但是如果在 Array 原型链上添加一个方法</span><br><span class="line">Array.prototype.test = function() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">for (let key in arr) &#123;</span><br><span class="line">    console.log(arr[key]); // 此时会打印 1, 2, ƒ () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们不能保证项目代码中不会对数组原型链进行操作，也不能保证引入的第三方库不对其进行操作，所以不要使用 for in 循环来遍历数组。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文罗列了 10 个项目开发中常见的编码技巧与规范，其实技巧和规范之间本身就是相辅相成的，所以没有分别进行罗列。当然实际的项目开发中存在着很多这样的例子需要大家自己去归纳和整理，比如使用 <code>name</code> 来命名你的组件等。如果你有不错的点子，也可以分享在下方的评论区域中供大家学习。</p><p>拓展阅读：<a href="https://github.com/ecomfe/spec" target="_blank" rel="noopener">前端各类规范集合</a></p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>可以使用哪些技巧来实现数组的循环遍历、去重等？</p></li><li><p>在 Vue 项目中如何使用 <code>ESLint</code> 来规范 JS 代码的编写？</p></li><li><p>.vue 单文件组件中如何进行代码的格式化？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发指南篇 2：学会编写可复用性模块</title>
      <link href="/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%202%EF%BC%9A%E5%AD%A6%E4%BC%9A%E7%BC%96%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%202%EF%BC%9A%E5%AD%A6%E4%BC%9A%E7%BC%96%E5%86%99%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="开发指南篇-2：学会编写可复用性模块"><a href="#开发指南篇-2：学会编写可复用性模块" class="headerlink" title="开发指南篇 2：学会编写可复用性模块"></a>开发指南篇 2：学会编写可复用性模块</h1><p>在生活中，重复的机械劳动会消耗我们的时间和精力，提高生产成本，降低工作效率。同样，在代码世界中，编写重复的代码会导致代码的冗余，页面性能的下降以及后期维护成本的增加。由此可见将重复的事情复用起来是提高生产效率、降低维护成本的不二之选。</p><p>在 Vue 项目中，每一个页面都可以看作是由大大小小的模块构成的，即便是一行代码、一个函数、一个组件都可以看作是一个个自由的模块。那么提高代码的复用性的关键便在于编写可复用的模块，也就是编写可复用的代码、函数和组件等。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let person = [];</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; data.obj.items.length; i++) &#123;</span><br><span class="line">    person.push(&#123;</span><br><span class="line">        name: data.obj.items[i].name,</span><br><span class="line">        age: data.obj.items[i].age</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道上方代码给你的第一印象是什么？总之给我的印象是糟糕的，因为出现了重复性的代码片段 <code>data.obj.items</code>，可能这样的代码在我们团队开发中随处可见，这也说明了重复编码现象其实无处不在。</p><p>面对自己编写的代码，我们应该保持一颗去重的心，发现重复的地方就相当于找到了可以复用的模块。在不复用的情况下，上述代码一旦需要修改变量 <code>items</code> 为 <code>lists</code>，那么我们就得修改 3 处地方，不知不觉就增加了维护成本。而到时候往往修改你代码的人并不是你自己，所以对自己好点，对他人也会好点。复用后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let person = [];</span><br><span class="line">let values = data.obj.items;</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; values.length; i++) &#123;</span><br><span class="line">    person.push(&#123;</span><br><span class="line">        name: values[i].name,</span><br><span class="line">        age: values[i].age</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过将 data.obj.items 的值赋值给变量 values 来实现了复用，此时修改 <code>items</code> 为 <code>lists</code> 的话我们只需修改一处地方即可，不管是维护成本还是代码可读性上，复用的优势都显而易见。</p><h2 id="封装成一个函数"><a href="#封装成一个函数" class="headerlink" title="封装成一个函数"></a>封装成一个函数</h2><p>除了使用变量的赋值缓存使用来解决数据的重复读取外，我们在开发过程中重复性更多的也许是功能点的重复，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;tempalte&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;str1&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;str2&quot;&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123; str1.slice(1).toUpperCase() &#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123; str2.slice(1).toUpperCase() &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>上述代码的重复功能点在于截取输入框中第二个字符开始到最后的值并把它们转化成大写字母，像这样很简单的操作虽然重复使用也不会出现太大的问题，但是如果是代码量较多的操作呢？重复书写相同功能的代码是一种不经过大脑思考的行为，我们需要对其进行优化，这里我们可以把功能点封装成一个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        sliceUpperCase(val) &#123;</span><br><span class="line">            return val.slice(1).toUpperCase()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此我们只要在用到该方法的地方调用即可，将值传入其中并返回新值。当然像在双花括号插值和 v-bind 表达式中重复的功能点我们可以封装成过滤器比较合适：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 单文件组件注册过滤器</span><br><span class="line">filters: &#123;</span><br><span class="line">    sliceUpperCase(val) &#123;</span><br><span class="line">        return val.slice(1).toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 全局注册过滤器</span><br><span class="line">Vue.filter(&apos;sliceUpperCase&apos;, function (val) &#123;</span><br><span class="line">    return val.slice(1).toUpperCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在 html 中使用“管道”符进行过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;&#123; str1 | toUpperCase &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;div&gt;&#123;&#123; str2 | toUpperCase &#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样我们就把重复的功能性代码封装成了函数，而不管是过滤器还是正常的方法封装，其本质都是函数的封装。</p><h2 id="封装成一个组件"><a href="#封装成一个组件" class="headerlink" title="封装成一个组件"></a>封装成一个组件</h2><p>相比较于函数的封装，规模更大一点的便是组件的封装，组件包含了模板、脚本以及样式的代码，在实际开发中组件的使用频率也是非常大的，我们项目中的每一个页面其实都可以看作是一个父组件，其可以包含很多子组件，子组件通过接收父组件的值来渲染页面，父组件通过响应子组件的回调来触发事件。</p><p>封装一个组件主要包含两种方式，一种是最常见的整体封装，用户通过改变数据源来呈现不同的页面状态，代码结构不可定制化。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;my-component data=&quot;我是父组件传入子组件的数据&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>另一种便是自定义封装，也就是插槽(slot)，我们可以开放一部分槽位给父组件，使其能够进行一定程度的定制化，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;my-component data=&quot;我是父组件传入子组件的数据&quot;&gt;</span><br><span class="line">        &lt;template slot=&quot;customize&quot;&gt;</span><br><span class="line">            &lt;span&gt;这是定制化的数据&lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">    &lt;/my-component&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在 myComponent 组件中我们便可以接收对应的 slot：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; data &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;slot name=&quot;customize&quot;&gt;&lt;/slot&gt;</span><br><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure><p>这里我们通过定义 slot 标签的 name 值为 customize 来接收父组件在使用该组件时在 template 标签上定义的 slot=”customize” 中的代码，不同父组件可以定制不同的 slot 代码来实现差异化的插槽。最终渲染出来的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;span&gt;我是父组件传入子组件的数据&lt;/span&gt;</span><br><span class="line">        &lt;span&gt;这是定制化的数据&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样我们就完成了一个小型组件的封装，将共用代码封装到组件中去，页面需要引入的时候直接使用 import 并进行相应注册即可，当然你也可以进行全局的引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import myComponent from &apos;../myComponent.vue&apos;</span><br><span class="line"></span><br><span class="line">// 全局</span><br><span class="line">Vue.component(&apos;my-component&apos;, myComponent)</span><br></pre></td></tr></table></figure><h2 id="封装成一个插件"><a href="#封装成一个插件" class="headerlink" title="封装成一个插件"></a>封装成一个插件</h2><p>在某些情况下，我们封装的内容可能不需要使用者对其内部代码结构进行了解，其只需要熟悉我们提供出来的相应方法和 api 即可，这需要我们更系统性的将公用部分逻辑封装成插件，来为项目添加全局功能，比如常见的 loading 功能、弹框功能等。</p><p>Vue 提供给了我们一个 install 方法来编写插件，使用该方法中的第一个 Vue 构造器参数可以为项目添加全局方法、资源、选项等。比如我们可以给组件添加一个简单的全局调用方法来实现插件的编写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* toast.js */</span><br><span class="line">import ToastComponent from &apos;./toast.vue&apos; // 引入组件</span><br><span class="line"></span><br><span class="line">let $vm</span><br><span class="line"></span><br><span class="line">export default &#123;    </span><br><span class="line">    install(Vue, options) &#123;</span><br><span class="line">        </span><br><span class="line">        // 判断实例是否存在</span><br><span class="line">        if (!$vm) &#123;            </span><br><span class="line">            const ToastPlugin = Vue.extend(ToastComponent); // 创建一个“扩展实例构造器”</span><br><span class="line">            </span><br><span class="line">            // 创建 $vm 实例</span><br><span class="line">            $vm = new ToastPlugin(&#123;                </span><br><span class="line">                el: document.createElement(&apos;div&apos;)  // 声明挂载元素          </span><br><span class="line">            &#125;);            </span><br><span class="line">            </span><br><span class="line">            document.body.appendChild($vm.$el); // 把 toast 组件的 DOM 添加到 body 里</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        // 给 toast 设置自定义文案和时间</span><br><span class="line">        let toast = (text, duration) =&gt; &#123;</span><br><span class="line">            $vm.text = text;</span><br><span class="line">            $vm.duration = duration;</span><br><span class="line">            </span><br><span class="line">            // 在指定 duration 之后让 toast 消失</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                $vm.isShow = false;  </span><br><span class="line">            &#125;, $vm.duration);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 判断 Vue.$toast 是否存在</span><br><span class="line">        if (!Vue.$toast) &#123;            </span><br><span class="line">            Vue.$toast = toast;        </span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        Vue.prototype.$toast = Vue.$toast; // 全局添加 $toast 事件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/11/1/166cb0b518f4c53c?w=855&h=285&f=jpeg&s=28471" alt></p><p>成功编写完插件的 JS 脚本后，我们在入口文件中需要通过 Vue.use() 来注册一下该插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Toast from &apos;@/widgets/toast/toast.js&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Toast); // 注册 Toast</span><br></pre></td></tr></table></figure><p>最后我们在需要调用它的地方直接传入配置项使用即可，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$toast(&apos;Hello World&apos;, 2000);</span><br></pre></td></tr></table></figure><p>当然你也可以不使用 install 方法来编写插件，直接采用导出一个封装好的实例方法并将其挂载到 Vue 的原型链上来实现相同的功能。</p><p>更详细的编写插件和实例的方法可以参考我之前写的一篇文章：<a href="https://mp.weixin.qq.com/s/Aqgh7Dkialhm9v8U0wBuqg" target="_blank" rel="noopener">Vue 插件编写与实战</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文讲解了编写可复用性模块的常见方法，通过出现了重复代码 -&gt; 封装成一个变量 -&gt; 封装成一个函数 -&gt; 封装成一个组件 -&gt; 封装成一个插件，一步步将重复代码进行分析和复用。而与重复代码做斗争是一个持久性的过程，我们需要时刻保持一种“强迫症”的心态去整理复用项目中的重复代码，做好编码的严谨和自律。</p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>在 Vue 中如何添加全局自定义指令？</p></li><li><p>在 vue 路由切换时如何全局隐藏某个插件？比如文中的 toast</p></li><li><p>如何实现一个表单验证插件？需要运用到哪些知识？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发指南篇 4：数据驱动与拼图游戏</title>
      <link href="/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%204%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%204%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E4%B8%8E%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="开发指南篇-4：数据驱动与拼图游戏"><a href="#开发指南篇-4：数据驱动与拼图游戏" class="headerlink" title="开发指南篇 4：数据驱动与拼图游戏"></a>开发指南篇 4：数据驱动与拼图游戏</h1><p>数据驱动是 Vue 框架的核心特性之一，也是 Vue 响应式原理的具体体现，相信大家对其应该深有体会，尤其是在操作数据来触发页面更新的时候。</p><p>为了让大家更加了解数据驱动的理念，并解决使用过程中可能出现的一系列问题，本文将结合比较常见和简单的 “拼图游戏” 来展示 Vue 数据驱动的魅力所在。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>首先我们先来看一下实现的 “拼图游戏” 的动态效果：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/28/16580710e190e86c?w=360&h=240&f=gif&s=2510561" alt></p><p>在不操作 <code>DOM</code> 的情况下实现以上功能其实需要我们对 Vue 数据驱动及数据可视化有一个非常清楚的认知，在操作数据的同时驱动可视化界面的还原。</p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>接下来我们来看一下实现该拼图游戏的功能点及关键代码：</p><h3 id="游戏面板的构建"><a href="#游戏面板的构建" class="headerlink" title="游戏面板的构建"></a>游戏面板的构建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- HTML 部分 --&gt;</span><br><span class="line">&lt;ul class=&quot;puzzle-wrap&quot;&gt;</span><br><span class="line">    &lt;li </span><br><span class="line">        :class=&quot;&#123;&apos;puzzle&apos;: true, &apos;puzzle-empty&apos;: !puzzle&#125;&quot; </span><br><span class="line">        v-for=&quot;(puzzle, index) in puzzles&quot;</span><br><span class="line">        :key=&quot;index&quot;</span><br><span class="line">        v-text=&quot;puzzle&quot;</span><br><span class="line">    &gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 数据部分</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            puzzles: Array.from(&#123; length: 15 &#125;, (value, index) =&gt; index + 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方我们使用 <code>v-for</code> 循环构建了从 1 ～ 15 按顺序排列的方块格子，也就是拼图完成时候的顺序，但是拼图游戏一开始数字的顺序应该是无序的，也是随机打乱的，那么我们怎么实现呢？可以使用下方的随机排列函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function shuffle(arr) &#123;</span><br><span class="line">    let len = arr.length</span><br><span class="line">    </span><br><span class="line">    for (let i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        let idx = Math.floor(Math.random() * (len - i))</span><br><span class="line">        let temp = arr[idx]</span><br><span class="line">        arr[idx] = arr[len - i - 1]</span><br><span class="line">        arr[len - i - 1] = temp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数中我们使用 <code>Math.random()</code> 来返回 0 和 1 之间的伪随机数，可能为 0，但总是小于1，[0, 1)，而通过这一特性我们可以实现生成 n-m，包含 n 但不包含 m 的整数，具体步骤如下：</p><ul><li>第一步算出 <code>m-n</code> 的值，假设等于 w</li><li>第二步 <code>Math.random() * w</code></li><li>第三步 <code>Math.random() * w + n</code></li><li>第四步 <code>Math.floor(Math.random() * w + n)</code></li></ul><p>在 <code>shuffle</code> 函数中 n 值永远是 0，而 w（即 len - i） 值随着循环 i 值的变大而不断减小。</p><blockquote><p>在上面的算法里，我们每一次循环从前 len - i 个元素里随机一个位置，将这个元素和第 len - i 个元素进行交换，迭代直到 i = len - 1 为止。</p></blockquote><p>这一便实现了数组的随机打乱。最后我们需要在数组末尾追加一个空值来显示唯一一个空白格子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.puzzles.push(&apos;&apos;);</span><br></pre></td></tr></table></figure><h3 id="交换方块位置"><a href="#交换方块位置" class="headerlink" title="交换方块位置"></a>交换方块位置</h3><p>实现随机数字后，当我们点击方块，如果其上下左右存在为空的格子就需要将其进行交换，而由于是数据驱动界面，这里我们便需要交换两者在数组中的位置来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        </span><br><span class="line">        // 点击方块</span><br><span class="line">        moveFn(index) &#123;</span><br><span class="line">            let puzzles = this.puzzles</span><br><span class="line"></span><br><span class="line">            // 获取点击位置上下左右的值</span><br><span class="line">            let leftNum = this.puzzles[index - 1],</span><br><span class="line">                rightNum = this.puzzles[index + 1],</span><br><span class="line">                topNum = this.puzzles[index - 4],</span><br><span class="line">                bottomNum = this.puzzles[index + 4]</span><br><span class="line"></span><br><span class="line">            // 和为空的位置交换数值</span><br><span class="line">            if (leftNum === &apos;&apos; &amp;&amp; index % 4) &#123;</span><br><span class="line">                this.setPuzzle(index, -1)</span><br><span class="line">            &#125; else if (rightNum === &apos;&apos; &amp;&amp; 3 !== index % 4) &#123;</span><br><span class="line">                this.setPuzzle(index, 1)</span><br><span class="line">            &#125; else if (topNum === &apos;&apos;) &#123;</span><br><span class="line">                this.setPuzzle(index, -4)</span><br><span class="line">            &#125; else if (bottomNum === &apos;&apos;) &#123;</span><br><span class="line">                this.setPuzzle(index, 4)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        // 设置数组值</span><br><span class="line">        setPuzzle(index, num) &#123;</span><br><span class="line">            let curNum = this.puzzles[index]</span><br><span class="line">            </span><br><span class="line">            this.$set(this.puzzles, index + num, curNum)</span><br><span class="line">            this.$set(this.puzzles, index, &apos;&apos;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是 16 宫格的拼图，所以我们在点击获取位置的时候需要考虑边界情况，比如第 4 个格子为空，我们点击第 5 个格子不应该交换它们，因为在界面上第 4 个格子不在第 5 个格子的左侧，所以我们使用 <code>index % 4</code> 的方法来进行边界的判断，同时使用 Vue 提供的 <code>$set</code> 方法来将响应属性添加到数组上。</p><h3 id="校验是否过关"><a href="#校验是否过关" class="headerlink" title="校验是否过关"></a>校验是否过关</h3><p>最后我们需要校验游戏是否过关，我们只需要在最后一个格子为空时去进行校验即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (this.puzzles[15] === &apos;&apos;) &#123;</span><br><span class="line">    const newPuzzles = this.puzzles.slice(0, 15)</span><br><span class="line">    const isPass = newPuzzles.every((e, i) =&gt; e === i + 1)</span><br><span class="line"></span><br><span class="line">    if (isPass) &#123;</span><br><span class="line">        alert (&apos;恭喜，闯关成功！&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用数组的 <code>every</code> 方法来简化代码的复杂度，当所有数字大小和对应的数组下标 + 1 相吻合时即会返回 <code>true</code>。</p><p>如此我们便完成了一个简单拼图游戏的功能。</p><h2 id="盲点及误区"><a href="#盲点及误区" class="headerlink" title="盲点及误区"></a>盲点及误区</h2><p>在实现拼图游戏后，有些同学可能会存在一些疑惑，比如：数组赋值为什么要用 $set 方法？数组随机打乱为什么不用 sort 排序呢？下面便来进行讲解：</p><h3 id="为什么要用-set-方法"><a href="#为什么要用-set-方法" class="headerlink" title="为什么要用 $set 方法"></a>为什么要用 $set 方法</h3><p>大家应该都知道如果不用 <code>$set</code> 方法我们可以直接通过操作数组索引的形式对数组进行赋值，从而交换拼图的中两者的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 设置数组值</span><br><span class="line">setPuzzle(index, num) &#123;</span><br><span class="line">    let curNum = this.puzzles[index]</span><br><span class="line">    </span><br><span class="line">    this.puzzles[index + num] = curNum</span><br><span class="line">    this.puzzles[index] = &apos;&apos;</span><br><span class="line">    </span><br><span class="line">    // this.$set(this.puzzles, index + num, curNum)</span><br><span class="line">    // this.$set(this.puzzles, index, &apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是你会发现这样做数据是改变了，但是页面并没有因此重新渲染，这是为什么呢？其实 Vue 官方已经给出了明确的答案：</p><blockquote><p>由于 JavaScript 的限制，Vue 不能检测以下变动的数组：</p><ul><li>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ul></blockquote><p>我们这里使用的便是第一种利用索引的方式，由于 Vue 检测不到数组变动，因此页面便无法重绘。同样 Vue 也不能检测对象属性的添加或删除，需要使用 <code>Vue.set(object, key, value)</code> 方法来实现。</p><p>其实还有一种比较取巧的方式便是强制重新渲染 Vue 实例来解决这一问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 设置数组值</span><br><span class="line">setPuzzle(index, num) &#123;</span><br><span class="line">    let curNum = this.puzzles[index]</span><br><span class="line">    </span><br><span class="line">    this.puzzles[index + num] = curNum</span><br><span class="line">    this.puzzles[index] = &apos;&apos;</span><br><span class="line">    </span><br><span class="line">    this.$forceUpdate() // 迫使 Vue 实例重新渲染</span><br><span class="line">    </span><br><span class="line">    // this.$set(this.puzzles, index + num, curNum)</span><br><span class="line">    // this.$set(this.puzzles, index, &apos;&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方我们使用了 Vue 提供的 <code>$forceUpdate</code> 方法迫使 Vue 实例重新渲染，这样改变的数据就会被更新的页面中去。但是最好不要这样操作，因为这会导致 Vue 重新遍历此对象所有的属性，一定程度上会影响页面的性能。</p><h3 id="为什么不用-sort-排序"><a href="#为什么不用-sort-排序" class="headerlink" title="为什么不用 sort 排序"></a>为什么不用 sort 排序</h3><p>其实 sort 方法也能够实现数组的随机排序，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let puzzleArr = Array.from(&#123; length: 15 &#125;, (value, index) =&gt; index + 1);</span><br><span class="line"></span><br><span class="line">// 随机打乱数组</span><br><span class="line">puzzleArr = puzzleArr.sort(() =&gt; &#123;</span><br><span class="line">    return Math.random() - 0.5</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们通过使用 <code>Math.random()</code> 的随机数减去 0.5 来返回一个大于、等于或小于 0 的数，sort 方法会根据接收到的值来对相互比较的数据进行升序或是降序排列。</p><p>但是由于 JavaScript 内置排序算法的缺陷性，使用 sort 排序的结果并不随机分布，经过大量的测试你会发现<strong>越大的数字出现在越后面的概率越大</strong>。</p><p>由于本文并非是一篇介绍 sort 排序的文章，关于论证其缺陷性的话题这里就不进行详细展开了，感兴趣的同学可以进一步进行探究。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文实例是基于我之前写的一篇关于利用 Vue.js 实现拼图游戏的文章上进行了改进和优化，希望通过这样一个小游戏来强化大家对于 Vue 数据驱动的理解。相比操作 DOM 元素，操作数据其实更加的便捷和快速，可以使用较少的代码来实现一些较为复杂的逻辑。</p><p>具体实例代码可以参考：<a href="https://github.com/luozhihao/vue-project-code/blob/ea7294370af888084be41c10c914b4fedbf3f400/ui-framework-project/src/views/demo/puzzle.vue" target="_blank" rel="noopener">puzzle</a></p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>Vue 中监听数据变化的原理是什么？是通过何种方式实现的？</p></li><li><p>如何论证原生 JS 中 sort 排序后越大的数字出现在越后面的概率越大？</p></li><li><p>如何使用 <code>Math.random()</code> 生成 n-m，不包含 n 但包含 m 的整数？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发指南篇 3：合理划分容器组件与展示组件</title>
      <link href="/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%203%EF%BC%9A%E5%90%88%E7%90%86%E5%88%92%E5%88%86%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%203%EF%BC%9A%E5%90%88%E7%90%86%E5%88%92%E5%88%86%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="开发指南篇-3：合理划分容器组件与展示组件"><a href="#开发指南篇-3：合理划分容器组件与展示组件" class="headerlink" title="开发指南篇 3：合理划分容器组件与展示组件"></a>开发指南篇 3：合理划分容器组件与展示组件</h1><p>上篇文章我们提到了组件的概念，组件是目前模块化、组件化开发模式中必不可少的单元形式，那么除了其概念和可复用性外，我们对它的职能划分了解多少呢？</p><p>本文将立足 Vue 组件的职能来谈谈我个人对于其划分的理解，唯有了解不同类型组件的职能才能编写出可维护、低耦合的前端代码。</p><h2 id="组件的职能划分"><a href="#组件的职能划分" class="headerlink" title="组件的职能划分"></a>组件的职能划分</h2><p>如果要将 Vue 组件按照职能划分，我们可以将其分为两种类型：容器组件和展示组件。</p><p>容器组件和展示组件的概念来自于 <code>Redux</code> 文档，那么首先什么是容器组件呢？顾名思义，它是一个容器性质的组件，我们可以把它理解为最外层的父组件，也就是最顶层的组件，一般我们把它放置在 <code>views</code> 文件夹下，其功能主要用于做数据提取与实现公共逻辑，然后渲染对应的子组件。</p><p>另一类组件叫做展示组件，字面意思就是主要用于做展示的组件，其主要功能是负责接收从容器组件传输过来的数据并在页面上渲染，实现其内部独有的功能逻辑。</p><p>一个页面中容器组件与展示组件的关系如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/13/16533670555c3f00?w=478&h=364&f=png&s=19662" alt></p><p>上图我们以博客首页为例，容器组件就是整个首页最外层的父组件，而展示组件就包含了导航栏、文章列表、底部等子组件，代码层面如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;navigation @count=&quot;countFn&quot;&gt;&lt;/navigation&gt;</span><br><span class="line">        &lt;article :list=&quot;articleList&quot;&gt;&lt;/article&gt;</span><br><span class="line">        &lt;foot&gt;&lt;/foot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; mapActions, mapGetters &#125; from &apos;vuex&apos;;</span><br><span class="line">    export default &#123;</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            this.SET_BLOG_DATA(); // 调用接口获取数据</span><br><span class="line">        &#125;,</span><br><span class="line">        computed: &#123;</span><br><span class="line">            ...mapGetters([&apos;articleList&apos;]), // 监听 state</span><br><span class="line">        &#125;</span><br><span class="line">        methods: &#123;</span><br><span class="line">            ...mapActions([&apos;SET_BLOG_DATA&apos;, &apos;SET_NAV_COUNT&apos;]),</span><br><span class="line">            countFn(item) &#123;</span><br><span class="line">            </span><br><span class="line">                // 调用接口存储导航点击次数并跳转，通过派发 action 的形式来发起 state 变化</span><br><span class="line">                this.SET_NAV_COUNT(&#123; type: item.type &#125;);</span><br><span class="line">                </span><br><span class="line">                this.$router.push(&#123;name: item.route&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上是首页容器组件中的主要代码，其主要做了两件事情：数据的传递和回调的处理，当然还可以包括处理一些该页面中不属于任何一个展示组件的方法，比如校验登录状态。在一个容器组件中可以包含多个展示组件，下面我们来看一下展示组件 <code>Navigation</code> 中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li </span><br><span class="line">            v-for=&quot;(item, index) in nav&quot;</span><br><span class="line">            :key=&quot;index&quot;</span><br><span class="line">            @click=&quot;goNav(item)&quot;</span><br><span class="line">            v-text=&quot;item.name&quot;</span><br><span class="line">        &gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                nav: [&#123;</span><br><span class="line">                    name: &apos;首页&apos;,</span><br><span class="line">                    route: &apos;index&apos;,</span><br><span class="line">                    type: &apos;index&apos;</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    name: &apos;文章&apos;,</span><br><span class="line">                    route: &apos;article&apos;,</span><br><span class="line">                    type: &apos;article&apos; </span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    name: &apos;关于&apos;,</span><br><span class="line">                    route: &apos;about&apos;,</span><br><span class="line">                    type: &apos;about&apos; </span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            goNav(item) &#123;</span><br><span class="line">                this.$emit(&apos;count&apos;, item); // 触发回调</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>Navigation</code> 导航组件只负责自己内部的数据渲染和回调逻辑，对于存储每个导航的点击量及跳转逻辑来说，作为展示组件这并不是其所关心的，所以我们需要通过触发容器组件回调的方式来实现。再来看一下展示组件 <code>Article</code> 的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li </span><br><span class="line">            v-for=&quot;(item, index) in list&quot;</span><br><span class="line">            :key=&quot;index&quot;</span><br><span class="line">            @click=&quot;goPage(item.id)&quot;</span><br><span class="line">            v-text=&quot;item.title&quot;</span><br><span class="line">        &gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">        </span><br><span class="line">            // 接收容器组件数据</span><br><span class="line">            list: &#123;</span><br><span class="line">                default: [],</span><br><span class="line">                type: Array</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>展示组件 Article 中动态的数据通过 <code>props</code> 从父组件中获取，其内部只处理文章列表的渲染工作，这样很好的将 UI 层面和应用层面进行了分离，便于今后该组件的复用。</p><p>此外 <code>Foot</code> 组件为纯静态组件，其只负责内部数据的渲染，不接收外部的数据和回调方法，这里就不做介绍了。</p><p>从以上代码示例中我们不难发现容器组件和展示组件的主要区别和注意点：</p><p>展示组件</p><p>容器组件</p><p>作用</p><p>描述如何展现（骨架、样式）</p><p>描述如何运行（数据获取、状态更新）</p><p>是否使用 Vuex</p><p>否</p><p>是</p><p>数据来源</p><p>props</p><p>监听 Vuex state</p><p>数据修改</p><p>从 props 调用回调函数</p><p>向 Vuex 派发 actions</p><p>相比较如果上述的博客首页不做组件的划分，全部逻辑都放在一个组件中，那么必然会导致代码的臃肿和难以维护，而一旦划分了容器组件和展示组件，后期如果哪个页面同样需要展示文章列表，我们只需要传递不同的数据直接复用即可。</p><h2 id="组件的层次结构"><a href="#组件的层次结构" class="headerlink" title="组件的层次结构"></a>组件的层次结构</h2><p>了解了组件职能的划分后，我们再来看一下组件的层次结构。关于组件的层次，一般页面中不宜嵌套超过 3 层的组件，因为超过 3 层后父子组件的通信就会变得相对困难，不利于项目的开发和维护。3 层结构的容器组件与展示组件的数据传递如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/14/165387907893eb84?w=633&h=41&f=png&s=9420" alt></p><p>可见组件的层次越深数据传递的过程就会变得越复杂，当然这取决于你如何划分容器组件和展示组件，比如我们可以将上述博客首页换一种划分方式：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/14/1653884e4abef22f?w=298&h=364&f=png&s=10718" alt></p><p>上图我们页面中存在 3 个容器组件，每个容器组件又可以包含各自的展示组件，这样一定程度上可以减少组件的层次嵌套深度。当然展示组件中也可以包含对应的容器组件来解决数据传输的问题：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/14/165388d3df0a32c5?w=633&h=41&f=png&s=10187" alt></p><p>这样展示组件 B 下面的容器组件 C 便可以不依赖于容器组件 A 的数据，其可以单独的进行数据获取和状态更新。</p><p>而对于那些你不知道应该划分为容器组件和展示组件的组件，比如一些耦合度较高的组件，那么你可以暂时归类到其他组件中，混用容器和展示，随着日后功能的逐渐清晰，我们再将其进行划分。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要介绍了容器组件和展示组件的概念和层次划分，在编码上，容器组件和展示组件各司其职，它们将容器和展示更好的分离，提高了组件的重用度，降低了功能上的耦合度，为高效、高质量的代码开发奠定了基础。</p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>如果你了解 React，那么试想一下在 React 中展示组件与容器组件有哪些异同点？</p></li><li><p>如果需要你对掘金首页进行组件的划分，你会如何划分其结构和层次？</p></li><li><p>在子组件的 <code>props</code> 中，如何动态的设置默认值？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发拓展篇 1：扩充你的开发工具</title>
      <link href="/2018/09/07/%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95%E7%AF%87%201%EF%BC%9A%E6%89%A9%E5%85%85%E4%BD%A0%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
      <url>/2018/09/07/%E5%BC%80%E5%8F%91%E6%8B%93%E5%B1%95%E7%AF%87%201%EF%BC%9A%E6%89%A9%E5%85%85%E4%BD%A0%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="开发拓展篇-1：扩充你的开发工具"><a href="#开发拓展篇-1：扩充你的开发工具" class="headerlink" title="开发拓展篇 1：扩充你的开发工具"></a>开发拓展篇 1：扩充你的开发工具</h1><p>在项目开发中，工具的使用起到了至关重要的作用，正所谓工欲善其事，必先利其器，掌握一些实用的开发工具能够使我们的开发效率事半功倍。</p><p>那么我们应该掌握哪些开发工具的使用方法呢？其实一路走来，我们已经介绍的开发工具包括了 <code>npm</code>、<code>yarn</code>、<code>webpack</code> 以及一些集成在项目中的工具包，这些工具一定程度上都大大简化了我们的开发流程，起到了项目助推剂的作用。因此在开发工具的学习上我们应该抱着宜多不宜少的心态，积极主动的扩充自己的工具库。</p><h2 id="巧用-Chrome-插件"><a href="#巧用-Chrome-插件" class="headerlink" title="巧用 Chrome 插件"></a>巧用 Chrome 插件</h2><p>首先，既然说到工具，那我们不得不介绍下占据浏览器市场份额霸主地位的 <code>Chrome</code> 了。相信每一个从事前端开发的同学都对其寄存着一种亲切感，因为只要是参与 web 项目的开发就基本上离不开它的关照，比如它提供的调试控制台以及数以万计的插件等。</p><p>而作为一名前端开发人员，我想你的 Chrome 浏览器地址栏右侧肯定排列着几款你钟爱的插件，使用的插件数量越多说明了你掌握的 Chrome 技能越多，同时一定程度上也凸显了你的开发能力。</p><p>那么接下来我们不妨来认识一下几款实用的 Chrome 插件：</p><h3 id="Vue-js-devtools"><a href="#Vue-js-devtools" class="headerlink" title="Vue.js devtools"></a>Vue.js devtools</h3><p>首先介绍的肯定是 <a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh-CN" target="_blank" rel="noopener">Vue.js devtools</a>，它是 Vue 官方发布的一款调试 Vue 项目的插件，支持数据模拟与调试。相信从事过 Vue 项目开发的同学都已经把它收入在自己的工具库中了，它的界面如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655c88fb776ea32?w=1036&h=391&f=png&s=67198" alt></p><p>成功安装它之后，在 Vue 项目的页面中我们可以打开 Chrome 控制台选择 Vue 的 tab 进行页面调试。</p><h3 id="Vue-Performance-Devtool"><a href="#Vue-Performance-Devtool" class="headerlink" title="Vue Performance Devtool"></a>Vue Performance Devtool</h3><p>在《Vue API 盲点解析》章节我们已经介绍了 <a href="https://chrome.google.com/webstore/detail/vue-performance-devtool/koljilikekcjfeecjefimopfffhkjbne" target="_blank" rel="noopener">Vue Performance Devtool</a> 这款插件，它可以分析我们页面中各个组件的性能情况，从而在其基础上我们可以有针对性的对组件的代码进行优化，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655c94f6dc46001?w=1100&h=146&f=png&s=49934" alt></p><p>同样安装完毕后，我们可以打开 Chrome 控制台选择 <code>Vue Performance</code> 的 tab 进行组件的性能观察。</p><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p><a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en" target="_blank" rel="noopener">Postman</a> 相信大家都比较熟悉，它是一款非常好用的接口调试工具。在 Vue 项目开发中，我们或多或少需要对后台提供的接口进行测试，比如传递数据并查看返回结果等，这时候使用 Postman 便可以完成这些任务。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655cfc5e3d6690d?w=1080&h=589&f=png&s=129723" alt></p><p>Postman 会当作 Chrome 应用程序安装到你的电脑上，打开后我们可以选择请求方式（GET／POST），输入请求 URL 以及设置传递参数来进行接口的调用。</p><h3 id="Web-Developer"><a href="#Web-Developer" class="headerlink" title="Web Developer"></a>Web Developer</h3><p><a href="https://chrome.google.com/webstore/detail/web-developer/bfbameneiokkgbdmiekhjnmfkcnldhhm" target="_blank" rel="noopener">Web Developer</a> 是一款强大的用于操作网页中各项资源与浏览器的插件，比如一键禁用 JS、编辑 CSS、清除 Cookie 等。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655cc3216d01a59?w=814&h=154&f=png&s=48981" alt></p><p>虽然说一些功能我们也可以在 Chrome 控制台实现，但其提供的快捷键能够十分方便的让我们在页面中操作某些资源。</p><h3 id="Google-PageSpeed-Insights-API-Extension"><a href="#Google-PageSpeed-Insights-API-Extension" class="headerlink" title="Google PageSpeed Insights API Extension"></a>Google PageSpeed Insights API Extension</h3><p>PageSpeed Insights (PSI) 是 <code>Google</code> 在全球范围内应用最广的开发者工具之一，其中文网页版 <a href="developers.google.cn/speed/pagespeed/insights/">developers.google.cn/speed/pagespeed/insights/</a> 也已经发布。作为一款专注于改进网页性能的开发者工具，它主要具有以下两个优势：<strong>真实的网页运行速度</strong> 及 <strong>优化建议</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655d1231520ea25?w=1081&h=576&f=png&s=70403" alt></p><p>为了便于使用，我们可以直接下载 Chrome 插件 <a href="https://chrome.google.com/webstore/detail/google-pagespeed-insights/hfebkooaidmeboeblkkejdoepilnnjhn" target="_blank" rel="noopener">Google PageSpeed Insights API Extension</a> 来对当前访问网址进行测试和分析。</p><h3 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a>FeHelper</h3><p>FeHelper 是百度 FE 团队开发的一款前端工具集插件，包含代码压缩／性能检测／字符串编解码等功能，能够帮助我们完成一些琐碎的开发任务。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655d245e1bd2730?w=1220&h=633&f=png&s=200978" alt></p><p>FeHelper 为我们提供了十多种快捷功能，在需要的时候我们直接点击插件图标选择对应功能即可，操作起来十分便捷。</p><h3 id="Can-I-Use"><a href="#Can-I-Use" class="headerlink" title="Can I Use"></a>Can I Use</h3><p><a href="https://chrome.google.com/webstore/detail/can-i-use/decehbilpgknnlnkbgkcggjbgjbphljb" target="_blank" rel="noopener">Can I Use</a> 是 <a href="https://caniuse.com/" target="_blank" rel="noopener">https://caniuse.com/</a> 网页版的插件。我们可以使用其来查看某一特性的浏览器支持程度，确保主流浏览器的支持。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/1655d38dca6e9973?w=614&h=596&f=png&s=100486" alt></p><p>使用 Chrome 插件形式的 Can I Use 我们可以快捷的查看项目中用到的某一特性的浏览器支持范围，同时还可以查看支持程度和兼容方式。</p><h3 id="其他实用插件"><a href="#其他实用插件" class="headerlink" title="其他实用插件"></a>其他实用插件</h3><ul><li><a href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc" target="_blank" rel="noopener">JSONView</a> ：一款可以将后台返回的 JSON 字符串数据自动格式化成规范 JSON 格式的插件</li><li><a href="https://chrome.google.com/webstore/detail/whatfont/jabopobgcpjmedljpbcaablpmlmfcogm" target="_blank" rel="noopener">WhatFont</a>：一款可以显示浏览器中选择文字的字体类型／字号／颜色的插件</li><li><a href="https://chrome.google.com/webstore/detail/the-qr-code-extension/oijdcdmnjjgnnhgljmhkjlablaejfeeb" target="_blank" rel="noopener">The QR Code Extension</a>：一款允许当前页面生成二维码，并使用网络摄像头扫描二维码的插件</li><li><a href="https://chrome.google.com/webstore/detail/test-ie/eldlkpeoddgbmpjlnpfblfpgodnojfjl?hl=zh-CN" target="_blank" rel="noopener">Test IE</a>：一款可以模拟 <code>IE</code> 及其他主流浏览器的插件，但大部分模拟场景需要付费才能使用</li><li><a href="https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg" target="_blank" rel="noopener">Wappalyzer</a>：一款查看当前网站使用的前后端技术的插件，帮助你学习和认识优秀网站的技术选型</li><li><a href="https://chrome.google.com/webstore/detail/mobileresponsive-web-desi/elmekokodcohlommfikpmojheggnbelo" target="_blank" rel="noopener">Mobile/Responsive Web Design Tester</a>：一款用于测试页面在不同机型下呈现的插件</li><li><a href="https://chrome.google.com/webstore/detail/resolution-test/idhfcdbheobinplaamokffboaccidbal" target="_blank" rel="noopener">Resolution Test</a>：一款用于测试页面在不同分辨率下呈现的插件</li></ul><p>以上我们介绍了一些非常实用的 chrome 拓展插件来助力我们的前端开发，为项目开发提供了工具解决方案，同时也有助于帮助大家开启以工具为向导的开发模式。</p><h2 id="分析你的包文件"><a href="#分析你的包文件" class="headerlink" title="分析你的包文件"></a>分析你的包文件</h2><p>每当我们使用 webpack 打包项目代码的时候，你可能需要关注一下打包生成的每个 js 文件的大小以及其包含的内容，这对于优化项目打包速度和提升页面加载性能都有十分大的帮助。</p><p>这里我们推荐使用 <a href="https://www.npmjs.com/package/webpack-bundle-analyzer" target="_blank" rel="noopener">webpack-bundle-analyzer</a> 这一款 webpack 插件来进行包文件的分析，下面我们就来介绍下其配置和使用方法。</p><p>首先作为一款需要内置在代码中的开发分析工具，我们需要安装并在 webpack 的 plugins 中添加该插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#  安装命令</span><br><span class="line">yarn add webpack-bundle-analyzer --dev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin</span><br><span class="line"></span><br><span class="line">const isPro = process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">    </span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        if (isPro) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                </span><br><span class="line">                    // 使用包分析工具</span><br><span class="line">                    new BundleAnalyzerPlugin()</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在生产环境下打包便可以在浏览器 8888 端口（默认）下打开页面进行包文件的分析，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/22/16561c54b9091a30?w=1432&h=696&f=png&s=212348" alt></p><p>图中区域内包含了我们打包出的所有 js 文件，我们可以以不同的颜色进行区分，同时我们也可以点击某一区块进行放大观察，以此来分析是否存在较大或重复的模块。而在页面左侧存在一个筛选面板，在该面板中我们能勾选需要查看的文件来进行显示，同时也可以切换查看原始、普通及 <code>GZIP</code> 压缩模式下的文件大小。</p><p>使用好 webpack-bundle-analyzer 工具我们可以快速的找到需要合并的模块，解决文件冗余，为资源优化提供可行性方案。</p><h2 id="调试移动端页面"><a href="#调试移动端页面" class="headerlink" title="调试移动端页面"></a>调试移动端页面</h2><p>除了 Chrome 插件及打包分析工具的介绍外，我们再来了解下移动端页面的调试工具。相比 PC 端调试，移动端调试可能稍微复杂一点，但是只要熟练的使用好 “工具” 这一东西，我们同样可以在移动端的世界中游刃有余。</p><p>作为一名 <code>Mac</code> 及 <code>iOS</code> 用户，这里我主要介绍在 <code>iPhone</code> 手机中调试页面的方法，当然最后也会简单介绍一下 <code>Android</code> 手机页面的调试方法。</p><p>首先我们得具备这些工具：iPhone 手机一部、数据线一条、Mac 电脑一台。在满足以上要求后我们需要把手机通过数据线连接上 Mac 电脑，连接完毕后便可以进行如下步骤的设置：</p><h4 id="1-打开苹果手机的-Web-检查器-（设置-gt-Safari浏览器-gt-高级-gt-Web检查器），一般情况下默认是开启的"><a href="#1-打开苹果手机的-Web-检查器-（设置-gt-Safari浏览器-gt-高级-gt-Web检查器），一般情况下默认是开启的" class="headerlink" title="1. 打开苹果手机的 Web 检查器 （设置 &gt; Safari浏览器 &gt; 高级 &gt; Web检查器），一般情况下默认是开启的"></a>1. 打开苹果手机的 <code>Web 检查器</code> （设置 &gt; Safari浏览器 &gt; 高级 &gt; Web检查器），一般情况下默认是开启的</h4><h4 id="2-打开-Mac-上的-Safari-的-“开发”菜单，一般情况下默认是开启的"><a href="#2-打开-Mac-上的-Safari-的-“开发”菜单，一般情况下默认是开启的" class="headerlink" title="2. 打开 Mac 上的 Safari 的 “开发”菜单，一般情况下默认是开启的"></a>2. 打开 Mac 上的 <code>Safari</code> 的 <code>“开发”菜单</code>，一般情况下默认是开启的</h4><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/1656272c36a04d93?w=747&h=456&f=png&s=94105" alt></p><h4 id="3-在手机-Safari-浏览器中打开你需要调试的页面"><a href="#3-在手机-Safari-浏览器中打开你需要调试的页面" class="headerlink" title="3. 在手机 Safari 浏览器中打开你需要调试的页面"></a>3. 在手机 Safari 浏览器中打开你需要调试的页面</h4><h4 id="4-在-Mac-Safari-浏览器中选择你需要调试的页面（开发-gt-你的-iPhone-gt-你的页面地址）"><a href="#4-在-Mac-Safari-浏览器中选择你需要调试的页面（开发-gt-你的-iPhone-gt-你的页面地址）" class="headerlink" title="4. 在 Mac Safari 浏览器中选择你需要调试的页面（开发 &gt; 你的 iPhone &gt; 你的页面地址）"></a>4. 在 Mac Safari 浏览器中选择你需要调试的页面（开发 &gt; 你的 iPhone &gt; 你的页面地址）</h4><h4 id="5-点击地址后弹出如图所示的控制台，你便可以在该控制台中进行调试了"><a href="#5-点击地址后弹出如图所示的控制台，你便可以在该控制台中进行调试了" class="headerlink" title="5. 点击地址后弹出如图所示的控制台，你便可以在该控制台中进行调试了"></a>5. 点击地址后弹出如图所示的控制台，你便可以在该控制台中进行调试了</h4><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/165627afd786c2d0?w=1084&h=593&f=png&s=178346" alt></p><p>最后你可以针对你的移动端页面进行断点调试、操作缓存、查看网络及资源等，帮助你快速的定位和解决问题。</p><p>而在 Android 手机中，我们同样可以对移动端页面进行调试，主要不同点在于 IOS 使用的工具是 iPhone 和 Mac，Android 使用的工具主要是 Android 手机和 Windows 系统罢了（Mac 也可以使用模拟器），当然还需要借助 Chrome 的帮助。</p><p>这里主要介绍一下 Chrome 中的 <code>inspect</code>，我们可以在 Chrome 地址栏输入：<code>chrome://inspect/</code> 来捕获手机访问的页面地址，前提是你的 Android 手机通过数据线连接上了电脑并开启了相应权限，最后获取到的地址会在 <code>Remote Target</code> 中显示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/23/165628f25bf53e10?w=1073&h=325&f=png&s=51054" alt></p><p>点击相应的地址会弹出一个控制台，你可以在该控制台中进行页面的调试。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了 Vue 项目开发时常用的 Chrome 插件、包分析工具以及移动端调试工具，这些开发工具的使用能够帮助我们快速的定位项目中出现的一些疑难杂症，而唯有 “用正确的工具，做正确的事情” 才能有效的彰显工具对于项目开发和维护的重要性，使我们的工具库能够发挥它真正的价值。</p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p><code>webpack-bundle-analyzer</code> 有哪些配置项？分别有什么作用？</p></li><li><p>除了本文介绍的开发工具外，还有哪些比较实用的开发工具？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发指南篇 5：Vue API 盲点解析</title>
      <link href="/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%205%EF%BC%9AVue%20API%20%E7%9B%B2%E7%82%B9%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/09/07/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E7%AF%87%205%EF%BC%9AVue%20API%20%E7%9B%B2%E7%82%B9%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="开发指南篇-5：Vue-API-盲点解析"><a href="#开发指南篇-5：Vue-API-盲点解析" class="headerlink" title="开发指南篇 5：Vue API 盲点解析"></a>开发指南篇 5：Vue API 盲点解析</h1><p>在了解了一些实用的开发技巧和编码理念后，我们在项目的开发过程中难免也会遇到因为不熟悉 Vue API 而导致的技术问题，而往往就是这样的一些问题消耗了我们大量的开发时间，造成代码可读性下降、功能紊乱甚至 <code>bug</code> 量的增加，其根本原因还是自己对 Vue API 的 “<strong>无知</strong>”。</p><p>本文将介绍 Vue 项目开发中比较难以理解并可能被你忽视的 API，唯有知己知彼，才能百战不殆。</p><h2 id="API-解析"><a href="#API-解析" class="headerlink" title="API 解析"></a>API 解析</h2><h3 id="使用-performance-开启性能追踪"><a href="#使用-performance-开启性能追踪" class="headerlink" title="使用 performance 开启性能追踪"></a>使用 performance 开启性能追踪</h3><p><code>performance API</code> 是 Vue 全局配置 API 中的一个，我们可以使用它来进行网页性能的追踪，我们可以在入口文件中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    Vue.config.performance = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来开启这一功能，该 API（2.2.0 新增）功能只适用于开发模式和支持 <code>performance.mark</code> API 的浏览器上，开启后我们可以下载 <a href="https://chrome.google.com/webstore/search/vue%20performance%20devtool" target="_blank" rel="noopener">Vue Performance Devtool</a> 这一 chrome 插件来看查看各个组件的加载情况，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/7/165100a377b1bac9?w=1094&h=150&f=png&s=42871" alt></p><p>从中我们可以清晰的看到页面组件在每个阶段的耗时情况，而针对耗时比较久的组件，我们便可以对其进行相应优化。</p><p>而其在 Vue 源码中主要使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">window.performance</a> 来获取网页性能数据，其中包含了 <code>performance.mark</code> 和 <code>performance.measure</code>。</p><ul><li>performance.mark 主要用于创建标记</li><li>performance.measure 主要用于记录两个标记的时间间隔</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">performance.mark(&apos;start&apos;); // 创建 start 标记</span><br><span class="line">performance.mark(&apos;end&apos;); // 创建 end 标记</span><br><span class="line"></span><br><span class="line">performance.measure(&apos;output&apos;, &apos;start&apos;, &apos;end&apos;); // 计算两者时间间隔</span><br><span class="line"></span><br><span class="line">performance.getEntriesByName(&apos;output&apos;); // 获取标记，返回值是一个数组，包含了间隔时间数据</span><br></pre></td></tr></table></figure><p>熟练的使用 performance 我们可以查看并分析网页的很多数据，为我们项目优化提供保障。除了上述介绍的两个方法，我们还可以使用 <code>performance.timing</code> 来计算页面各个阶段的加载情况，关于 performance.timing 的介绍可以查看我之前写的一篇文章：<a href="https://www.cnblogs.com/luozhihao/p/4681564.html" target="_blank" rel="noopener">利用 Navigation Timing 测量页面加载时间</a></p><h3 id="使用-errorHandler-来捕获异常"><a href="#使用-errorHandler-来捕获异常" class="headerlink" title="使用 errorHandler 来捕获异常"></a>使用 errorHandler 来捕获异常</h3><p>在浏览器异常捕获的方法上，我们熟知的一般有：<code>try ... catch</code> 和 <code>window.onerror</code>，这也是原生 JavaScript 提供给我们处理异常的方式。但是在 Vue 2.x 中如果你一如既往的想使用 window.onerror 来捕获异常，那么其实你是捕获不到的，因为异常信息被框架自身的异常机制捕获了，你可以使用 <code>errorHandler</code> 来进行异常信息的获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = function (err, vm, info) &#123;</span><br><span class="line">    let &#123; </span><br><span class="line">        message, // 异常信息</span><br><span class="line">        name, // 异常名称</span><br><span class="line">        stack  // 异常堆栈信息</span><br><span class="line">    &#125; = err;</span><br><span class="line"></span><br><span class="line">    // vm 为抛出异常的 Vue 实例</span><br><span class="line">    // info 为 Vue 特定的错误信息，比如错误所在的生命周期钩子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在入口文件中加入上述代码后，我们便可以捕获到 Vue 项目中的一些异常信息了，但是需要注意的是 Vue 2.4.0 起的版本才支持捕获 Vue 自定义事件处理函数内部的错误，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;my-component @eventFn=&quot;doSomething&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        doSomething() &#123;</span><br><span class="line">            console.log(a); // a is not defined</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用 Vue 中的异常捕获机制，我们可以针对捕获到的数据进行分析和上报，为实现前端异常监控奠定基础。关于对异常捕获的详细介绍，感兴趣的同学可以查看我的这篇文章：<a href="https://www.cnblogs.com/luozhihao/p/8635507.html" target="_blank" rel="noopener">谈谈前端异常捕获与上报</a></p><h3 id="使用-nextTick-将回调延迟到下次-DOM-更新循环之后执行"><a href="#使用-nextTick-将回调延迟到下次-DOM-更新循环之后执行" class="headerlink" title="使用 nextTick 将回调延迟到下次 DOM 更新循环之后执行"></a>使用 nextTick 将回调延迟到下次 DOM 更新循环之后执行</h3><p>在某些情况下，我们改变页面中绑定的数据后需要对新视图进行一些操作，而这时候新视图其实还未生成，需要等待 DOM 的更新后才能获取的到，在这种场景下我们便可以使用 nextTick 来延迟回调的执行。比如未使用 <code>nextTick</code> 时的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul ref=&quot;box&quot;&gt;</span><br><span class="line">        &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;index&quot;&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            arr: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">    this.getData();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getData() &#123;</span><br><span class="line">            this.arr = [1, 2, 3];</span><br><span class="line">            this.$refs.box.getElementsByTagName(&apos;li&apos;)[0].innerHTML = &apos;hello&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上方代码我们在实际运行的时候肯定会报错，因为我们获取 DOM 元素 li 的时候其还未被渲染，我们将方法放入 nextTick 回调中即可解决该问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">    this.$refs.box.getElementsByTagName(&apos;li&apos;)[0].innerHTML = &apos;hello&apos;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然你也可以使用 ES6 的 <code>async/await</code> 语法来改写上述方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    async getData() &#123;</span><br><span class="line">        this.arr = [1, 2, 3];</span><br><span class="line">        </span><br><span class="line">        await this.$nextTick();</span><br><span class="line">        </span><br><span class="line">        this.$refs.box.getElementsByTagName(&apos;li&apos;)[0].innerHTML = &apos;hello&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来我们来分析下 Vue 是如何做到的，其源码中使用了 3 种方式：</p><ul><li>promise.then 延迟调用</li><li>setTimeout(func, 0) 延迟功能</li><li>MutationObserver 监听变化</li></ul><p>前两种方式相信大家都比较熟悉，其都具备延迟执行的功能，我们也可以直接替换 nextTick 为这两种方式中的一种，同样可以解决问题。这里主要介绍下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a> 这一 HTML5 新特性，那么什么是 <code>MutationObserver</code> 呢？用一句话介绍就是：我们可以使用它创建一个观察者对象，其会监听某个 DOM 元素，并在它的 DOM 树发生变化时执行我们提供的回调函数。实例化代码及配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 传入回调函数进行实例化</span><br><span class="line">var observer = new MutationObserver(mutations =&gt; &#123;</span><br><span class="line">    mutations.forEach(mutation =&gt; &#123;</span><br><span class="line">        console.log(mutation.type);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 选择目标节点</span><br><span class="line">var target = document.querySelector(&apos;#box&apos;);</span><br><span class="line"> </span><br><span class="line">// 配置观察选项</span><br><span class="line">var config = &#123; </span><br><span class="line">    attributes: true, // 是否观察属性的变动</span><br><span class="line">    childList: true, // 是否观察子节点的变动（指新增，删除或者更改）</span><br><span class="line">    characterData: true // 是否观察节点内容或节点文本的变动</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 传入目标节点和观察选项</span><br><span class="line">observer.observe(target, config);</span><br><span class="line"> </span><br><span class="line">// 停止观察</span><br><span class="line">observer.disconnect();</span><br></pre></td></tr></table></figure><p>这样我们便可以观察 id 为 box 下的 DOM 树变化，一旦发生变化就会触发相应的回调方法，实现延迟调用的功能。</p><h3 id="使用-watch-的深度遍历和立即调用功能"><a href="#使用-watch-的深度遍历和立即调用功能" class="headerlink" title="使用 watch 的深度遍历和立即调用功能"></a>使用 watch 的深度遍历和立即调用功能</h3><p>相信很多同学使用 <code>watch</code> 来监听数据变化的时候通常只使用过其中的 <code>handler</code> 回调，其实其还有两个参数，便是：</p><ul><li>deep 设置为 true 用于监听对象内部值的变化</li><li>immediate 设置为 true 将立即以表达式的当前值触发回调</li></ul><p>我们来看下代码中的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;obj.a = 2&quot;&gt;修改&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            obj: &#123;</span><br><span class="line">                a: 1,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            handler: function(newVal, oldVal) &#123;</span><br><span class="line">                console.log(newVal); </span><br><span class="line">            &#125;,</span><br><span class="line">            deep: true,</span><br><span class="line">            immediate: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上代码我们修改了 obj 对象中 a 属性的值，我们可以触发其 watch 中的 handler 回调输出新的对象，而如果不加 <code>deep: true</code>，我们只能监听 obj 的改变，并不会触发回调。同时我们也添加了 <code>immediate: true</code> 配置，其会立即以 obj 的当前值触发回调。</p><p>在 Vue 源码中，主要使用了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty (obj, key, option)</a> 方法来实现数据的监听，同时其也是 Vue 数据双向绑定的关键方法之一。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Observer() &#123;</span><br><span class="line">    var result = null;</span><br><span class="line">    </span><br><span class="line">    Object.defineProperty(this, &apos;result&apos;, &#123;</span><br><span class="line">        get: function() &#123;</span><br><span class="line">            console.log(&apos;你访问了 result&apos;);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function(value) &#123;</span><br><span class="line">            result = value;</span><br><span class="line">            console.log(&apos;你设置了 result = &apos; + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var app = new Observer(); // 实例化</span><br><span class="line"></span><br><span class="line">app.result; // 你访问了 result</span><br><span class="line">app.result = 11; // 你设置了 result = 11</span><br></pre></td></tr></table></figure><p>我们通过实例化了 <code>Observer</code> 方法来实现了一个简单的监听数据访问与变化的功能。<code>Object.defineProperty</code> 是 ES5 的语法，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的主要原因。</p><h3 id="对低开销的静态组件使用-v-once"><a href="#对低开销的静态组件使用-v-once" class="headerlink" title="对低开销的静态组件使用 v-once"></a>对低开销的静态组件使用 v-once</h3><p>Vue 提供了 <code>v-once</code> 指令用于只渲染元素和组件一次，一般可以用于存在大量静态数据组件的更新性能优化，注意是大量静态数据，因为少数情况下我们的页面渲染会因为一些静态数据而变慢。如果你需要对一个组件使用 v-once，可以直接在组件上绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-once :data=&quot;msg&quot;&gt;&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><p>这时候因为组件绑定了 v-once，所以无论 msg 的值如何变化，组件内渲染的永远是其第一次获取到的初始值。因此我们在使用 v-once 的时候需要考虑该组件今后的更新情况，避免不必要的问题产生。</p><h3 id="使用-isServer-判断当前实例是否运行于服务器"><a href="#使用-isServer-判断当前实例是否运行于服务器" class="headerlink" title="使用 $isServer 判断当前实例是否运行于服务器"></a>使用 $isServer 判断当前实例是否运行于服务器</h3><p>当我们的 Vue 项目中存在服务端渲染（SSR）的时候，有些项目文件可能会同时在客户端和服务端加载，这时候代码中的一些客户端浏览器才支持的属性或变量在服务端便会加载出错，比如 window、 document 等，这时候我们需要进行环境的判断来区分客户端和服务端，如果你不知道 <code>$isServer</code>，那么你可能会使用 <code>try ... catch</code> 或者 <code>process.env.VUE_ENV</code> 来判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    document.title = &apos;test&apos;;</span><br><span class="line">&#125; catch(e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// process.env.VUE_ENV 需要在 webpack 中进行配置</span><br><span class="line">if (process.env.VUE_ENV === &apos;client&apos;) &#123;</span><br><span class="line">    document.title = &apos;test&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而使用 $isServer 则无需进行配置，在组件中直接使用该 API 即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (this.$isServer) &#123;</span><br><span class="line">    document.title = &apos;test&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其源码中使用了 <code>Object.defineProperty</code> 来进行数据监测：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Vue.prototype, &apos;$isServer&apos;, &#123;</span><br><span class="line">    get: isServerRendering</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var _isServer;</span><br><span class="line">var isServerRendering = function () &#123;</span><br><span class="line">    if (_isServer === undefined) &#123;</span><br><span class="line">        if (!inBrowser &amp;&amp; !inWeex &amp;&amp; typeof global !== &apos;undefined&apos;) &#123;</span><br><span class="line">            _isServer = global[&apos;process&apos;].env.VUE_ENV === &apos;server&apos;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _isServer = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return _isServer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们访问 $isServer 属性时，其会调用 <code>isServerRendering</code> 方法，该方法会首先判断当前环境，如果在浏览器或者 Weex 下则返回 false，否则继续判断当前全局环境下的 <code>process.env.VUE_ENV</code> 是否为 server 来返回最终结果。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>每一门语言、一个框架都有其 API 文档，在 Vue 的项目开发过程中，很多时候当你一筹莫展之际，你可以尝试浏览一下 Vue 的 API 列表，或许你就会柳暗花明。</p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>使用 watch 监听某一值时，同时修改该值两次会触发几次 watch 回调？</p></li><li><p>使用 <code>errorHandler</code> 捕获异常堆栈后如何解析 <code>source-map</code> 信息？</p></li><li><p>除了本文介绍的 Vue 盲点外，还有哪些需要注意并容易忽略的 API？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇：Vue CLI 3 项目构建基础</title>
      <link href="/2018/09/07/%E5%BC%80%E7%AF%87%EF%BC%9AVue%20CLI%203%20%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/09/07/%E5%BC%80%E7%AF%87%EF%BC%9AVue%20CLI%203%20%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="开篇：Vue-CLI-3-项目构建基础"><a href="#开篇：Vue-CLI-3-项目构建基础" class="headerlink" title="开篇：Vue CLI 3 项目构建基础"></a>开篇：Vue CLI 3 项目构建基础</h1><p>大家好，当你点进这个标题，开始阅读本章的时候，说明你对 <code>Vue.js</code> 是充满好奇心和求知欲的。我之前写过一篇文章，这样评价 Vue.js，称它是“简单却不失优雅，小巧而不乏大匠”的作品，正如其官网介绍的“易用，灵活和高效”那样。其实框架是 Vue.js 的本质，而真正了解它的人则会把它当成一件作品来欣赏。</p><p>Vue.js 作为一门轻量级、易上手的前端框架，从入门难度和学习曲线上相对其他框架来说算是占据优势的，越来越多的人开始投入 Vue.js 的怀抱，走进 Vue.js 的世界。那么接下来屏幕前的你不妨一起来和我从零开始构建一个 Vue 项目，体会一下 Vue.js 的精彩绝伦。</p><h2 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h2><p>在构建一个 Vue 项目前，我们先要确保你本地安装了 <code>Node</code> 环境以及包管理工具 <code>npm</code>，打开终端运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看 node 版本</span><br><span class="line">node -v</span><br><span class="line"></span><br><span class="line"># 查看 npm 版本</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>如果成功打印出版本号，说明你本地具备了 node 的运行环境，我们可以使用 npm 来安装管理项目的依赖，而如果没有或报错，则你需要去 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">node 官网</a>进行 node 的下载及安装，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/31/166c5eb2c6f04593?w=575&h=197&f=png&s=29269" alt></p><p>左边的版本是推荐安装的稳定版本，也就是目前已经被正式列入标准的版本，而右边的版本是当前最新的版本，该版本包含了一些新的特性，还未被完全列入标准，可能以后会有所变动。这里建议大家安装最新的 node 稳定版进行开发。</p><h2 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h2><p>当我们安装完 node 后便可以开始进行后续的构建工作了，那么这里我主要给大家介绍下最便捷的脚手架构建。</p><h3 id="1-什么是脚手架"><a href="#1-什么是脚手架" class="headerlink" title="1. 什么是脚手架"></a>1. 什么是脚手架</h3><p>很多人可能经常会听到“脚手架”三个字，无论是前端还是后台，其实它在生活中的含义是为了保证各施工过程顺利进行而搭设的工作平台。因此作为一个工作平台，前端的脚手架可以理解为能够帮助我们快速构建前端项目的一个工具或平台。</p><h3 id="2-vue-cli"><a href="#2-vue-cli" class="headerlink" title="2. vue-cli"></a>2. vue-cli</h3><p>其实说到脚手架，目前很多主流的前端框架都提供了各自官方的脚手架工具，以帮助开发者快速构建起自己的项目，比如 <code>Vue</code>、<code>React</code> 等，这里我们就来介绍下 Vue 的脚手架工具 <code>vue-cli</code>。</p><p>vue-cli 经历了几个版本的迭代，目前最新的版本是 3.x，也是本小册构建项目所使用的版本，我们一起来看下其人性化的构建流程：</p><h4 id="a-安装"><a href="#a-安装" class="headerlink" title="a. 安装"></a>a. 安装</h4><p>我们可以在终端通过以下命令全局安装 vue-cli：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装 Vue CLI 3.x</span><br><span class="line">npm i -g @vue/cli</span><br></pre></td></tr></table></figure><p>如果你习惯使用 <code>yarn</code>，你也可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 没有全局安装yarn需执行此命令</span><br><span class="line">npm i -g yarn</span><br><span class="line">yarn global add @vue/cli</span><br></pre></td></tr></table></figure><p>注意因为是全局安装，所以 vue-cli 是全局的包，它和我们所处的项目没有关系。同时我们这里介绍的 CLI 版本是最新的 3.x，它和 2.x 版本存在着很大的区别，具体的讲解会在后续章节中进行介绍。</p><h4 id="b-构建"><a href="#b-构建" class="headerlink" title="b. 构建"></a>b. 构建</h4><p>安装完 vue-cli 后，我们在你想要创建的项目目录地址下执行构建命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># my-project 是你的项目名称</span><br><span class="line">vue create my-project</span><br></pre></td></tr></table></figure><p>执行完上述命令后，会出现一系列的选择项，我们可以根据自己的需要进行选择，流程图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/16412343fab2e351?w=980&h=634&f=png&s=57073" alt></p><p>如果你只想构建一个基础的 Vue 项目，那么使用 <code>Babel</code>、<code>Router</code>、<code>Vuex</code>、<code>CSS Pre-processors</code> 就足够了，最后选择你喜欢的包管理工具 npm or yarn。</p><h4 id="c-启动"><a href="#c-启动" class="headerlink" title="c. 启动"></a>c. 启动</h4><p>等待构建完成后你便可以运行命令来启动你的 Vue 项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打开项目目录</span><br><span class="line">cd vue-project</span><br><span class="line"></span><br><span class="line"># 启动项目</span><br><span class="line">yarn serve</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>需要注意的是如果启动的时候出现报错或者包丢失等情况，最好将 node 或者 yarn （如果使用）的版本更新到最新重新构建。</p><p>成功后打开浏览器地址：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 可以看到如下界面：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/18/164125dcfb6fa7d5" alt></p><h4 id="d-目录结构"><a href="#d-目录结构" class="headerlink" title="d. 目录结构"></a>d. 目录结构</h4><p>最后脚手架生成的目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules     # 项目依赖包目录</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico  # ico图标</span><br><span class="line">│   └── index.html   # 首页模板</span><br><span class="line">├── src </span><br><span class="line">│   ├── assets       # 样式图片目录</span><br><span class="line">│   ├── components   # 组件目录</span><br><span class="line">│   ├── views        # 页面目录</span><br><span class="line">│   ├── App.vue      # 父组件</span><br><span class="line">│   ├── main.js      # 入口文件</span><br><span class="line">│   ├── router.js    # 路由配置文件</span><br><span class="line">│   └── store.js     # vuex状态管理文件</span><br><span class="line">├── .gitignore       # git忽略文件</span><br><span class="line">├── .postcssrc.js    # postcss配置文件</span><br><span class="line">├── babel.config.js  # babel配置文件</span><br><span class="line">├── package.json     # 包管理文件</span><br><span class="line">└── yarn.lock        # yarn依赖信息文件</span><br></pre></td></tr></table></figure><p>根据你安装时选择的依赖不同，最后生成的目录结构也会有所差异。</p><h3 id="3-可视化界面"><a href="#3-可视化界面" class="headerlink" title="3. 可视化界面"></a>3. 可视化界面</h3><p>当然，除了使用上述命令行构建外，<code>vue-cli 3.x</code> 还提供了可视化的操作界面，在项目目录下我们运行如下命令开启图形化界面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><p>之后浏览器会自动打开本地 <code>8000</code> 端口，页面如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/26/1643ca037f818a81?w=805&h=396&f=png&s=18543" alt></p><p>如果你还没有任何项目，那么可以点击创建或者直接导入现有的项目。创建项目和我们使用命令行的步骤基本相同，完全可视化操作，一定程度上降低了构建和使用的难度。项目创建或导入成功后你便可以进入项目进行可视化管理了。</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/26/1643ca8799bb4491?w=819&h=397&f=png&s=71058" alt></p><p>在整个管理界面中，我们可以为自己的项目安装 CLI 提供的插件，比如安装 <code>@vue/cli-plugin-babel</code> 插件，同时我们也可以配置相应插件的配置项，进行代码的编译、热更新、检查等。详细的操作大家可以自己进行手动尝试，相信你会发现意想不到的惊喜。</p><h2 id="你还需要了解什么"><a href="#你还需要了解什么" class="headerlink" title="你还需要了解什么"></a>你还需要了解什么</h2><p>上方我们用 vue-cli 成功生成了一个最基础的 Vue 项目，麻雀虽小，五脏俱全，但是想要让麻雀飞起来，我们还要不断的给它进行拓展训练，那么我们还需要了解什么呢？</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/20/165f2c3a9c4f640c?w=665&h=251&f=png&s=21583" alt></p><p>以上这些内容（包含但不限于）将会在本小册的接下来几章进行详细的讲解，你准备好了吗？</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要讲述了使用 vue-cli 脚手架进行 Vue 项目构建的基本知识，从构建的流程中我们不难发现 Vue 提供给了我们一套非常灵活可配置的工具，其小巧而不乏大匠的魅力不言而喻。希望大家能够从构建开始，逐渐领略 Vue.js 的匠心，激发自己的对 Vue 的兴趣。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做好一个开源项目（上篇）</title>
      <link href="/2018/09/07/%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/"/>
      <url>/2018/09/07/%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="拓展：如何做好一个开源项目（上篇）"><a href="#拓展：如何做好一个开源项目（上篇）" class="headerlink" title="拓展：如何做好一个开源项目（上篇）"></a>拓展：如何做好一个开源项目（上篇）</h1><h2 id="iView-的故事"><a href="#iView-的故事" class="headerlink" title="iView 的故事"></a>iView 的故事</h2><p>毕业四年以来，我一直觉得自己是一个很幸运的人，幸运参与过创业，幸运一路有大牛带，幸运开源了 iView 项目。</p><p>2016 年初，我还是一名普通的前端工程师，那时候还是 Vue.js 1.x 的时代，知名度也远不如现在，在大部分人眼中，Vue.js 就是一个轻量级的 Angular。</p><p>我所在的公司是做 to B 业务的，与大部分公司一样，那时主导 jQuery，把 Vue.js 引入团队乃至整个公司，是一件很不易的事，因为不是你自己在用，你要说服所有人用，现在看来，当初的决定是很正确的。如果你有兴趣，欢迎阅读扩展阅读 1，那篇文章详细介绍了我的 Vue.js “推广史”。</p><p>到了 16 年 7 月，我们团队已经完全认可了 Vue.js + Webpack 的技术栈，一直践行至今。一个偶然的机会，公司举办了一个创新大赛，作为可视化团队，我提议做一套自己的组件库。当初也只是一个想法，抱着试试看的态度就报名了。比赛的目的只是呼吁大家创新，后续就没有动作了，但是我没有就此放下，从那时起，几乎全职开发 iView，两年半来，我每天的工作基本就是维护 iView。不得不说，一个成功的开源项目，必须有 leader 的认可和公司的支持，缺一不可。</p><p>那时不比现在，优秀的 Vue.js 组件库非常少，文献更是少得可怜。一开始做 iView 没什么头绪，只是规划了一张 MindNode 脑图，罗列了一期要做的所有组件。这里有一个插曲，因为这张 todo 的脑图有贴在 GitHub 的 Readme，以至于一开始大部分 issues 都是问这个脑图是用什么软件做的，因为做的很好看，索性写了个提问须知，注明了脑图是用 MindNode 制作的。</p><p>起初对开源工作不是很了解，连一个编译工程都搭不起来，想了数日也搞不定。与大部分人一样，一开始也是要参考其它人的开源项目（就像现在很多人参考 iView 是一样的），那是我参考 Vux（移动端的 Vue.js 组件库，当时有 6k star），向作者捐了杯咖啡钱，顺便加了好友（因为是支付宝捐赠，能加好友），请教了工程的问题，这才一步步搭起来，现在想想真是幸运。</p><p>万事开头难，把地基搭好，剩下的都是添砖加瓦的事。差不多 16 年底，iView 一期完成了（43 个组件），也发布了第一个正式版，有了第一批用户（当然，主要还是自己公司），然而在那个时候，又做了一个在今天看来稍晚但正确的决定——支持 Vue.js 2。</p><p>虽然是开源项目，但主要还是先满足自己团队和公司的需求，那个时候所有的项目都是 Vue.js 1.x 的，还没有用 Vue.js 2，但 2.x 已经发布有一段时间了，以至于在 2017 年初，GitHub 有很多 issues 问什么时候支持 2.x。很长一段时间没有升级到 2.x，主要因为要支持公司的项目，而我当时也觉得升级到 2.x 是一个很耗时的工作，就没有支持。后来，有一个人提交了一个非常大的 PR，将所有组件都支持了 2.x，而且只用了一个周末的时间。这件事让我意识到支持 Vue.js 2.x 的重要性了，于是花了 2 周时间研究，并升级到了 2.x（那个 pr 没有直接合并，而是参考，因为很多地方有 bug）。接下来的几个月，都在不断维护新的 iView，使用者也不断增多，社区又重新活跃起来。</p><p>如果当初没有及时转型（现在看来仍然是晚了），还在一味地维护 Vue.js 1.x 版本，那 iView 也许早就完了。有了好的开头，就要不放弃，不抛弃，坚持做下去，认真处理每一个 PR，因为质量是一个开源组件库最重要的，但并不是每一个 PR 都适合 merge，即使作者付出了很多时间提交这个 PR，也会有质量问题。</p><p>有了不错的口碑，在 2018 年继续完善，目前已经是同类产品里功能最丰富的组件库，而且在 18 年的 7 月 28 日（iView 两周年）成功举行了 3.0 发布会，一切都在朝着更好的一面发展着……</p><p>这就是我的 iView 开源的故事，一个成功的开源项目，或许带有一点小幸运，因为如今的同类开源产品已经数不胜数了，不过确实有很多值得分享的地方，如果你打算做一个开源项目，希望下面的些许经验能够帮助到你。</p><h2 id="不要盲目造轮子"><a href="#不要盲目造轮子" class="headerlink" title="不要盲目造轮子"></a>不要盲目造轮子</h2><p>每一个做开源项目的开发者，都是有目的的，如果你做一个开源项目没有任何目的，那你的目的多半是要造个轮子来提升下技术。</p><p>中国当前的开源环境和氛围虽不是很好，“拿来主义”者居多，但相比几年前，已是不错了，更多的人喜欢把自己杰出的代码开源出来。目前多数“正经”的开源项目，都是 KPI 导向的，不能说项目不好，只是一定时间后，可能就不维护了，而开源项目不仅仅要解决问题，持续维护也是观望着最在意的。</p><p>相比 React，Vue.js 的组件库开源项目要多的多，每隔一段时间就能看到几个新的，可能是因为 Vue.js 更容易上手，开发者很活跃。既然已经有这么的同类项目了，那为什么还要持续造轮子呢？因为中国的开发者就是喜欢自己折腾一个，而不是去维护一个现成的。</p><p>就以 Vue.js 组件库的开源现象来说，源源不断的轮子，主要还是市面上已有的组件库不能完全满足自己的业务，主要还是 UI 层面的，单论功能，市面上成熟的组件库足够完善，甚至超出你的业务需求。不好说这种现象是好是坏，好的是从头开发一个组件库，对技术的提升还是有的，它会督促你学习别人的代码，来改良自己的代码，否则造一个还不如别人的轮子也就没意义了。对于公司来说，也有了自己的 UI 组件库和规范（虽然很多只是 fork 后改的），感觉用自己的东西，对内对外都是一件很自豪的事。不好的就是，这是一种程序员向产品或 UI 或 leader 的妥协，因为没办法说服他们使用市面上成熟的组件库，否则，完全可以把造轮子的精力用于维护一个成熟的项目。</p><p>造轮子这个词，似乎成了前端圈的代名词，的确，前端的造轮子能力是极强的，但不能盲目造轮子。如果你只是仿照其它开源项目练习，那就不说了，如果是想认真做一个开源项目，而不是造个轮子玩玩，那一定要构思好你要做的东西。</p><p>一般来说，在决定做一个开源项目前，都是要做市场调研的，你要很清楚的知道，自己做的项目弥补了同类产品的哪些不足，或者有哪些新的特性，因为它们是用户选择你的开源项目的主要依据，否则内容都一样，为什么不选一个成熟的呢。</p><p>如果某个开源项目已经很不错，但你希望基于它进行改造，但不是以 PR 的形式，那你可以在开源协议允许的前提下，fork 后，基于某个 release 独立维护。</p><p>每个开源项目都有一个核心的功能，或是解决用户的核心痛点，比如 iView 就是解决用户建站的问题，相比同类产品，它的特点就是组件丰富程度最高，功能也是最全面的，生态完善，有技术支持渠道。如果你的开源项目解决的问题是其它任何开源项目没有的，那用户很有可能会使用。但对于相同功能的，用户更倾向于选择还在维护的、star 数多的（star 多，说明这个项目的关注度高，更活跃）。所以，在做开源时，你不仅要知道自己产品的核心技术和特性，还要了解市面同类产品，去其糟粕，取其精华，不断更新和修复 bug，逐渐就会获得第一批用户。</p><h2 id="做了东西要用"><a href="#做了东西要用" class="headerlink" title="做了东西要用"></a>做了东西要用</h2><p>虽然我这两年的工作基本全是在维护 iView 开源项目，但偶尔也会穿插做几个项目，因为使用了，才能更好地了解自己的开源项目。</p><p>你可能会问，我每天都在维护 iView，还有我不了解的吗？还真是，维护和使用完全不一样，在开发组件库时，往往只聚焦在某个组件上，我们定义了 API，然后通过文档告诉使用者怎么用，有些功能是实现了，然而维护者只知道提供了这个功能，却不知在实际项目中好不好用，能用和好用是两个概念。</p><p>很多 feature，是自己用了才提炼出来的。比如 iView 的 <a href="https://www.iviewui.com/components/cell" target="_blank" rel="noopener">单元格组件 Cell</a> 和 <a href="https://www.iviewui.com/components/time" target="_blank" rel="noopener">相对时间组件 Time</a>，都是我在做项目时发现并增加的，没有项目的支持，可能觉得这个组件没什么意义，完全应该由使用者在业务里自己写，作为基础组件后，使用体验确实好很多。</p><p>如果你足够重视你的开源项目，应该亲自使用并且安利别人使用来收集反馈，对于组件库来说，细节是很重要的，而很多细节与我们的用户习惯有关，比如 iView 在 3.0 版本开始，对按钮 Button 组件提供了一个新的 props： <code>to</code>，用于指定跳转路径，之前版本如果点击按钮跳转，必须监听它的 <code>@click</code> 事件，然后通过 vue-router 的编程式导航（也就是通过 JS）跳转，如果不亲自使用，绝对不知道这种原先的跳转模式写起来有多麻烦。如果你足够注重细节，这个 Button 组件在跳转时，还应该支持键盘的 Command 键（Windows 为 Ctrl，要做兼容）在新窗口打开链接。这些细节都与使用习惯息息相关，所以，一定要多用用自己的开源项目，在一个个小细节都处理好后，你会的开源项目自然会蒸蒸日上。</p><h2 id="第一批用户"><a href="#第一批用户" class="headerlink" title="第一批用户"></a>第一批用户</h2><p>开源项目做好后，要获得第一批使用者。现在的环境，大多是公司或团队主导做开源，个人的很少，所以你的公司或团队自然就是第一批用户，做开源的主要目的，也是服务他们。</p><p>第一批用户也可以算是开源项目的小白鼠，一开始说服全公司使用，还是比较困难的，可以先小范围推广使用。公司都希望自己的产品稳定，而新的开源项目前期必定会有不少 bug，在经历几个小项目试水后，再尝试向更多的团队推广。因为有了成功案例，又是“自家”的开源项目，给自己人推广还是比较容易的。</p><p>在第一批用户的推广中，你的 leader 可能会起到决定性作用。你的开源项目，八成市场上已经有同类的了，不得不承认，即使让“自己人”做技术选型，也更期望选市面上成熟的，这种情况，就需要你的 leader 出来“拍板”了，否则，你的开源项目也许永远不会有第一批用户来试错。记得当时我在团队推广 Vue.js 时，起初也是很多质疑，有一部分人坚持使用 jQuery + 前端模板，得到 leader 的认可后，试水了几个项目，大家都能感受到 Vue.js 和 webpack 带来的高效开发体验，从此就没人再用 jQuery 了。不过呢，你最好确保你的开源项目质量还不错，否则这锅就得 leader 替你背了。</p><p>与市面上同类成熟的开源项目相比，你的开源项目最大的优势就是你能为第一批用户提供优质的“售后”服务。如果是同事的问题，你可以很快直接解答；如果是通过 GitHub 提交的 issues（前期不会很多了），尽量在半小时内回复，这样使用者会觉得你确实在用心维护这个开源项目。通过前期的口碑积累，你的第一批用户也成为了最忠实的用户，这时可以组建微信或 QQ 群，更直接地提供“售后”，而这第一批忠实用户，会成为后期推广的重要人脉。</p><h2 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h2><p>生态（ecosystem）不是与生俱来的，当你的开源项目有了一定的规模后，可以考虑发展生态体系。比如 iView，起初只是一个组件库，后续逐渐提供了 iview-project 工程、具有 GUI 的 iView CLI（这个概念可比 Vue CLI 3 早了一年）、后台模板 iview-admin、支持 Vue CLI 3 的 vue-cli-plugin-iview，以及业务组件 iview-area 和 markdown 编辑器 iview-editor，再到后来支持 SSR、TS。</p><p>完善的生态体系对于新用户来说，可以最快速搭建产品，减少学习和开发成本；对于观望者（正在决定是否使用的人）来说，更愿意选择生态完善的开源项目。所以，你的开源项目生态越完善，使用者也会越多。</p><p>生态的另一个好处，就是让用户产生依赖。最典型的例子就是 Vue 全家桶，一般刚接触的人，只会用个 Vue.js，再后来 vue-router、vuex 都是必须的了，再后来搭配一个三方的组件库，比如 iView，各种业务都能轻松应对。一旦用户对你的生态足够依赖，就很难更换技术栈了，因为生态的深入，更换成本很大，这也是很多企业的老项目所谓的“历史原因”。</p><p>生态的建设，不一定都是官方的行为，但是最核心的还是要自己维护，用户既然选择你的开源项目，也就意味着信任你的技术实力，放心用你的生态。项目到了一定规模，自然有不少第三方的开发者一起建设生态，这些 contributors 都是最有价值的开发者，尽量联系他们，一起来贡献更多的代码。</p><p>对于 Vue.js 组件库来说，生态一般分为脚手架、后台模板和业务组件。最新的 Vue CLI 3 提供了插件机制，现在的主流做法都是提供一个类似 <a href="https://github.com/iview/vue-cli-plugin-iview" target="_blank" rel="noopener">vue-cli-plugin-iview</a> 的插件，很少有单独提供自己的工程了，在文档里，要推荐使用者用 Vue CLI 3 来管理项目，享受 Vue 的生态。后台模板是开箱即用的，默认配置好了路由、权限管理、多语言、登录等常规的后台系统功能，使用者 down 下来后，稍作修改就能很快开发自己的后台管理系统，主流的 UI 组件库，都会提供自家的后台模板，当然也有第三方专注在做后台模板的。最后一类业务组件，比如城市级联选择器 <a href="https://github.com/iview/iview-area" target="_blank" rel="noopener">iview-area</a>，它基于 iView 的基础组件开发，但又不是基础组件，所以不能归到 iView 里，只能作为独立组件单独维护，业务组件理论上使用者可以自己封装，但是重复性的工作，还是交给社区做吧，这就是开源。</p><p>下一篇，将介绍：</p><ul><li><strong>持续运营</strong></li><li><strong>国际化</strong></li><li><strong>让更多的人参与</strong></li><li><strong>让 Robot 来做“坏人”</strong></li><li><strong>赞助与商业化</strong></li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://juejin.im/post/5880108f8d6d810058ae0def" target="_blank" rel="noopener">2016我的心路历程：从 Vue 到 Webpack 到 iView</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 拓展 </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结篇：写在最后</title>
      <link href="/2018/09/07/%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%9A%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E/"/>
      <url>/2018/09/07/%E6%80%BB%E7%BB%93%E7%AF%87%EF%BC%9A%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="总结篇：写在最后"><a href="#总结篇：写在最后" class="headerlink" title="总结篇：写在最后"></a>总结篇：写在最后</h1><p>看到这里，也就是要和大家说再见的时候了，其实还有很多想和大家分享的内容没能来得及一一阐述，但是没有关系，我相信在今后学习 Vue 的道路上我们永远会保持关注，彼此照应，一起学习，一起进步。</p><p>而正所谓温故而知新，可以为师矣，接下来我们不妨一起回顾下本小册的主要内容。</p><h2 id="回顾与总结"><a href="#回顾与总结" class="headerlink" title="回顾与总结"></a>回顾与总结</h2><p>浏览小册目录，我们可以清楚的将小册的内容归类为构建与开发两部分，这也是本小册所要分享的知识点所在。</p><p>在小册构建部分我们由浅入深的进行了项目构建的学习，在 <code>Vue CLI 3.x</code> 的基础上，从基础构建开始，经历了 <code>npm</code> 与 <code>yarn</code> 的使用、<code>webpack</code> 的配置以及项目环境的注入，最后通过单页应用和多页应用的构建实战来进一步强化大家的认知，并对构建出的项目进行了整合和优化。</p><p>而在小册开发部分，我们主要针对 Vue 项目开发过程中可能遇到的技术点、难点及优化点进行了指南性的介绍，包括了编码技巧与规范、可复用性模块的编写、组件的职能划分、数据驱动的介绍以及 Vue API 的解析等，通过理论结合实战的形式一步步地帮助大家构筑 Vue 开发知识体系。</p><p>相对于偏具体实战性质的书籍，本小册主要偏向理论及应用层面。因为小册没有针对实现某一系统性的功能或项目进行详细的讲解，而是介绍了从无到有开发一个 Vue 基础项目的方法和经验，本着“授人以渔”的宗旨给大家进行应用性质的指南，而至于具体的业务及功能场景，则需要大家自己去填充。</p><h2 id="进阶与提升"><a href="#进阶与提升" class="headerlink" title="进阶与提升"></a>进阶与提升</h2><p>由于本小册定位是一本入门提升级的书籍，很多底层和原理性的知识都没能够在此详细介绍，如果你看完本小册并已经充分掌握了小册中的知识体系，或许接下来你可能有点迷茫，不知道下一步该如何完善自己的项目。不用担心，你可以按照下图的知识路线进一步提升自己，将一个纯前端的项目发展为由<strong>前端 —— 中间层</strong>组成的真正前后端分离的项目，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/26/166b1039eecd39a9?w=1058&h=326&f=png&s=67040" alt></p><p>本小册讲解的是上图中纯前端部分的内容，而所谓的 Node 中间层其实就是处于前端数据请求与后台响应渲染中间位置的架构，它是运行在服务端的，可以帮助我们启动脱离于后台项目的前端服务并实现数据的中转处理与页面渲染等功能。</p><p>这里我们需要了解 Node.js 的 Web 开发框架 <a href="https://github.com/koajs/koa" target="_blank" rel="noopener">Koa</a>（或者 <a href="https://github.com/expressjs/express" target="_blank" rel="noopener">Express</a>）, 你可以尝试使用 Koa 项目脚手架 <a href="https://github.com/17koa/koa-generator" target="_blank" rel="noopener">koa-generator</a> 来实现一个简单的中间层项目。</p><p>在我们的 Vue 项目中，我们通过 webpack 打包在 dist 目录下输出了用于生产环境的静态文件，那么这些静态文件最后哪里会使用它们？其实我们可以通过启动 Node 服务来进行加载并渲染入口 html，也就是最终我们将这些文件放在服务器上运行的效果。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/1/166cafe8fabd52d3?w=767&h=135&f=jpeg&s=29669" alt></p><p>当然中间层的作用远不止渲染我们打包后的页面这么简单，通过添加一些 <code>middleware</code>（中间件）我们可以将客户端的一些功能转移到服务端处理，比如登录验证、用户信息获取、路由重定向以及各页面业务逻辑的封装等。感兴趣的同学可以以此为进阶和提升的下一个目标。</p><h2 id="作者寄语"><a href="#作者寄语" class="headerlink" title="作者寄语"></a>作者寄语</h2><p>文森特·梵高曾经说过：“不要吹灭你的灵感和你的想象力; 不要成为你的模型的奴隶。” 看完本小册，你可能并没有学到什么，但是我希望你能发现什么，发现自己的灵感，发挥自己的想象力去继续深挖填充小册中介绍的内容，永远不要止步于当下，你还有很多东西需要去学习。</p><p>我们应该抱着玩的心态的去尝试各种新鲜的技术，然后回归运用到应用中去，毕竟世界那么大，每一个 <code>Hello Wrold</code> 实战都是你打开未知大门的钥匙。</p><p>有些时候你花了时间去学习，但是最后总会茫然的感觉自己并没有收获任何实际性的东西，其实你忽略了自己的思想，忽略了思想上的提升。就好比有些人上了四年大学，当他回望大学生涯的时候会发现大学并没有教会他什么，但却给了他一种思想，而这种思想正塑造了自己的人生。</p><p>Vue 的学习并非一朝一夕就能完成的，不要吝啬自己的学习时间，也不要局限于 Vue 本身，因为所有知识都是融会贯通的，当你学会了 <code>React</code> 的时候再来看看 Vue 的文档，或许也会有一种似曾相识的亲切感。</p><p>最后，愿自己码梦为生，笔耕不辍；愿你码到成功，初心不改。</p><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>如果你喜欢我的文章并想继续关注“劳卜”我的话，可以扫一扫下方的二维码关注我的微信公众号「前端呼啦圈」，第一时间获取我的原创推送。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/27/166b60f778687af7?w=200&h=200&f=png&s=26718" alt></p><p>同时也可以关注我的博客：<a href="http://www.cnblogs.com/luozhihao/" target="_blank" rel="noopener">http://www.cnblogs.com/luozhihao/</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 的精髓——组件</title>
      <link href="/2018/09/07/%E5%BC%80%E7%AF%87%EF%BC%9AVue.js%20%E7%9A%84%E7%B2%BE%E9%AB%93%E2%80%94%E2%80%94%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/09/07/%E5%BC%80%E7%AF%87%EF%BC%9AVue.js%20%E7%9A%84%E7%B2%BE%E9%AB%93%E2%80%94%E2%80%94%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="开篇：Vue-js-的精髓——组件"><a href="#开篇：Vue-js-的精髓——组件" class="headerlink" title="开篇：Vue.js 的精髓——组件"></a>开篇：Vue.js 的精髓——组件</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Vue.js，无疑是当下最火热的前端框架 _Almost_，而 Vue.js 最精髓的，正是它的组件与组件化。写一个 Vue 工程，也就是在写一个个的组件。</p><p>业务场景是千变万化的，而不变的是 Vue.js 组件开发的核心思想和使用技巧，掌握了 Vue.js 组件的各种开发模式，再复杂的业务场景也可以轻松化解。本小册则着重介绍笔者在 3 年的 Vue.js 开发及两年的 <a href="https://github.com/iview/iview" target="_blank" rel="noopener">iView</a> 开源中积累和沉淀的对 Vue.js 组件的见解和经验。</p><p>本小册<strong>不会</strong>介绍 Vue.js 的基础用法，因为市面上已经沉淀了大量的相关技术资料，而且 Vue.js 的文档已经足够详细。如果您尚未接触 Vue.js 或正打算开始了解，推荐您先阅读笔者出版的<a href="https://item.jd.com/12215519.html" target="_blank" rel="noopener">《Vue.js 实战》</a>（清华大学出版社）一书，它适合刚接触 Vue.js 的开发者。因此，本小册适合已经了解或使用过 Vue.js 的开发者。</p><p>这一节，我们先笼统地聊聊 Vue.js 组件和组件化以及本小册各章节的梳理。</p><h2 id="组件的分类"><a href="#组件的分类" class="headerlink" title="组件的分类"></a>组件的分类</h2><p>一般来说，Vue.js 组件主要分成三类：</p><ol><li><p>由 <code>vue-router</code> 产生的每个页面，它本质上也是一个组件（.vue），主要承载当前页面的 HTML 结构，会包含数据获取、数据整理、数据可视化等常规业务。整个文件相对较大，但一般不会有 <code>props</code> 选项和 <code>自定义事件</code>，因为它作为路由的渲染，不会被复用，因此也不会对外提供接口。</p><p>在项目开发中，我们写的大部分代码都是这类的组件（页面），协同开发时，每人维护自己的页面，很少有交集。这类组件相对是最好写的，因为主要是还原设计稿，完成需求，不需要太多模块和架构设计上的考虑。</p></li><li><p>不包含业务，独立、具体功能的基础组件，比如<strong>日期选择器</strong>、<strong>模态框</strong>等。这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。比如笔者开源的 iView，就是包含了 50 多个这样基础组件的 UI 组件库。</p><p>每个公司都有自己的组件使用规范或组件库，但要开发和维护一套像 iView 这样的组件库，投入的人力和精力还是很重的，所以出于成本考虑，很多项目都会使用已有的开源组件库。</p><p>独立组件的开发难度要高于第一类组件，因为它的侧重点是 API 的设计、兼容性、性能、以及复杂的功能。这类组件对 JavaScript 的编程能力有一定要求，也会包含非常多的技巧，比如在不依赖 Vuex 和 Bus（因为独立组件，无法依赖其它库）的情况下，各组件间的通信，还会涉及很多脑壳疼的逻辑，比如日期选择器要考虑不同时区、国家的日历习惯，支持多种日期格式。</p><p>本小册也会重点介绍此类组件的各种开发模式和技巧，对应不同的模式，会带有具体的组件实战。</p></li><li><p>业务组件。它不像第二类独立组件只包含某个功能，而是在业务中被多个页面复用的，它与独立组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而独立组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。</p><p>业务组件更像是介于第一类和第二类之间，在开发上也与独立组件类似，但寄托于项目，你可以使用项目中的技术栈，比如 Vuex、axios、echarts 等，所以它的开发难度相对独立组件要容易点，但也有必要考虑组件的可维护性和复用性。</p></li></ol><h2 id="小册的内容"><a href="#小册的内容" class="headerlink" title="小册的内容"></a>小册的内容</h2><p>因为本小册是围绕 Vue.js 组件展开的，所以第二节会讲解 Vue.js 组件的三个 API：<code>prop</code>、<code>event</code>、<code>slot</code>，当然，如果你已经开发过一些独立组件，完全可以跳过这节内容。</p><p>3 - 7 小节会介绍组件间通信的一些方法和黑科技，一部分是 Vue.js 内置的，一部分是自行实现的，在实际开发中，会非常实用。同时也利用这些方法完成了两个具体的实战案例：</p><ol><li>具有数据校验功能的表单组件 —— Form；</li><li>组合多选框组件 —— CheckboxGroup &amp; Checkbox。</li></ol><p>本小册都会以这种核心科技 + 对应实战的形式展开。</p><p>8 - 10 小节介绍 Vue 的构造器 extend 和手动挂载组件 $mount 的用法及案例。Vue.js 除了我们正常 <code>new Vue()</code> 外，还可以手动挂载的，这 3 节将介绍手动挂载一个 Vue 组件的使用场景。其中涉及到两个案例：</p><ol><li>动态渲染 .vue 文件的组件 —— Display；</li><li>全局通知组件 —— $Alert。</li></ol><p><strong>Display</strong> 组件用于将 <code>.vue</code> 文件渲染出来，线上的案例是 <a href="https://run.iviewui.com/" target="_blank" rel="noopener">iView Run</a>，它不需要你重新编译项目，就可以渲染一个标准的 Vue.js 组件。</p><p><strong>$Alert</strong> 是全局的通知组件，它的调用方法不同于常规组件。常规组件使用方法形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Alert content=&quot;通知内容&quot; :duration=&quot;3&quot;&gt;&lt;/Alert&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import Alert from &apos;../components/alert.vue&apos;;</span><br><span class="line">    </span><br><span class="line">    export default &#123;</span><br><span class="line">        components: &#123; Alert &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>而 <code>$Alert</code> 的调用更接近 JS 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        showMessage () &#123;</span><br><span class="line">            this.$Alert(&#123;</span><br><span class="line">                content: &apos;通知内容&apos;,</span><br><span class="line">                duration: 3</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然与常规 Vue 组件调用方式不同，但底层仍然由 Vue 组件构成和维护。</p><p>11 - 12 小节介绍 Render 函数与 Functional Render，并完成一个能够渲染自定义列的 Table 组件。Render 函数也是 Vue.js 组件重要的一部分，只不过在大多数业务中不常使用。本小节会介绍它的使用场景。</p><p>13 小节介绍<strong>作用域 slot（slot-scope）</strong>，并基于这种方法同样实现 Table 组件。slot 用的很多，但 slot-scope 在业务中并不常用，但在一些特定场景下，比如组件内部有循环体时，会非常实用。</p><p>14 - 15 小节介绍递归组件，并完成树形控件 —— Tree。</p><p>16 - 19 小节是综合拓展，会着重讲解 Vue.js 容易忽略却很重要的 API，以及对 Vue.js 面试题的详细分析。除此之外，还会总结笔者在两年的 iView 开源经历中的经验，除了技术细节外，还包括开源项目的持续性发展、推广等。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>三年前，我开始接触 Vue.js 框架，当时就被它的轻量、组件化和友好的 API 所吸引。与此同时，我也开源了 iView 项目。三年的磨(cǎi )砺(kēng)，沉淀了不少关于 Vue.js 组件的经验。</p><p>本小册的内容也许不会让你的技术一夜间突飞猛进，但绝对使你醍醐灌顶。</p><p>那么，请准备好一台电脑和一杯咖啡，一起来探索 Vue.js 的精髓吧。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 开篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js 面试、常见问题答疑</title>
      <link href="/2018/09/07/%E6%8B%93%E5%B1%95%EF%BC%9AVue.js%20%E9%9D%A2%E8%AF%95%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91/"/>
      <url>/2018/09/07/%E6%8B%93%E5%B1%95%EF%BC%9AVue.js%20%E9%9D%A2%E8%AF%95%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91/</url>
      
        <content type="html"><![CDATA[<h1 id="拓展：Vue-js-面试、常见问题答疑"><a href="#拓展：Vue-js-面试、常见问题答疑" class="headerlink" title="拓展：Vue.js 面试、常见问题答疑"></a>拓展：Vue.js 面试、常见问题答疑</h1><p>在过去的很多面试中，我会经常问候选人一些关于 Vue.js 的问题。这些问题从题面来看很简单，但仔细想又不是那么简单，不同的人，会答出不同的层次，从而更好地了解一个人对 Vue.js 的理解程度。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h3><p>第一题应该是最简单的，提这个问题，也是想让候选人不那么紧张，因为但凡用过 Vue.js，多少知道 <code>v-show</code> 和 <code>v-if</code> 的区别，否则就没得聊了。不过这最简单的一道题，有三个层次，我会逐一追问。首先，基本所有人都会说到：</p><p><code>v-show</code> 只是 CSS 级别的 <code>display: none;</code> 和 <code>display: block;</code> 之间的切换，而 <code>v-if</code> 决定是否会选择代码块的内容（或组件）。</p><p>回答这些，已经可以得到 50 分了，紧接着我会追问，什么时候用 v-show，什么时候用 v-if ？到这里一部分人会比较吞吐，可能是知道，但表达不出来。我比较倾向的回答是：</p><p>频繁操作时，使用 <code>v-show</code>，一次性渲染完的，使用 <code>v-if</code>，只要意思对就好。</p><p>第二问可以得到 80 分了，最后一问很少有人能答上：**那使用 <code>v-if</code> 在性能优化上有什么经验？**这是一个加分项，要对 Vue.js 的组件编译有一定的理解。说一下期望的答案：</p><p>因为当 <code>v-if=&quot;false&quot;</code> 时，内部组件是不会渲染的，所以在特定条件才渲染部分组件（或内容）时，可以先将条件设置为 <code>false</code>，需要时（或异步，比如 $nextTick）再设置为 <code>true</code>，这样可以优先渲染重要的其它内容，合理利用，可以进行性能优化。</p><h3 id="绑定-class-的数组用法"><a href="#绑定-class-的数组用法" class="headerlink" title="绑定 class 的数组用法"></a>绑定 class 的数组用法</h3><p>动态绑定 class 应该不陌生吧，这也是最基本的，但是这个问题却有点绕，什么叫**绑定 class 的数组用法？**我们看一下，最常用的绑定 class 怎么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;&#123;show: isShow&#125;&quot;&gt;内容&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        isShow: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>绑定 class 的对象用法能满足大部分业务需求，不过，在复杂的场景下，会用到<strong>数组</strong>，来看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div :class=&quot;classes&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">      classes () &#123;</span><br><span class="line">        return [</span><br><span class="line">          `$&#123;prefixCls&#125;`,</span><br><span class="line">          `$&#123;prefixCls&#125;-$&#123;this.type&#125;`,</span><br><span class="line">          &#123;</span><br><span class="line">            [`$&#123;prefixCls&#125;-long`]: this.long,</span><br><span class="line">            [`$&#123;prefixCls&#125;-$&#123;this.shape&#125;`]: !!this.shape,</span><br><span class="line">            [`$&#123;prefixCls&#125;-$&#123;this.size&#125;`]: this.size !== &apos;default&apos;,</span><br><span class="line">            [`$&#123;prefixCls&#125;-loading`]: this.loading != null &amp;&amp; this.loading,</span><br><span class="line">            [`$&#123;prefixCls&#125;-icon-only`]: !this.showSlot &amp;&amp; (!!this.icon || !!this.customIcon || this.loading),</span><br><span class="line">            [`$&#123;prefixCls&#125;-ghost`]: this.ghost</span><br><span class="line">          &#125;</span><br><span class="line">        ];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>示例来自 iView 的 Button 组件，可以看到，数组里，可以是固定的值，还有动态值（对象）的混合。</p><h3 id="计算属性和-watch-的区别"><a href="#计算属性和-watch-的区别" class="headerlink" title="计算属性和 watch 的区别"></a>计算属性和 watch 的区别</h3><p>回答该题前，一般都会思考一下。很多人会偏题，直接去答计算属性和 watch 怎么用，这是不得分的，因为题目是问<strong>区别</strong>，并不是用法。</p><p>计算属性是自动监听依赖值的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。</p><p>所以区别来源于用法，只是需要动态值，那就用计算属性；需要知道值的改变后执行业务逻辑，才用 watch，用反或混用虽然可行，但都是不正确的用法。</p><p>这个问题会延伸出几个问题：</p><ol><li><p>computed 是一个对象时，它有哪些选项？</p></li><li><p>computed 和 methods 有什么区别？</p></li><li><p>computed 是否能依赖其它组件的数据？</p></li><li><p>watch 是一个对象时，它有哪些选项？</p></li></ol><p>问题 1，已经在 16 小节介绍过，有 get 和 set 两个选项。</p><p>问题 2，methods 是一个方法，它可以接受参数，而 computed 不能；computed 是可以缓存的，methods 不会；一般在 <code>v-for</code> 里，需要根据当前项动态绑定值时，只能用 methods 而不能用 computed，因为 computed 不能传参。</p><p>问题 3，computed 可以依赖其它 computed，甚至是其它组件的 data。</p><p>问题 4，第 16 小节也有提到，有以下常用的配置：</p><ul><li>handler 执行的函数</li><li>deep 是否深度</li><li>immediate 是否立即执行</li></ul><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>这个问题我会先写一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-component&gt;内容&lt;/custom-component&gt;</span><br></pre></td></tr></table></figure><p>然后问：<strong>怎样给这个自定义组件 custom-component 绑定一个<code>原生</code>的 click 事件？</strong></p><p>我一开始并不会问什么是事件修饰符，但是如果候选人说 <code>&lt;custom-component @click=&quot;xxx&quot;&gt;</code>，就已经错了，说明它对这个没有概念。这里的 <code>@click</code> 是自定义事件 click，并不是原生事件 click。绑定原生的 click 是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-component @click.native=&quot;xxx&quot;&gt;内容&lt;/custom-component&gt;</span><br></pre></td></tr></table></figure><p>该问题会引申很多，比如常见的事件修饰符有哪些？如果你能说上 <code>.exact</code>，说明你是个很爱探索的人，会大大加分哦。</p><blockquote><p>.exact 是 Vue.js 2.5.0 新加的，它允许你控制由精确的系统修饰符组合触发的事件，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&gt; &lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&gt; &lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; &lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&gt; &lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>你可能还需要了解常用的几个事件修饰符：</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li></ul><p>而且，事件修饰符在连用时，是有先后顺序的。</p><h3 id="组件中-data-为什么是函数"><a href="#组件中-data-为什么是函数" class="headerlink" title="组件中 data 为什么是函数"></a>组件中 data 为什么是函数</h3><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p><p>因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p><h3 id="keep-alive-的理解"><a href="#keep-alive-的理解" class="headerlink" title="keep-alive 的理解"></a>keep-alive 的理解</h3><p>这是个概念题，主要考察候选人是否知道这个用法。简单说，就是把一个组件的编译缓存起来。在第 14 节有过详细介绍，也可以看看 <a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive" target="_blank" rel="noopener">Vue.js 的文档</a>。</p><h3 id="递归组件的要求"><a href="#递归组件的要求" class="headerlink" title="递归组件的要求"></a>递归组件的要求</h3><p>回答这道题，首先你得知道什么是<strong>递归组件</strong>。而不到 10% 的人知道递归组件。其实在实际业务中用的确实不多，在独立组件中会经常使用，第 14 节和 15 节专门讲过递归组件。那回到问题，递归组件的要求是什么？主要有两个：</p><ul><li>要给组件设置 <strong>name</strong>；</li><li>要有一个明确的结束条件。</li></ul><h3 id="自定义组件的语法糖-v-model-是怎样实现的"><a href="#自定义组件的语法糖-v-model-是怎样实现的" class="headerlink" title="自定义组件的语法糖 v-model 是怎样实现的"></a>自定义组件的语法糖 v-model 是怎样实现的</h3><p>在第 16 节已经详细介绍过，这里的 v-model，并不是给普通输入框 <code>&lt;input /&gt;</code> 用的那种 v-model，而是在自定义组件上使用。既然是语法糖，就能够还原，我们先还原一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; currentValue &#125;&#125;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;Click&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      value: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        currentValue: this.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick () &#123;</span><br><span class="line">        this.currentValue += 1;</span><br><span class="line">        this.$emit(&apos;input&apos;, this.currentValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      value (val) &#123;</span><br><span class="line">        this.currentValue = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这个组件中，只有一个 props，但是名字叫 <code>value</code>，内部还有一个 <code>currentValue</code>，当改变 currentValue 时，会触发一个自定义事件 <code>@input</code>，并把 currentValue 的值返回。这就是一个 <code>v-model</code> 的语法糖，它要求 props 有一个叫 <code>value</code> 的项，同时触发的自定义事件必须叫 <code>input</code>。这样就可以在自定义组件上用 <code>v-model</code> 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-component v-model=&quot;value&quot;&gt;&lt;/custom-component&gt;</span><br></pre></td></tr></table></figure><p>如果你能说到 <code>model</code> 选项，绝对是加分的。</p><h3 id="Vuex-中-mutations-和-actions-的区别"><a href="#Vuex-中-mutations-和-actions-的区别" class="headerlink" title="Vuex 中 mutations 和 actions 的区别"></a>Vuex 中 mutations 和 actions 的区别</h3><p>主要的区别是，actions 可以执行异步。actions 是调用 mutations，而 mutations 来修改 store。</p><h3 id="Render-函数"><a href="#Render-函数" class="headerlink" title="Render 函数"></a>Render 函数</h3><p>这是比较难的一题了，因为很少有人会去了解 Vue.js 的 Render 函数，因为基本用不到。Render 函数的内容本小册已经很深入的讲解过了，遇到这个问题，一般可以从这几个方面来回答：</p><ul><li>什么是 Render 函数，它的使用场景是什么。</li><li>createElement 是什么？</li><li>Render 函数有哪些常用的参数？</li></ul><p>说到 Render 函数，就要说到虚拟 DOM（Virtual DOM）,Virtual DOM 并不是真正意义上的 DOM，而是一个轻量级的 JavaScript 对象，在状态发生变化时，Virtual DOM 会进行 Diff 运算，来更新只需要被替换的 DOM，而不是全部重绘。</p><p>它的使用场景，就是完全发挥 JavaScript 的编程能力，有时需要结合 JSX 来使用。</p><p>createElement 是 Render 函数的核心，它构成了 Vue Virtual DOM 的模板，它有 3 个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">createElement () &#123;</span><br><span class="line">  // &#123;String | Object | Function&#125;</span><br><span class="line">  // 一个 HTML 标签，组件选项，或一个函数</span><br><span class="line">  // 必须 return 上述其中一个</span><br><span class="line">  &apos;div&apos;,</span><br><span class="line">    // &#123;Object&#125;</span><br><span class="line">    // 一个对应属性的数据对象，可选</span><br><span class="line">    // 您可以在 template 中使用</span><br><span class="line">    &#123;</span><br><span class="line">    // 详细的属性</span><br><span class="line">  &#125;,</span><br><span class="line">    // &#123;String | Array&#125;</span><br><span class="line">    // 子节点（VNodes），可选</span><br><span class="line">    [</span><br><span class="line">    createElement(&apos;h1&apos;, &apos;hello world&apos;),</span><br><span class="line">    createElement(MyComponent, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        someProps: &apos;foo&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    &apos;bar&apos;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的参数，主要是指上面第二个参数里的值了，这个比较多，得去看 Vue.js 的文档。</p><h3 id="怎样理解单向数据流"><a href="#怎样理解单向数据流" class="headerlink" title="怎样理解单向数据流"></a>怎样理解单向数据流</h3><p>这个概念出现在组件通信。父组件是通过 prop 把数据传递到子组件的，但是这个 prop 只能由父组件修改，子组件不能修改，否则会报错。子组件想修改时，只能通过 <code>$emit</code> 派发一个自定义事件，父组件接收到后，由父组件修改。</p><p>一般来说，对于子组件想要更改父组件状态的场景，可以有两种方案：</p><ol><li><p>在子组件的 data 中拷贝一份 prop，data 是可以修改的，但 prop 不能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: String</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      currentValue: this.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>如果是对 prop 值的转换，可以使用计算属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  props: [&apos;size&apos;],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    normalizedSize: function () &#123;</span><br><span class="line">      return this.size.trim().toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>如果你能提到 v-model 实现数据的双向绑定、.sync 用法，会大大加分的，这些在第 16 节已经详细介绍过。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">Vue.js 生命周期</a> 主要有 8 个阶段：</p><ul><li><p>创建前 / 后（beforeCreate / created）：在 beforeCreate 阶段，Vue 实例的挂载元素 el 和数据对象 data 都为 undefined，还未初始化。在 created 阶段，Vue 实例的数据对象 data 有了，el 还没有。</p></li><li><p>载入前 / 后（beforeMount / mounted）：在 beforeMount 阶段，Vue 实例的 $el 和 data 都初始化了，但还是挂载之前为虚拟的 DOM 节点，data 尚未替换。在 mounted 阶段，Vue 实例挂载完成，data 成功渲染。</p></li><li><p>更新前 / 后（beforeUpdate / updated）：当 data 变化时，会触发 beforeUpdate 和 updated 方法。这两个不常用，且不推荐使用。</p></li><li><p>销毁前 / 后（beforeDestroy / destroyed）：beforeDestroy 是在 Vue 实例销毁前触发，一般在这里要通过 removeEventListener 解除手动绑定的事件。实例销毁后，触发 destroyed。</p></li></ul><h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><p>本小册一半的篇幅都在讲组件的通信，如果能把这些都吃透，基本上 Vue.js 的面试就稳了。</p><p>这个问题看似简单，却比较大，回答时，可以拆分为几种场景：</p><ol><li><p>父子通信：</p><p>父向子传递数据是通过 props，子向父是通过 events（$emit）；通过父链 / 子链也可以通信（$parent / $children）；<code>ref</code> 也可以访问组件实例；provide / inject API。</p></li><li><p>兄弟通信：</p><p>Bus；Vuex；</p></li><li><p>跨级通信：</p><p>Bus；Vuex；provide / inject API。</p></li></ol><p>除了常规的通信方法，本册介绍的 dispatch / broadcast 和 findComponents 系列方法也可以说的，如果能说到这些，说明你对 Vue.js 组件已经有较深入的研究。</p><h3 id="路由的跳转方式"><a href="#路由的跳转方式" class="headerlink" title="路由的跳转方式"></a>路由的跳转方式</h3><p>一般有两种：</p><ol><li>通过 <code>&lt;router-link to=&quot;home&quot;&gt;</code>，router-link 标签会渲染为 <code>&lt;a&gt;</code> 标签，在 template 中的跳转都是用这种；</li><li>另一种是编程式导航，也就是通过 JS 跳转，比如 <code>router.push(&#39;/home&#39;)</code>。</li></ol><h3 id="Vue-js-2-x-双向绑定原理"><a href="#Vue-js-2-x-双向绑定原理" class="headerlink" title="Vue.js 2.x 双向绑定原理"></a>Vue.js 2.x 双向绑定原理</h3><p>这个问题几乎是面试必问的，回答也是有深有浅。基本上要知道核心的 API 是通过 <code>Object.defineProperty()</code> 来劫持各个属性的 setter / getter，在数据变动时发布消息给订阅者，触发相应的监听回调，这也是为什么 Vue.js 2.x 不支持 IE8 的原因（IE 8 不支持此 API，且无法通过 polyfill 实现）。</p><p>Vue.js 文档已经对 <a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">深入响应式原理</a> 解释的很透彻了。</p><h3 id="什么是-MVVM，与-MVC-有什么区别"><a href="#什么是-MVVM，与-MVC-有什么区别" class="headerlink" title="什么是 MVVM，与 MVC 有什么区别"></a>什么是 MVVM，与 MVC 有什么区别</h3><p>MVVM 模式是由经典的软件架构 MVC 衍生来的。当 View（视图层）变化时，会自动更新到 ViewModel（视图模型），反之亦然。View 和 ViewModel 之间通过双向绑定（data-binding）建立联系。与 MVC 不同的是，它没有 Controller 层，而是演变为 ViewModel。</p><p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作是由 Vue.js 完成的，我们不需要手动操作 DOM，只需要维护好数据状态。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>一个人的简历，是由简单到复杂再到简单，技术是无止尽的，接触的越多，越能感到自己的渺小。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 拓展 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何做好一个开源项目（下篇）</title>
      <link href="/2018/09/07/%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/"/>
      <url>/2018/09/07/%E6%8B%93%E5%B1%95%EF%BC%9A%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="拓展：如何做好一个开源项目（下篇）"><a href="#拓展：如何做好一个开源项目（下篇）" class="headerlink" title="拓展：如何做好一个开源项目（下篇）"></a>拓展：如何做好一个开源项目（下篇）</h1><h2 id="持续运营"><a href="#持续运营" class="headerlink" title="持续运营"></a>持续运营</h2><p>项目有了一定的规模和进展后，需要持续运营，让更多的人知道和使用。运营并不是个技术活，对于程序员来说，还是或缺的技能。最简单的运营手段，就是在一些技术社区分享“软文”，iView 在早期就是这样做的，还总结出了一个 “500 star 定律”，也就是说，每一次分享文章，差不多能在 GitHub 带来 500 个 star。star 对于一个开源项目来说，还是蛮重要的，它直接决定了用户是否会选择你的项目，但用户都是程序员，又不傻，如果项目质量低，star 就变的一文不值了，还会坏了口碑。切记，不要刷 star，前端圈堪比娱乐圈，会被针对的很惨。</p><p>当然，不是什么内容都能发，比如更新日志，最好就不要发了，除非像 2.0、3.0 这种大版本。即使是发大版本的更新内容，也不是说把更新日志一贴就完事，如果你足够重视你的开源项目，就应该重视每一篇文章，把更新的核心思路说清楚。典型的案例可以参考 iView：</p><ul><li><a href="https://juejin.im/post/5b5e6f19e51d4515b01bf36e" target="_blank" rel="noopener">iView 发布 3.0 版本，以及开发者社区等 5 款新产品</a></li><li><a href="https://juejin.im/post/5aa5d56e51882555635df2b2" target="_blank" rel="noopener">iView 近期的更新，以及那些“不为人知”的故事</a></li><li><a href="https://juejin.im/post/59e6a995518825619a01c433" target="_blank" rel="noopener">iView 发布后台管理系统 iview-admin，没错，它就是你想要的</a></li></ul><p>标题的重要性就不必说了，在信息爆炸的时代，你的标题不够吸引人，根本没人看。</p><p>目前，有几个社区是值得关注和积累粉丝的：</p><ul><li>掘金：比较活跃的程序员社区，前端属性较浓，社区运营做的很好，对开源项目有扶持，相关的文章首次亮相，官方都会给予一定的资源支持。</li><li>知乎：流量最大的社区，大 V 属性，如果你是初入知乎，可以把文章投稿到热门的专栏，比如前端评论外刊、前端之巅等。因为自己起初是没有粉丝订阅的，发表了也不会有人看到，投稿就不一样了。而且，被某个大 V 赞一下，那效果就像中奖。</li><li>v2ex：不用解释，就是很火的社区。</li></ul><p>开源项目，一般都会在 GitHub 托管，不过也可以在开源中国（Gitee）同步一份，每个版本的更新日志，可以以新闻的形式，向开源中国投稿。开源中国在国内还是有一定的影响力的。</p><p>除了发表文章，一些技术分享大会也可以关注，可以以公司的名义申请成为嘉宾做分享。如果有机会，还可以到其它公司做技术分享，尤其是大厂商，这些都是难得推广开源项目的好机会。你的开源项目，如果有几个 BAT 这类的大厂使用，那会成为维护者、社区用户和观望者的信心来源。</p><p>还有发布会。在国内，开源项目搞发布会的，据我所知只有 iView。没错，18 年 7 月，iView 搞了一场新品发布会，线下进行，线上同步直播，当时有超过 2 万的在线用户观看，推广效果还是不错的。一场“合格”的活动，要分<strong>活动前</strong>、<strong>活动中</strong>、<strong>活动后</strong>。活动开始前一个月，就要散布消息，让用户有个初步印象，之间还可以爆料一些活动热点；活动进行中，要有专人负责现场，还要与观众互动；活动结束后，要加个班，把核心内容整理为文字，在第一时间通过官方渠道发表出来。这种大规模的活动，没有公司支持，个人很难完成的，因为这不是一两个人的事，需要很多工作人员一起完成，幕前幕后、直播的网络、现场 wifi，还要应对各种突破状况，不过，最重要的还是活动内容的策划准备了，否则一切都是纸上谈兵。</p><p>讲到这，你可能会说，老老实实做技术不好吗，非要弄这些花里胡哨的东西。的确，推广这件事，并不是做开源必须的，老实做技术没有错，推广只是让你的开源项目更快传达给目标用户。做这些事的目的就一个，让更多的人使用你的开源项目，让更多的开发者参与贡献代码。</p><p>最后一点，如果你的公司或团队有经费，适当投放一点广告也是不错的。</p><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>是时候与世界接轨了。一般来说，国际化（Internationalization，简称 i18n）分 3 个部分，首先是你的开源项目支持多国语言，对于 UI 组件库来说，这个还是很好支持的，只需要提供一个多语言的配置文件就行，每种语言一个文件，然后由社区贡献更多的语言。以 Vue.js 为例，社区也提供了 vue-i18n 插件，那你的组件库还要兼容 vue-i18n，可能还要考虑兼容多个主流的版本。</p><p>另一部分是文档的国际化，除了中文，至少应该提供一个英文版本，毕竟英文算是通用的语言。如果文档内容不多，可以让社区来提供更多的翻译版本。维护多语言的文档是一件很辛苦的事，这意味着每一个版本更新都是中英双语的，并不是说文档翻译一遍就不管了。好在翻译文档是个一次性的技术活，前期多找一些英文好的热心用户一起翻译，后面只要确保每次更新都保持中英双语就好了。</p><p>做国际化，意味着要服务国际友人，那就不能强求他们用微信或 QQ。在开源界，比较通用的是 <a href="https://gitter.im" target="_blank" rel="noopener">Gitter</a>，只需要关联一次 GitHub 的 repo 就行。除此之外，官方可以在 Twitter 开通一个账户，来更新一些动态，与其它 Twitter 互动。<a href="https://discordapp.com/" target="_blank" rel="noopener">Discord</a> 也是技术圈比较热门的一个 App，以 Vue.js 来说，你可以加入一个名为 <strong>Vue Land</strong> 的服务器，在里面找到 <strong>#ui-libraries</strong> 的频道，就可以和全世界的开发者讨论组件库的话题了。</p><p>支持国际化，短期来看，是一件付出回报比很低的事，但从长远利益出发，对国际化的支持，有助于更多的国外开发者成为核心 maintainers，让全世界能够参与进来，才是开源的意义所在。</p><h2 id="让更多的人参与"><a href="#让更多的人参与" class="headerlink" title="让更多的人参与"></a>让更多的人参与</h2><p>开源项目从来就不是一个人的事，一个健壮的开源项目，需要不断有人贡献代码。在项目有了一定知名度和使用人群后，自然会有不少 PR 进来，知名的开源项目 contributors 都有几百人，哪怕修改一行代码，只要被 merge，就算一个 contributors。最核心的维护者一般不会超过 5 人，而且除了作者本人，很多都是阶段性的，毕竟是开源，大多数人还是兼职做的，能贡献一点是一点，业务忙了就没顾不上了。</p><p>为开源项目贡献代码，主要以 PR 的形式进行，作为一个开源项目的 owner，即使 organization 的其他成员有直接 commit 的权限，也应该建议他们提交 PR，而不是直接 commit，owner 需要认真 review 每一个 PR 以确保代码质量。修复一个问题最怕的，是引起新的问题，或导致以前已修复的问题又复现，有时候，contributor 可能只为了 fix 某一个 issue，但它对整个项目是不了解的，而且对以前“发生的事情”都不了解，会导致一些他看不到的问题，这种情况作为 owner 就要认真审查了。</p><p>参与一个开源项目的方式有很多，除了最直接的 PR，还可以 review issues。项目活跃时，每天都会有不少 issues 进来，owner 可能没时间及时处理，但可以<strong>打标签</strong>（labels）。一个 issue 被标记了 label，说明已经审核过此 issue，常见的 label 有以下几种：</p><ul><li><strong>bug</strong>：已确定为 bug；</li><li><strong>feature request</strong>：已确定为请求新功能；</li><li><strong>invalid</strong>：无效的 issue，一般可以直接关闭；</li><li><strong>contribution welcome</strong>：owner 可能暂时没有精力处理，期望社区来贡献代码；</li><li><strong>provide example</strong>：issue 需要提供复现示例；</li><li><strong>discussion</strong>：暂时无法断定，需要进一步讨论；</li><li><strong>may be supported in the future</strong>：先标记一下，也许未来会支持。</li></ul><p>管理 issues 的另一个方式是用好<strong>里程碑</strong>（milestones）功能。milestones 可以按照版本号创建，把期望在这个版本解决的 issues 添加进去，发版前对当前 milestone 的所有 issues 集中查看，是否都处理完成了。</p><p>有一些<strong>有价值</strong>的 issues 可能会耗费不少精力处理，而且社区很多用户都希望能够解决，owner 当然也希望处理，只是没有时间。这种情况不妨<strong>有偿悬赏</strong>，推荐一个新起的国外社区 <a href="https://issuehunt.io/" target="_blank" rel="noopener">IssueHunt</a>，用户可以为某一个 repo 的 issue 众筹，谁处理了，就可以得到全部赏金。</p><p>每一个版本发布后，记得创建一条 release，这样做一是有一个版本更新日志记录的地方，二是 watch 你项目的人都可以及时收到邮件通知提醒升级，三是 release 会打一个 tag，其它贡献者可以切换到此 tag。release 最好不要在发版前再创建，不然整理起来很费劲，建议每个 release 发布后，就新建下一个版本的 release 作为草稿（draft），处理一个 issue，就记录一条，避免遗漏。</p><p>版本号也是有讲究的，比如 3.2.1，这里的最后一位，代表只有 bug fixed，中间一位代表有 new features，第一位代表有 break changes。一般来说，除了第一位，剩下的版本都是兼容式的，就是说用户升级后不会影响当前项目，如果有 API 的变更，应该发布第一位版本号。</p><p>代码贡献越活跃，贡献者越多，开源项目也越健壮，作为 owner，应该及时联络有价值的贡献者，一个人的能力毕竟是有限的。当你与世界各地讲着不同语言的的人，一起完成一个开源项目，会觉得开源真是一件了不起的事情。</p><h2 id="让-Robot-来做“坏人”"><a href="#让-Robot-来做“坏人”" class="headerlink" title="让 Robot 来做“坏人”"></a>让 Robot 来做“坏人”</h2><p>开源项目有一定的规模后，社区就会很活跃，每天都会有大量的 issues，这些 issues 越积越多，不及时处理掉，对 owner 来说就是精神压力。在项目初期，由于使用者不多，是鼓励提 issues 的，建议、新功能请求、bug 反馈、问题咨询等各种内容都可以提交，而且作者有足够的时间和精力来认真回答。到了一定规模后，可能什么 issues 都会出现，不乏一些带有恶意的、言语攻击的，如果直接关闭 issue，可能还会继续“纠缠”，说 owner 态度不好之类的，这些都是笔者亲身经历过的。</p><p>除了恶意的 issues，还有很多 issues 不符合格式要求，连代码格式化都没有，甚至连问题都说不清楚，也没有描述，就一个标题，这些无效的 issues 一个个回复都会占据大量的精力，直接 close 还会被说没处理怎么就关闭了，实属无奈。</p><p>这时你需要一个 GitHub 机器人来充当“坏人”的角色，也就是注册另一个 GitHub 账户，用它来处理一些不符合要求的 issues，这是一个很聪明的做法，关闭 issues 这些活都让 robot 来操作。比如 iView 的“坏人”就是 <a href="https://github.com/iview-bot" target="_blank" rel="noopener">iview-bot</a>，不过它是一个智能的 robot，不需要 owner 控制，会自动关闭不合格的 issues 并回复提问者。GitHub 提供了 API 来接收每一个 issues 并通过 API 来操作 issues，包括关闭、打标签、回复等，只要给 robot 设置足够的权限就行。比如 iView 的 issues 机器人代码是 <a href="https://github.com/iview/iview-bot" target="_blank" rel="noopener">https://github.com/iview/iview-bot</a>。用户如果直接通过 GitHub 提交 issues，会被 robot 立即关闭，并回复：</p><blockquote><p>Hello, this issue has been closed because it does not conform to our issue requirements. Please use the <a href="https://www.iviewui.com/new-issue" target="_blank" rel="noopener">Issue Helper</a> to create an issue - thank you!</p></blockquote><p>就是说，用户必须通过 <a href="https://www.iviewui.com/new-issue" target="_blank" rel="noopener">Issue Helper</a> 这个页面提交 issues 才可以，不是通过它提交的，会被检测出来立即关闭。在这个页面中，用户需要提供详细的描述才能通过表单验证。issues 只接受 bug 报告或是新功能请求 (feature requests)，对于使用咨询等其它问题，都不能提交，而是鼓励到 Stackoverflow 之类的社区讨论。如果是 Bug，还必须提供能够最小化复现问题的在线链接，以及详细的复现步骤。</p><p>robot 还有一个作用：翻译。它会把中文的 issues 自动翻译为英文并把翻译内容自动创建一条回复，同时标题也会修改为英文。开源项目到这个规模，使用者和贡献者不仅仅是中国人了，世界各地的开发者都有，使用英文会让所有人都看懂 issues。</p><p>虽然 robot 能自动过滤 80% 不合格的 issues，但仍有浑水摸鱼的用户跳过这些验证，这时可以给 robot 设置一些快捷回复，人为来 comment &amp; close：</p><ul><li><p>Hello, this issue has been closed because similar problems exist or have been explained in the documentation, please check carefully. <em>已有相同 issues，或文档有说明</em></p></li><li><p>Hello, this issue has been closed because it is not required to submit or describe is not clear. <em>描述不清楚</em></p></li><li><p>Hello, this issue has been closed because it has nothing to do with the <strong>bug report</strong> or <strong>feature request</strong>. Maybe you can ask normal question through <a href="https://segmentfault.com/t/iview" target="_blank" rel="noopener">SegmentFault</a> or <a href="https://stackoverflow.com/" target="_blank" rel="noopener">stackoverflow</a>. <em>不是 bug 反馈或 新功能请求，请到社区讨论</em></p></li><li><p>Hello, this issue has been closed because it is not a bug, but a usage problem, please consult other communities. <em>用法不对</em></p></li><li><p>Please provide online code. You can quickly create an example using the following online link：<a href="https://run.iviewui.com/" target="_blank" rel="noopener">https://run.iviewui.com/</a>. <em>没有提供在线示例</em></p></li></ul><p>其实呢，这个“坏人”也没那么坏，还是挺可爱的。</p><h2 id="赞助与商业化"><a href="#赞助与商业化" class="headerlink" title="赞助与商业化"></a>赞助与商业化</h2><p>开源项目的发展离不开资金的支持，向社区寻求赞助并不是一件“羞耻”的事情，而是理所当然的。</p><p>最简单的赞助方式就是通过二维码打赏，不过这种方式在国内几乎没有什么用，中国的开发者大多比较“囊中羞涩”，而且由于打赏的匿名性（微信），时不时收到个 1 分钱，也就呵呵了。</p><p>这里推荐几种比较好的“募资”方式：<a href="https://www.patreon.com/" target="_blank" rel="noopener">patreon</a> 和 <a href="https://opencollective.com/" target="_blank" rel="noopener">opencollective</a> 是开源项目最常用的，可以一次性支持，或周期性，以美元结算，可转至 PayPal。不过这两种都是美元，而且转到 owner 这里，扣除手续费可能少很多，不过对赞助者（往往是企业）来说，好处就是有发票。另一种方式是通过开源中国来赞助，开源中国的用户还是比较慷慨的。</p><p>另一种是投放广告，这里推荐 <a href="https://www.carbonads.net/" target="_blank" rel="noopener">Carbon</a>，不同于 Google Ads 的是，它的广告都是与互联网相关的，而且样式可以完全自定义，很美观，不会让用户产生反感，广告根据展示和点击转化付费。Carbon 的中国市场负责人中文很溜哦，作为中国开发者，不用担心谈不来。</p><p>不过呢，最值得推荐的还是接入<strong>品牌广告</strong>，但前提是你的文档要有一定的流量。开源项目的文档有着最大的特点：访问者几乎都是程序员，所以你要是挂个某多多的广告，几乎会被喷死。在线教育、云主机服务商都是不错的选择。一般不会有人主动联系 owner 投放的，除非像 Vue.js 这种级别的，但你可以尝试发一封友好的邮件来询问。不知道发给谁？告诉你个好办法，去其它社区（比如 v2ex）看看都有哪些金主投放就知道了，既然已经投放，说明有投放广告的需求，都是潜在的目标“客户”。</p><p>再来说说商业化。</p><p>开源并不是意味着免费，根据开源协议的不同，有的开源软件在用于商业时，可能要购买授权，源码是开放的，但不一定可以免费使用。不过能够收取授权费，也说明你的软件确实无可替代。企业为了避免不必要的纠纷，肯定是愿意购买你的软件的。但是对于大多数 MIT 的开源项目，可以商业化吗？答案是肯定的。</p><p>首先要知道，能够付费的，都是企业，而非个人，个人也没有付费的必要。一种比较常见的模式就是软件免费，然后可以向企业提供额外的付费咨询服务或顾问。最懂开源项目的人，绝对是这个项目的 owner，如果企业是深度用户，还是很愿意支付一些费用来咨询问题的。我是做 to B 业务的，我们公司也是做 to B 的，公司高管大多也来自 Oracle（算是比较大的 to B 企业了），所以我对企业服务也有一定的理解，一款好的产品，绝对是技术加咨询服务。</p><p>商业化还是有很多方式的，具体要看开源项目的类型。以组件库为例，它本身是免费的，也可以无限制免费使用，但可能提供付费的高级组件或模板系统，以及其它生态产品，比如基于组件库的 IM 系统。</p><p>当然了，并不是所有的开源项目都要商业化，大部分还是完全免费的，商业化也有利弊，如果没有一定的实力，很有可能搞砸哦！</p><p>以上，就是我从事开源工作两年多的一些浅薄经验，希望能给聪明的你带来帮助。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>每个开发者，都应该尝试维护一个开源项目。</p><p>每个开发者，都应该抱着一颗敬畏之心使用他人的开源项目，而不是“用你的是看得起你”。</p><p>每个开发者，都应该适当地赞助一个帮助过你的开源项目。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 拓展 </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更灵活的组件</title>
      <link href="/2018/09/07/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%9ARender%20%E5%87%BD%E6%95%B0%E4%B8%8E%20Functional%20Render/"/>
      <url>/2018/09/07/%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%9ARender%20%E5%87%BD%E6%95%B0%E4%B8%8E%20Functional%20Render/</url>
      
        <content type="html"><![CDATA[<h1 id="更灵活的组件：Render-函数与-Functional-Render"><a href="#更灵活的组件：Render-函数与-Functional-Render" class="headerlink" title="更灵活的组件：Render 函数与 Functional Render"></a>更灵活的组件：Render 函数与 Functional Render</h1><p>Vue.js 2.x 与 Vue.js 1.x 最大的区别就在于 2.x 使用了 Virtual DOM（虚拟 DOM）来更新 DOM 节点，提升渲染性能。</p><p>一般来说，我们写 Vue.js 组件，模板都是写在 <code>&lt;template&gt;</code> 内的，但它并不是最终呈现的内容，template 只是一种对开发者友好的语法，能够一眼看到 DOM 节点，容易维护，在 Vue.js 编译阶段，会解析为 Virtual DOM。</p><p>与 DOM 操作相比，Virtual DOM 是基于 JavaScript 计算的，所以开销会小很多。下图演示了 Virtual DOM 运行的过程：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670bc4c26b9c667?w=1964&h=636&f=png&s=105521" alt></p><p>正常的 DOM 节点在 HTML 中是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;main&quot;&gt;</span><br><span class="line">  &lt;p&gt;文本内容&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;文本内容&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>用 Virtual DOM 创建的 JavaScript 对象一般会是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const vNode = &#123;</span><br><span class="line">  tag: &apos;div&apos;,</span><br><span class="line">  attributes: &#123;</span><br><span class="line">    id: &apos;main&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    // p 节点</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vNode 对象通过一些特定的选项描述了真实的 DOM 结构。</p><p>在 Vue.js 中，对于大部分场景，使用 template 足以应付，但如果想完全发挥 JavaScript 的编程能力，或在一些特定场景下（后文介绍），需要使用 Vue.js 的 Render 函数。</p><h2 id="Render-函数"><a href="#Render-函数" class="headerlink" title="Render 函数"></a>Render 函数</h2><p>正如上文介绍的 Virtual DOM 示例一样，Vue.js 的 Render 函数也是类似的语法，需要使用一些特定的选项，将 template 的内容改写成一个 JavaScript 对象。</p><p>对于初级前端工程师，或想快速建站的需求，直接使用 Render 函数开发 Vue.js 组件是要比 template 困难的，原因在于 Render 函数返回的是一个 JS 对象，没有传统 DOM 的层级关系，配合上 if、else、for 等语句，将节点拆分成不同 JS 对象再组装，如果模板复杂，那一个 Render 函数是难读且难维护的。所以，绝大部分组件开发和业务开发，我们直接使用 template 语法就可以了，并不需要特意使用 Render 函数，那样只会增加负担，同时也放弃了 Vue.js 最大的优势（React 无 template 语法）。</p><p>很多学习 Vue.js 的开发者在遇到 Render 函数时都有点”躲避“，或直接放弃这部分，这并没有问题，因为不用 Render 函数，照样可以写出优秀的 Vue.js 程序。不过，Render 函数并没有想象中的那么复杂，只是配置项特别多，一时难以记住，但归根到底，Render 函数只有 3 个参数。</p><p>来看一组 template 和 Render 写法的对照：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;main&quot; class=&quot;container&quot; style=&quot;color: red&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;内容 1&lt;/p&gt;</span><br><span class="line">    &lt;p v-else&gt;内容 2&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        show: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      show: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render: (h) =&gt; &#123;</span><br><span class="line">    let childNode;</span><br><span class="line">    if (this.show) &#123;</span><br><span class="line">      childNode = h(&apos;p&apos;, &apos;内容 1&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      childNode = h(&apos;p&apos;, &apos;内容 2&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return h(&apos;div&apos;, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        id: &apos;main&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      class: &#123;</span><br><span class="line">        container: true</span><br><span class="line">      &#125;,</span><br><span class="line">      style: &#123;</span><br><span class="line">        color: &apos;red&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, [childNode]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>h</code>，即 <code>createElement</code>，是 Render 函数的核心。可以看到，template 中的 <strong>v-if / v-else</strong> 等指令，都被 JS 的 <strong>if / else</strong> 替代了，那 <strong>v-for</strong> 自然也会被 <strong>for</strong> 语句替代。</p><p>h 有 3 个参数，分别是：</p><ol><li><p>要渲染的元素或组件，可以是一个 html 标签、组件选项或一个函数（不常用），该参数为必填项。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 1. html 标签</span><br><span class="line">h(&apos;div&apos;);</span><br><span class="line">// 2. 组件选项</span><br><span class="line">import DatePicker from &apos;../component/date-picker.vue&apos;;</span><br><span class="line">h(DatePicker);</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>对应属性的数据对象，比如组件的 props、元素的 class、绑定的事件、slot、自定义指令等，该参数是可选的，上文所说的 Render 配置项多，指的就是这个参数。该参数的完整配置和示例，可以到 Vue.js 的文档查看，没必要全部记住，用到时查阅就好：<a href="https://cn.vuejs.org/v2/guide/render-function.html#createElement-%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">createElement 参数</a>。</p></li><li><p>子节点，可选，String 或 Array，它同样是一个 h。示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &apos;内容&apos;,</span><br><span class="line">  h(&apos;p&apos;, &apos;内容&apos;),</span><br><span class="line">  h(Component, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      someProp: &apos;foo&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>所有的组件树中，如果 vNode 是组件或含有组件的 slot，那么 vNode 必须唯一。以下两个示例都是<strong>错误</strong>的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 局部声明组件</span><br><span class="line">const Child = &#123;</span><br><span class="line">  render: (h) =&gt; &#123;</span><br><span class="line">    return h(&apos;p&apos;, &apos;text&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  render: (h) =&gt; &#123;</span><br><span class="line">    // 创建一个子节点，使用组件 Child</span><br><span class="line">    const ChildNode = h(Child);</span><br><span class="line">    </span><br><span class="line">    return h(&apos;div&apos;, [</span><br><span class="line">      ChildNode,</span><br><span class="line">      ChildNode</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  render: (h) =&gt; &#123;</span><br><span class="line">    return h(&apos;div&apos;, [</span><br><span class="line">      this.$slots.default,</span><br><span class="line">      this.$slots.default</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重复渲染多个组件或元素，可以通过一个循环和工厂函数来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const Child = &#123;</span><br><span class="line">  render: (h) =&gt; &#123;</span><br><span class="line">    return h(&apos;p&apos;, &apos;text&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  render: (h) =&gt; &#123;</span><br><span class="line">    const children = Array.apply(null, &#123;</span><br><span class="line">      length: 5</span><br><span class="line">    &#125;).map(() =&gt; &#123;</span><br><span class="line">      return h(Child);</span><br><span class="line">    &#125;);</span><br><span class="line">    return h(&apos;div&apos;, children);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于含有组件的 slot，复用比较复杂，需要将 slot 的每个子节点都克隆一份，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  render: (h) =&gt; &#123;</span><br><span class="line">    function cloneVNode (vnode) &#123;</span><br><span class="line">      // 递归遍历所有子节点，并克隆</span><br><span class="line">      const clonedChildren = vnode.children &amp;&amp; vnode.children.map(vnode =&gt; cloneVNode(vnode));</span><br><span class="line">      const cloned = h(vnode.tag, vnode.data, clonedChildren);</span><br><span class="line">      cloned.text = vnode.text;</span><br><span class="line">      cloned.isComment = vnode.isComment;</span><br><span class="line">      cloned.componentOptions = vnode.componentOptions;</span><br><span class="line">      cloned.elm = vnode.elm;</span><br><span class="line">      cloned.context = vnode.context;</span><br><span class="line">      cloned.ns = vnode.ns;</span><br><span class="line">      cloned.isStatic = vnode.isStatic;</span><br><span class="line">      cloned.key = vnode.key;</span><br><span class="line"></span><br><span class="line">      return cloned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const vNodes = this.$slots.default === undefined ? [] : this.$slots.default;</span><br><span class="line">    const clonedVNodes = this.$slots.default === undefined ? [] : vNodes.map(vnode =&gt; cloneVNode(vnode));</span><br><span class="line">    </span><br><span class="line">    return h(&apos;div&apos;, [</span><br><span class="line">      vNodes,</span><br><span class="line">      clonedVNodes</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Render 函数里创建了一个 cloneVNode 的工厂函数，通过递归将 slot 所有子节点都克隆了一份，并对 VNode 的关键属性也进行了复制。</p><p>深度克隆 slot 并非 Vue.js 内置方法，也没有得到推荐，属于黑科技，在一些特殊的场景才会使用到，正常业务几乎是用不到的。比如 iView 组件库的穿梭框组件 Transfer，就用到了这种方法：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670bc4f017b9bf6?w=1246&h=654&f=png&s=108936" alt></p><p>它的使用方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Transfer</span><br><span class="line">    :data=&quot;data&quot;</span><br><span class="line">    :target-keys=&quot;targetKeys&quot;</span><br><span class="line">    :render-format=&quot;renderFormat&quot;&gt;</span><br><span class="line">  &lt;div :style=&quot;&#123;float: &apos;right&apos;, margin: &apos;5px&apos;&#125;&quot;&gt;</span><br><span class="line">    &lt;Button size=&quot;small&quot; @click=&quot;reloadMockData&quot;&gt;Refresh&lt;/Button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Transfer&gt;</span><br></pre></td></tr></table></figure><p>示例中的默认 slot 是一个 Refresh 按钮，使用者只写了一遍，但在 Transfer 组件中，是通过克隆 VNode 的方法，显示了两遍。如果不这样做，就要声明两个具名 slot，但是左右两个的逻辑可能是完全一样的，使用者就要写两个一模一样的 slot，这是不友好的。</p><blockquote><p>Render 函数的基本用法还有很多，比如 v-model 的用法、事件和修饰符、slot 等，读者可以到 Vue.js 文档阅读。<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">Vue.js 渲染函数</a></p></blockquote><h2 id="Render-函数使用场景"><a href="#Render-函数使用场景" class="headerlink" title="Render 函数使用场景"></a>Render 函数使用场景</h2><p>上文说到，一般情况下是不推荐直接使用 Render 函数的，使用 template 足以，在 Vue.js 中，使用 Render 函数的场景，主要有以下 4 点：</p><ol><li><p>使用两个相同 slot。在 template 中，Vue.js 不允许使用两个相同的 slot，比如下面的示例是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ol><pre><code>解决方案就是上文中讲到的**约束**，使用一个深度克隆 VNode 节点的方法。</code></pre><ol start="2"><li><p>在 SSR 环境（服务端渲染），如果不是常规的 template 写法，比如通过 Vue.extend 和 new Vue 构造来生成的组件实例，是编译不过的，在前面小节也有所介绍。回顾上一节的 <code>$Alert</code> 组件的 notification.js 文件，当时是使用 Render 函数来渲染 Alert 组件，如果改成另一种写法，在 SSR 中会报错，对比两种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 正确写法</span><br><span class="line">import Alert from &apos;./alert.vue&apos;;</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">Alert.newInstance = properties =&gt; &#123;</span><br><span class="line">  const props = properties || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  const Instance = new Vue(&#123;</span><br><span class="line">    data: props,</span><br><span class="line">    render (h) &#123;</span><br><span class="line">      return h(Alert, &#123;</span><br><span class="line">        props: props</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const component = Instance.$mount();</span><br><span class="line">  document.body.appendChild(component.$el);</span><br><span class="line"></span><br><span class="line">  const alert = Instance.$children[0];</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    add (noticeProps) &#123;</span><br><span class="line">      alert.add(noticeProps);</span><br><span class="line">    &#125;,</span><br><span class="line">    remove (name) &#123;</span><br><span class="line">      alert.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Alert;</span><br></pre></td></tr></table></figure></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 在 SSR 下报错的写法</span><br><span class="line">import Alert from &apos;./alert.vue&apos;;</span><br><span class="line">import Vue from &apos;vue&apos;;</span><br><span class="line"></span><br><span class="line">Alert.newInstance = properties =&gt; &#123;</span><br><span class="line">  const props = properties || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  const div = document.createElement(&apos;div&apos;);</span><br><span class="line">  div.innerHTML = `&lt;Alert $&#123;props&#125;&gt;&lt;/Alert&gt;`;</span><br><span class="line">  document.body.appendChild(div);</span><br><span class="line">  </span><br><span class="line">  const Instance = new Vue(&#123;</span><br><span class="line">    el: div,</span><br><span class="line">    data: props,</span><br><span class="line">    components: &#123; Alert &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  const alert = Instance.$children[0];</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    add (noticeProps) &#123;</span><br><span class="line">      alert.add(noticeProps);</span><br><span class="line">    &#125;,</span><br><span class="line">    remove (name) &#123;</span><br><span class="line">      alert.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Alert;</span><br></pre></td></tr></table></figure></code></pre><ol start="3"><li><p>在 runtime 版本的 Vue.js 中，如果使用 Vue.extend 手动构造一个实例，使用 template 选项是会报错的，在第 9 节中也有所介绍。解决方案也很简单，把 template 改写为 Render 就可以了。需要注意的是，在开发独立组件时，可以通过配置 Vue.js 版本来使 template 选项可用，但这是在自己的环境，无法保证使用者的 Vue.js 版本，所以对于提供给他人用的组件，是需要考虑兼容 runtime 版本和 SSR 环境的。</p></li><li><p>这可能是使用 Render 函数最重要的一点。一个 Vue.js 组件，有一部分内容需要从父级传递来显示，如果是文本之类的，直接通过 <code>props</code> 就可以，如果这个内容带有样式或复杂一点的 html 结构，可以使用 <code>v-html</code> 指令来渲染，父级传递的仍然是一个 HTML Element 字符串，不过它仅仅是能解析正常的 html 节点且有 XSS 风险。当需要最大化程度自定义显示内容时，就需要 <code>Render</code> 函数，它可以渲染一个完整的 Vue.js 组件。你可能会说，用 slot 不就好了？的确，slot 的作用就是做内容分发的，但在一些特殊组件中，可能 slot 也不行。比如一个表格组件 <code>Table</code>，它只接收两个 props：列配置 columns 和行数据 data，不过某一列的单元格，不是只将数据显示出来那么简单，可能带有一些复杂的操作，这种场景只用 slot 是不行的，没办法确定是那一列的 slot。这种场景有两种解决方案，其一就是 Render 函数，下一节的实战就是开发这样一个 Table 组件；另一种是用作用域 slot（slot-scope），后面小节也会详细介绍。</p></li></ol><h2 id="Functional-Render"><a href="#Functional-Render" class="headerlink" title="Functional Render"></a>Functional Render</h2><p>Vue.js 提供了一个 <code>functional</code> 的布尔值选项，设置为 true 可以使组件无状态和无实例，也就是没有 data 和 this 上下文。这样用 Render 函数返回虚拟节点可以更容易渲染，因为函数化组件（Functional Render）只是一个函数，渲染开销要小很多。</p><p>使用函数化组件，Render 函数提供了第二个参数 context 来提供临时上下文。组件需要的 data、props、slots、children、parent 都是通过这个上下文来传递的，比如 this.level 要改写为 context.props.level，this.$slots.default 改写为 context.children。</p><blockquote><p>您可以阅读 <a href="https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">Vue.js 文档—函数式组件</a> 来查看示例。</p></blockquote><p>函数化组件在业务中并不是很常用，而且也有类似的方法来实现，比如某些场景可以用 is 特性来动态挂载组件。函数化组件主要适用于以下两个场景：</p><ul><li>程序化地在多个组件中选择一个；</li><li>在将 children、props、data 传递给子组件之前操作它们。</li></ul><p>比如上文说过的，某个组件需要使用 Render 函数来自定义，而不是通过传递普通文本或 v-html 指令，这时就可以用 Functional Render，来看下面的示例：</p><ol><li><p>首先创建一个函数化组件 <strong>render.js</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// render.js</span><br><span class="line">export default &#123;</span><br><span class="line">  functional: true,</span><br><span class="line">  props: &#123;</span><br><span class="line">    render: Function</span><br><span class="line">  &#125;,</span><br><span class="line">  render: (h, ctx) =&gt; &#123;</span><br><span class="line">    return ctx.props.render(h);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><pre><code>它只定义了一个 props：render，格式为 Function，因为是 functional，所以在 render 里使用了第二个参数 `ctx` 来获取 props。这是一个中间文件，并且可以复用，其它组件需要这个功能时，都可以引入它。</code></pre><ol start="2"><li><p>创建组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- my-component.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Render :render=&quot;render&quot;&gt;&lt;/Render&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Render form &apos;./render.js&apos;;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; Render &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      render: Function</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>使用上面的 my-compoennt 组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- demo.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;my-component :render=&quot;render&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import myComponent from &apos;../components/my-component.vue&apos;;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; myComponent &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        render: (h) =&gt; &#123;</span><br><span class="line">          return h(&apos;div&apos;, &#123;</span><br><span class="line">            style: &#123;</span><br><span class="line">              color: &apos;red&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &apos;自定义内容&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>这里的 render.js 因为只是把 demo.vue 中的 Render 内容过继，并无其它用处，所以用了 Functional Render。</p><p>就此例来说，完全可以用 slot 取代 Functional Render，那是因为只有 <code>render</code> 这一个 prop。如果示例中的 <code>&lt;Render&gt;</code> 是用 <code>v-for</code> 生成的，也就是多个时，用 一个 slot 是实现不了的，那时用 Render 函数就很方便了，后面章节会专门介绍。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果想换一种思路写 Vue.js，就试试 Render 函数吧，它会让你“又爱又恨”！</p><p>注：本节部分内容参考了《Vue.js 实战》（清华大学出版社），部分代码参考 <a href="https://github.com/iview/iview/blob/2.0/src/components/transfer/transfer.vue" target="_blank" rel="noopener">iView</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 拓展 </tag>
            
            <tag> 开源 </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme主题介绍</title>
      <link href="/2018/09/07/%E6%9C%80%E5%85%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2018/09/07/%E6%9C%80%E5%85%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建基础篇 2</title>
      <link href="/2018/09/07/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%AF%87%202%EF%BC%9Awebpack%20%E5%9C%A8%20CLI%203%20%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2018/09/07/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%AF%87%202%EF%BC%9Awebpack%20%E5%9C%A8%20CLI%203%20%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="构建基础篇-2：webpack-在-CLI-3-中的应用"><a href="#构建基础篇-2：webpack-在-CLI-3-中的应用" class="headerlink" title="构建基础篇 2：webpack 在 CLI 3 中的应用"></a>构建基础篇 2：webpack 在 CLI 3 中的应用</h1><p>webpack 作为目前最流行的项目打包工具，被广泛使用于项目的构建和开发过程中，其实说它是打包工具有点大材小用了，我个人认为它是一个集前端自动化、模块化、组件化于一体的可拓展系统，你可以根据自己的需要来进行一系列的配置和安装，最终实现你需要的功能并进行打包输出。</p><p>而在 Vue 的项目中，webpack 同样充当着举足轻重的作用，比如打包压缩、异步加载、模块化管理等等。如果你了解 webpack 那么相信本文会让你更了解其在 Vue 中的使用，如果你是一个 webpack 小白，那么也没事，相信你会很容易的了解它在项目中的配置和功能。</p><h2 id="webpack-的使用"><a href="#webpack-的使用" class="headerlink" title="webpack 的使用"></a>webpack 的使用</h2><h3 id="1-与-vue-cli-2-x-的差异"><a href="#1-与-vue-cli-2-x-的差异" class="headerlink" title="1. 与 vue-cli 2.x 的差异"></a>1. 与 vue-cli 2.x 的差异</h3><p>如果你使用过 vue-cli 2.x，那么你应该了解其构建出的目录会包含相应的 webpack 配置文件，但是在 vue-cli 3.x 中你却见不到一份关于 webpack 的配置文件，难道 3.x 抛弃了 webpack？其实不然，3.x 提供了一种开箱即用的模式，即你无需配置 webpack 就可以运行项目，并且它提供了一个 vue.config.js 文件来满足开发者对其封装的 webpack 默认配置的修改。如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/22/164c05d8ad965059?w=797&h=584&f=png&s=32393" alt></p><h3 id="2-vue-config-js-的配置"><a href="#2-vue-config-js-的配置" class="headerlink" title="2. vue.config.js 的配置"></a>2. vue.config.js 的配置</h3><p>通过上方新老版本的对比，我们可以清晰的看出 vue.config.js 的配置项结构，如果你构建的项目中没有该文件，那么你需要在根目录手动创建它。下面我们就来介绍一下其常用配置项的功能和用途：</p><h3 id="a-baseurl"><a href="#a-baseurl" class="headerlink" title="a. baseurl"></a>a. baseurl</h3><p>在第一节《Vue CLI 3 项目构建基础》中我们通过 vue-cli 3.x 成功构建并在浏览器中打开 <code>http://localhost:8080/</code> 展示了项目首页。如果现在你想要将项目地址加一个二级目录，比如：<code>http://localhost:8080/vue/</code>，那么我们需要在 vue.config.js 里配置 baseurl 这一项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    baseUrl: &apos;vue&apos;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其改变的其实是 webpack 配置文件中 output 的 <code>publicPath</code> 项，这时候你重启终端再次打开页面的时候我们首页的 url 就会变成带二级目录的形式。</p><h3 id="b-outputDir"><a href="#b-outputDir" class="headerlink" title="b. outputDir"></a>b. outputDir</h3><p>如果你想将构建好的文件打包输出到 output 文件夹下（默认是 dist 文件夹），你可以配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    outputDir: &apos;output&apos;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行命令 <code>yarn build</code> 进行打包输出，你会发现项目跟目录会创建 output 文件夹， 这其实改变了 webpack 配置中 output 下的 <code>path</code> 项，修改了文件的输出路径。</p><h3 id="c-productionSourceMap"><a href="#c-productionSourceMap" class="headerlink" title="c. productionSourceMap"></a>c. productionSourceMap</h3><p>该配置项用于设置是否为生产环境构建生成 source map，一般在生产环境下为了快速定位错误信息，我们都会开启 source map：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    productionSourceMap: true,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置会修改 webpack 中 <code>devtool</code> 项的值为 <code>source-map</code>。</p><p>开启 source map 后，我们打包输出的文件中会包含 js 对应的 .map 文件，其用途可以参考：<a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="noopener">JavaScript Source Map 详解</a></p><h3 id="d-chainWebpack"><a href="#d-chainWebpack" class="headerlink" title="d. chainWebpack"></a>d. chainWebpack</h3><p>chainWebpack 配置项允许我们更细粒度的控制 webpack 的内部配置，其集成的是 <a href="https://github.com/mozilla-neutrino/webpack-chain" target="_blank" rel="noopener">webpack-chain</a> 这一插件，该插件可以让我们能够使用链式操作来修改配置，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 用于做相应的合并处理</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // config 参数为已经解析好的 webpack 配置</span><br><span class="line">    chainWebpack: config =&gt; &#123;</span><br><span class="line">        config.module</span><br><span class="line">            .rule(&apos;images&apos;)</span><br><span class="line">            .use(&apos;url-loader&apos;)</span><br><span class="line">            .tap(options =&gt;</span><br><span class="line">                merge(options, &#123;</span><br><span class="line">                  limit: 5120,</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上操作我们可以成功修改 webpack 中 module 项里配置 rules 规则为图片下的 url-loader 值，将其 limit 限制改为 5M，修改后的 webpack 配置代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;   </span><br><span class="line">                /* config.module.rule(&apos;images&apos;) */</span><br><span class="line">                test: /\.(png|jpe?g|gif|webp)(\?.*)?$/,</span><br><span class="line">                use: [</span><br><span class="line">                    /* config.module.rule(&apos;images&apos;).use(&apos;url-loader&apos;) */</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &apos;url-loader&apos;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: 5120,</span><br><span class="line">                            name: &apos;img/[name].[hash:8].[ext]&apos;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是我们使用了 webpack-merge 这一插件，该插件用于做 webpack 配置的合并处理，这样 options 下面的其他值就不会被覆盖或改变。</p><p>关于 webpack-chain 的使用可以参考其 github 官方地址：<a href="https://github.com/mozilla-neutrino/webpack-chain" target="_blank" rel="noopener">https://github.com/mozilla-neutrino/webpack-chain</a>，它提供了操作类似 JavaScript Set 和 Map 的方式，以及一系列速记方法。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c58e690ddb43d?w=557&h=398&f=png&s=59904" alt></p><h3 id="e-configureWebpack"><a href="#e-configureWebpack" class="headerlink" title="e. configureWebpack"></a>e. configureWebpack</h3><p>除了上述使用 chainWebpack 来改变 webpack 内部配置外，我们还可以使用 configureWebpack 来进行修改，两者的不同点在于 chainWebpack 是链式修改，而 configureWebpack 更倾向于整体替换和修改。示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    // config 参数为已经解析好的 webpack 配置</span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        // config.plugins = []; // 这样会直接将 plugins 置空</span><br><span class="line">        </span><br><span class="line">        // 使用 return 一个对象会通过 webpack-merge 进行合并，plugins 不会置空</span><br><span class="line">        return &#123;</span><br><span class="line">            plugins: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configureWebpack 可以直接是一个对象，也可以是一个函数，如果是对象它会直接使用 webpack-merge 对其进行合并处理，如果是函数，你可以直接使用其 config 参数来修改 webpack 中的配置，或者返回一个对象来进行 merge 处理。</p><p>你可以在项目目录下运行 <code>vue inspect</code> 来查看你修改后的 webpack 完整配置，当然你也可以缩小审查范围，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 只查看 plugins 的内容</span><br><span class="line">vue inspect plugins</span><br></pre></td></tr></table></figure><h3 id="f-devServer"><a href="#f-devServer" class="headerlink" title="f. devServer"></a>f. devServer</h3><p>vue.config.js 还提供了 devServer 项用于配置 webpack-dev-server 的行为，使得我们可以对本地服务器进行相应配置，我们在命令行中运行的 <code>yarn serve</code> 对应的命令 <code>vue-cli-service serve</code> 其实便是基于 webpack-dev-server 开启的一个本地服务器，其常用配置参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: true, // 是否自动打开浏览器页面</span><br><span class="line">        host: &apos;0.0.0.0&apos;, // 指定使用一个 host。默认是 localhost</span><br><span class="line">        port: 8080, // 端口地址</span><br><span class="line">        https: false, // 使用https提供服务</span><br><span class="line">        proxy: null, // string | Object 代理设置</span><br><span class="line">        </span><br><span class="line">        // 提供在服务器内部的其他中间件之前执行自定义中间件的能力</span><br><span class="line">        before: app =&gt; &#123;</span><br><span class="line">          // `app` 是一个 express 实例</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然除了以上参数，其支持所有的 webpack-dev-server 中的选项，比如 <code>historyApiFallback</code> 用于重写路由（会在后续的多页应用配置中讲解）、progress 将运行进度输出到控制台等，具体可参考：<a href="https://www.webpackjs.com/configuration/dev-server/" target="_blank" rel="noopener">devServer</a></p><p>以上讲解了 vue.config.js 中一些常用的配置项功能，具体的配置实现需要结合实际项目进行，完整的配置项可以查看：<a href="https://github.com/vuejs/vue-cli/blob/ce3e2d475d63895cbb40f62425bb6b3237469bcd/docs/zh/config/README.md" target="_blank" rel="noopener">vue.config.js</a></p><h3 id="3-默认插件简介"><a href="#3-默认插件简介" class="headerlink" title="3. 默认插件简介"></a>3. 默认插件简介</h3><p>通过对 vue.config.js 的了解，我们知道了 vue-cli 3.x 为我们默认封装了项目运行的常用 webpack 配置，那么它给我们提供了哪些默认插件，每一个 plugin 又有着怎样的用途呢？除了使用 <code>vue inspect plugins</code> 我们还可以通过运行 <code>vue ui</code> 进入可视化页面查看，步骤如下：</p><ul><li>打开可视化页面，点击对应项目进入管理页面（如果没有对应项目，需要导入或新建）</li><li>点击侧边栏 Tasks 选项，再点击二级栏 inspect 选项</li><li>点击 Run task 按钮执行审查命令</li></ul><p>如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/22/164c15d1f97432b5?w=924&h=392&f=png&s=60624" alt></p><p>最后我们从输出的内容中找到 plugins 数组，其包含了如下插件（配置项已经省略，增加了定义插件的代码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// vue-loader是 webpack 的加载器，允许你以单文件组件的格式编写 Vue 组件</span><br><span class="line">const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);</span><br><span class="line"></span><br><span class="line">// webpack 内置插件，用于创建在编译时可以配置的全局常量</span><br><span class="line">const &#123; DefinePlugin &#125; = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">// 用于强制所有模块的完整路径必需与磁盘上实际路径的确切大小写相匹配</span><br><span class="line">const CaseSensitivePathsPlugin = require(&apos;case-sensitive-paths-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// 识别某些类型的 webpack 错误并整理，以提供开发人员更好的体验。</span><br><span class="line">const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// 将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件</span><br><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line"></span><br><span class="line">// 用于在 webpack 构建期间优化、最小化 CSS文件</span><br><span class="line">const OptimizeCssnanoPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// webpack 内置插件，用于根据模块的相对路径生成 hash 作为模块 id, 一般用于生产环境</span><br><span class="line">const &#123; HashedModuleIdsPlugin &#125; = require(&apos;webpack&apos;);</span><br><span class="line"></span><br><span class="line">// 用于根据模板或使用加载器生成 HTML 文件</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// 用于在使用 html-webpack-plugin 生成的 html 中添加 &lt;link rel =&apos;preload&apos;&gt; 或 &lt;link rel =&apos;prefetch&apos;&gt;，有助于异步加载</span><br><span class="line">const PreloadPlugin = require(&apos;preload-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">// 用于将单个文件或整个目录复制到构建目录</span><br><span class="line">const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        /* config.plugin(&apos;vue-loader&apos;) */</span><br><span class="line">        new VueLoaderPlugin(), </span><br><span class="line">        </span><br><span class="line">        /* config.plugin(&apos;define&apos;) */</span><br><span class="line">        new DefinePlugin(),</span><br><span class="line">        </span><br><span class="line">        /* config.plugin(&apos;case-sensitive-paths&apos;) */</span><br><span class="line">        new CaseSensitivePathsPlugin(),</span><br><span class="line">        </span><br><span class="line">        /* config.plugin(&apos;friendly-errors&apos;) */</span><br><span class="line">        new FriendlyErrorsWebpackPlugin(),</span><br><span class="line">        </span><br><span class="line">        /* config.plugin(&apos;extract-css&apos;) */</span><br><span class="line">        new MiniCssExtractPlugin(),</span><br><span class="line">        </span><br><span class="line">        /* config.plugin(&apos;optimize-css&apos;) */</span><br><span class="line">        new OptimizeCssnanoPlugin(),</span><br><span class="line">        </span><br><span class="line">        /* config.plugin(&apos;hash-module-ids&apos;) */</span><br><span class="line">        new HashedModuleIdsPlugin(),</span><br><span class="line">        </span><br><span class="line">        /* config.plugin(&apos;html&apos;) */</span><br><span class="line">        new HtmlWebpackPlugin(),</span><br><span class="line">        </span><br><span class="line">        /* config.plugin(&apos;preload&apos;) */</span><br><span class="line">        new PreloadPlugin(),</span><br><span class="line">        </span><br><span class="line">        /* config.plugin(&apos;copy&apos;) */</span><br><span class="line">        new CopyWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到每个插件上方都添加了使用 chainWebpack 访问的方式，同时我也添加了每个插件相应的用途注释，需要注意的是要区分 webpack 内置插件和第三方插件的区别，如果是内置插件则无需安装下载，而外部插件大家可以直接访问：<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a> 搜索对应的插件，了解其详细的 api 设置。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要阐述了 vue-cli 3.x 下基于 vue.config.js 配置 webpack 的主要方法，同时也介绍了其默认的 webpack 插件与主要功能，相信大家在了解 webpack 的知识后能够更加轻松的开展后续内容的学习，为接下来项目的构建和开发奠定基础。</p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>除了文章中介绍的配置项，<code>vue.config.js</code> 中还有哪些额外的配置？</p></li><li><p><code>webpack-merge</code> 的合并原理是怎样的？</p></li><li><p>使用 <code>chainWebpack</code> 获取到 webpack 中的某一插件后，如何修改其配置？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建基础篇 1</title>
      <link href="/2018/09/07/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%AF%87%201%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B8%8E%E9%85%8D%E7%BD%AE%E9%A1%B9/"/>
      <url>/2018/09/07/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%AF%87%201%EF%BC%9A%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B8%8E%E9%85%8D%E7%BD%AE%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="构建基础篇-1：你需要了解的包管理工具与配置项"><a href="#构建基础篇-1：你需要了解的包管理工具与配置项" class="headerlink" title="构建基础篇 1：你需要了解的包管理工具与配置项"></a>构建基础篇 1：你需要了解的包管理工具与配置项</h1><p>任何一个项目的构建离不开工具和统一的管理标准，在项目开发和维护过程中，我们需要了解安装包的相应工具和配置文件，以此来有效的进行项目的迭代和版本的更新，为项目提供基本的运行环境。本文将详细介绍构建 Vue.js 项目相关的依赖包安装工具和相应的配置文件，为大家提供参考。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>相信大家对于包管理工具的使用一定不会陌生，毕竟它已经成为前端项目中必不可少的一部分，为了照顾部分零基础用户，这里我们做一个简单的介绍。</p><h3 id="1-npm-与-package-json"><a href="#1-npm-与-package-json" class="headerlink" title="1. npm 与 package.json"></a>1. npm 与 package.json</h3><p>npm 是 Node Package Manager 的简称，顾名思义，它是 node 的包管理工具，也是目前世界上最大的开源库生态系统。官方地址为：<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a>，你可以在里面找到数以万计的开源包。</p><p>使用 npm 包下载量统计工具，比如 <a href="https://npm-stat.com/" target="_blank" rel="noopener">npm-start</a>，我们可以查看相应包在一定时间范围内的下载量数据，下面是 <code>vue-cli</code> 和 <code>@vue/cli</code> 的下载量趋势：</p><p><img src="https://user-gold-cdn.xitu.io/2018/6/27/16441d9cefe89881?w=988&h=396&f=png&s=56257" alt></p><p>在上篇文章中我们介绍了使用 vue-cli 来构建自己的项目，并生成了相应的目录结构，而在最外层目录中，我们可以看到有 <code>package.json</code> 这一文件，该文件便是我们需要了解的包管理文件。</p><p>我们先来看一下该文件里面的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;my-project&quot;, </span><br><span class="line">    &quot;version&quot;: &quot;0.1.0&quot;, </span><br><span class="line">    &quot;private&quot;: true, </span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">        &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">        &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;vue&quot;: &quot;^2.5.16&quot;,</span><br><span class="line">        &quot;vue-router&quot;: &quot;^3.0.1&quot;,</span><br><span class="line">        &quot;vuex&quot;: &quot;^3.0.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;devDependencies&quot;: &#123;</span><br><span class="line">        &quot;@vue/cli-plugin-babel&quot;: &quot;^3.0.0-beta.15&quot;,</span><br><span class="line">        &quot;@vue/cli-service&quot;: &quot;^3.0.0-beta.15&quot;,</span><br><span class="line">        &quot;less&quot;: &quot;^3.0.4&quot;,</span><br><span class="line">        &quot;less-loader&quot;: &quot;^4.1.0&quot;,</span><br><span class="line">        &quot;vue-template-compiler&quot;: &quot;^2.5.16&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;browserslist&quot;: [</span><br><span class="line">        &quot;&gt; 1%&quot;,</span><br><span class="line">        &quot;last 2 versions&quot;,</span><br><span class="line">        &quot;not ie &lt;= 8&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到该文件是由一系列键值对构成的 JSON 对象，每一个键值对都有其相应的作用，比如 scripts 脚本命令的配置，我们在终端启动项目运行的 <code>npm run serve</code> 命令其实便是执行了 scripts 配置下的 serve 项命令 <code>vue-cli-service serve</code> ，我们可以在 scripts 下自己修改或添加相应的项目命令。</p><p>而 dependencies 和 devDependencies 分别为项目生产环境和开发环境的依赖包配置，也就是说像 <code>@vue/cli-service</code> 这样只用于项目开发时的包我们可以放在 devDependencies 下，但像 <code>vue-router</code> 这样结合在项目上线代码中的包应该放在 dependencies 下。</p><p>详细的package.json文件配置项介绍可以参考：<a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">package.json</a></p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><p>在简单的了解了 package.json 文件后，我们再来看下包管理工具的常用命令。一般在项目的构建和开发阶段，我们常用的 npm 命令有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 生成 package.json 文件（需要手动选择配置）</span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line"># 生成 package.json 文件（使用默认配置）</span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line"># 一键安装 package.json 下的依赖包</span><br><span class="line">npm i</span><br><span class="line"></span><br><span class="line"># 在项目中安装包名为 xxx 的依赖包（配置在 dependencies 下）</span><br><span class="line">npm i xxx</span><br><span class="line"></span><br><span class="line"># 在项目中安装包名为 xxx 的依赖包（配置在 dependencies 下）</span><br><span class="line">npm i xxx --save</span><br><span class="line"></span><br><span class="line"># 在项目中安装包名为 xxx 的依赖包（配置在 devDependencies 下）</span><br><span class="line">npm i xxx --save-dev</span><br><span class="line"></span><br><span class="line"># 全局安装包名为 xxx 的依赖包</span><br><span class="line">npm i -g xxx</span><br><span class="line"></span><br><span class="line"># 运行 package.json 中 scripts 下的命令</span><br><span class="line">npm run xxx</span><br></pre></td></tr></table></figure><p>比较陌生但实用的有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打开 xxx 包的主页</span><br><span class="line">npm home xxx</span><br><span class="line"></span><br><span class="line"># 打开 xxx 包的代码仓库</span><br><span class="line">npm repo xxx</span><br><span class="line"></span><br><span class="line"># 将当前模块发布到 npmjs.com，需要先登录</span><br><span class="line">npm publish</span><br></pre></td></tr></table></figure><p>相比 npm，<a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener">yarn</a> 相信大家也不会陌生，它是由 facebook 推出并开源的包管理工具，具有速度快，安全性高，可靠性强等主要优势，它的常用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 生成 package.json 文件（需要手动选择配置）</span><br><span class="line">yarn init</span><br><span class="line"></span><br><span class="line"># 生成 package.json 文件（使用默认配置）</span><br><span class="line">yarn init -y</span><br><span class="line"></span><br><span class="line"># 一键安装 package.json 下的依赖包</span><br><span class="line">yarn</span><br><span class="line"></span><br><span class="line"># 在项目中安装包名为 xxx 的依赖包（配置在 dependencies 下）,同时 yarn.lock 也会被更新</span><br><span class="line">yarn add xxx</span><br><span class="line"></span><br><span class="line"># 在项目中安装包名为 xxx 的依赖包（配置在配置在 devDependencies 下）,同时 yarn.lock 也会被更新</span><br><span class="line">yarn add xxx --dev</span><br><span class="line"></span><br><span class="line"># 全局安装包名为 xxx 的依</span><br><span class="line">yarn global add xxx</span><br><span class="line"></span><br><span class="line"># 运行 package.json 中 scripts 下的命令</span><br><span class="line">yarn xxx</span><br></pre></td></tr></table></figure><p>比较陌生但实用的有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 列出 xxx 包的版本信息</span><br><span class="line">yarn outdated xxx</span><br><span class="line"></span><br><span class="line"># 验证当前项目 package.json 里的依赖版本和 yarn 的 lock 文件是否匹配</span><br><span class="line">yarn check</span><br><span class="line"></span><br><span class="line"># 将当前模块发布到 npmjs.com，需要先登录</span><br><span class="line">yarn publish</span><br></pre></td></tr></table></figure><p>以上便是 npm 与 yarn 包管理工具的常用及实用命令，需要注意的是，本小册的讲解将会优先使用 yarn 命令进行包的管理和安装。</p><h3 id="3-第三方插件配置"><a href="#3-第三方插件配置" class="headerlink" title="3. 第三方插件配置"></a>3. 第三方插件配置</h3><p>在上方的 package.json 文件中我们可以看到有 browserslist 这一配置项，那么该配置项便是这里所说的第三方插件配置，该配置的主要作用是用于在不同的前端工具之间共享目标浏览器和 Node.js 的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;: [</span><br><span class="line">    &quot;&gt; 1%&quot;, // 表示包含所有使用率 &gt; 1% 的浏览器</span><br><span class="line">    &quot;last 2 versions&quot;, // 表示包含浏览器最新的两个版本</span><br><span class="line">    &quot;not ie &lt;= 8&quot; // 表示不包含 ie8 及以下版本</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>比如像 <a href="https://www.npmjs.com/package/autoprefixer" target="_blank" rel="noopener">autoprefixer</a> 这样的插件需要把你写的 css 样式适配不同的浏览器，那么这里要针对哪些浏览器呢，就是上面配置中所包含的。</p><p>而如果写在 autoprefixer 的配置中，那么会存在一个问题，万一其他第三方插件也需要浏览器的包含范围用于实现其特定的功能，那么就又得在其配置中设置一遍，这样就无法得以共用。所以在 package.json 中配置 browserslist 的属性使得所有工具都会自动找到目标浏览器。</p><p>当然，你也可以单独写在 .browserslistrc 的文件中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Browsers that we support </span><br><span class="line"></span><br><span class="line">&gt; 1%</span><br><span class="line">last 2 versions</span><br><span class="line">not ie &lt;= 8</span><br></pre></td></tr></table></figure><p>至于它是如何去衡量浏览器的使用率和版本的，数据都是来源于 <a href="https://caniuse.com/" target="_blank" rel="noopener">Can I Use</a>。你也可以访问 <a href="http://browserl.ist/" target="_blank" rel="noopener">http://browserl.ist/</a> 去搜索配置项所包含的浏览器列表，比如搜索 <code>last 2 versions</code> 会得到你想要的结果，或者在项目终端运行如下命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx browserslist</span><br></pre></td></tr></table></figure><p>除了上述插件的配置，项目中常用的插件还有：babel、postcss 等，有兴趣的同学可以访问其官网进行了解。</p><h3 id="4-vue-cli-包安装"><a href="#4-vue-cli-包安装" class="headerlink" title="4. vue-cli 包安装"></a>4. vue-cli 包安装</h3><p>在上述的教程中，我们使用 npm 或 yarn 进行了包的安装和配置，除了以上两种方法，vue-cli 3.x 还提供了其专属的 <code>vue add</code> 命令，但是需要注意的是该命令安装的包是以 @vue/cli-plugin 或者 vue-cli-plugin 开头，即只能安装 Vue 集成的包。</p><p>比如运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add jquery</span><br></pre></td></tr></table></figure><p>其会安装 <code>vue-cli-plugin-jquery</code>，很显然这个插件不存在便会安装失败。又或者你运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add @vue/eslint</span><br></pre></td></tr></table></figure><p>其会解析为完整的包名 <code>@vue/cli-plugin-eslint</code>，因为该包存在所以会安装成功。</p><p>同时，不同于 npm 或 yarn 的安装， <code>vue add</code> 不仅会将包安装到你的项目中，其还会改变项目的代码或文件结构，所以安装前最好提交你的代码至仓库。</p><p>另外 vue add 中还有两个特例，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装 vue-router</span><br><span class="line">vue add router</span><br><span class="line"></span><br><span class="line"># 安装 vuex</span><br><span class="line">vue add vuex</span><br></pre></td></tr></table></figure><p>这两个命令会直接安装 vue-router 和 vuex 并改变你的代码结构，使你的项目集成这两个配置，并不会去安装添加 vue-cli-plugin 或 @vue/cli-plugin 前缀的包。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>不积跬步无以至千里，不积小流无以成江海。本文主要介绍了在 Vue 项目构建前期需要了解的包管理工具与配置的知识点，只有了解了基本的工具使用才能熟练的对项目进行按需配置，希望大家在接下来的学习中能够学以致用，付诸实践。</p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>文章中使用的一些 npm 包名为什么要用 <code>@</code> 开头？</p></li><li><p>除了文章中介绍的 <code>browserslist</code> 这样的配置项可以写在单独的文件中外，还有哪些常用的配置项可以这样操作？又是如何配置的？</p></li><li><p>Vue CLI 3 还集成了哪些包，可以通过 <code>vue add</code> 命令安装？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建基础篇 3</title>
      <link href="/2018/09/07/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%AF%87%203%EF%BC%9Aenv%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/09/07/%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%AF%87%203%EF%BC%9Aenv%20%E6%96%87%E4%BB%B6%E4%B8%8E%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="构建基础篇-3：env-文件与环境设置"><a href="#构建基础篇-3：env-文件与环境设置" class="headerlink" title="构建基础篇 3：env 文件与环境设置"></a>构建基础篇 3：env 文件与环境设置</h1><p>在实际项目的开发中，我们一般会经历项目的开发阶段、测试阶段和最终上线阶段，每一个阶段对于项目代码的要求可能都不尽相同，那么我们如何能够游刃有余的在不同阶段下使我们的项目呈现不同的效果，使用不同的功能呢？这里就需要引入<strong>环境</strong>的概念。</p><p>一般一个项目都会有以下 3 种环境：</p><ul><li>开发环境（开发阶段，本地开发版本，一般会使用一些调试工具或额外的辅助功能）</li><li>测试环境（测试阶段，上线前版本，除了一些 bug 的修复，基本不会和上线版本有很大差别）</li><li>生产环境（上线阶段，正式对外发布的版本，一般会进行优化，关掉错误报告）</li></ul><p>作为一名开发人员，我们可能需要针对每一种环境编写一些不同的代码并且保证这些代码运行在正确的环境中，那么我们应该如何在代码中判断项目所处的环境同时执行不同的代码呢？这就需要我们进行正确的环境配置和管理。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h3><p>正确的配置环境首先需要我们认识不同环境配置之间的关系，如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/16749778e85b5370?w=356&h=318&f=png&s=24190" alt></p><p>我们从上图中可以了解到每一个环境其实有其不同的配置，同时它们也存在着交集部分，交集便是它们都共有的配置项，那么在 Vue 中我们应该如何处理呢？</p><p>我们可以在根目录下创建以下形式的文件进行不同环境下变量的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.env                # 在所有的环境中被载入</span><br><span class="line">.env.local          # 在所有的环境中被载入，但会被 git 忽略</span><br><span class="line">.env.[mode]         # 只在指定的模式中被载入</span><br><span class="line">.env.[mode].local   # 只在指定的模式中被载入，但会被 git 忽略</span><br></pre></td></tr></table></figure><p>比如我们创建一个名为 .env.stage 的文件，该文件表明其只在 stage 环境下被加载，在这个文件中，我们可以配置如下键值对的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=stage</span><br><span class="line">VUE_APP_TITLE=stage mode</span><br></pre></td></tr></table></figure><p>这时候我们怎么在 vue.config.js 中访问这些变量呢？很简单，使用 <code>process.env.[name]</code> 进行访问就可以了，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line"></span><br><span class="line">console.log(process.env.NODE_ENV); // development（在终端输出）</span><br></pre></td></tr></table></figure><p>当你运行 <code>yarn serve</code> 命令后会发现输出的是 development，因为 <code>vue-cli-service serve</code> 命令默认设置的环境是 development，你需要修改 package.json 中的 serve 脚本的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve --mode stage&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>--mode stage</code> 其实就是修改了 webpack 4 中的 mode 配置项为 stage，同时其会读取对应 .env.[model] 文件下的配置，如果没找到对应配置文件，其会使用默认环境 development，同样 <code>vue-cli-service build</code> 会使用默认环境 production。</p><p>这时候如果你再创建一个 .env 的文件，再次配置重复的变量，但是值不同，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=staging</span><br><span class="line">VUE_APP_TITLE=staging mode</span><br><span class="line">VUE_APP_NAME=project</span><br></pre></td></tr></table></figure><p>因为 .env 文件会被所有环境加载，即公共配置，那么最终我们运行 <code>vue-cli-service serve</code> 打印出来的是哪个呢？答案是 <strong>stage</strong>，但是如果是 .env.stage.local 文件中配置成上方这样，答案便是 <strong>staging</strong>，所以 .env.[mode].local 会覆盖 .env.[mode] 下的相同配置。同理 .env.local 会覆盖 .env 下的相同配置。</p><p>由此可以得出结论，相同配置项的权重：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.env.[mode].local &gt; .env.[mode] &gt; .env.local &gt; .env</span><br></pre></td></tr></table></figure><p>但是需要注意的是，除了相同配置项权重大的覆盖小的，不同配置项它们会进行合并操作，类似于 Javascript 中的 Object.assign 的用法。</p><h3 id="2-环境注入"><a href="#2-环境注入" class="headerlink" title="2. 环境注入"></a>2. 环境注入</h3><p>通过上述配置文件的创建，我们成功使用命令行的形式对项目环境进行了设置并可以自由切换，但是需要注意的是我们在 Vue 的前端代码中打印出的 <code>process.env</code> 与 vue.config.js 中输出的可能是不一样的，这需要普及一个知识点：webpack 通过 DefinePlugin 内置插件将 process.env 注入到客户端代码中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// webpack 配置</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.DefinePlugin(&#123;</span><br><span class="line">            &apos;process.env&apos;: &#123;</span><br><span class="line">                NODE_ENV: JSON.stringify(process.env.NODE_ENV)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 vue-cli 3.x 封装的 webpack 配置中已经帮我们完成了这个功能，所以我们可以直接在客户端代码中打印出 process.env 的值，该对象可以包含多个键值对，也就是说可以注入多个值，但是经过 CLI 封装后仅支持注入环境配置文件中以 <code>VUE_APP_</code> 开头的变量，而 <code>NODE_ENV</code> 和 <code>BASE_URL</code> 这两个特殊变量除外。比如我们在权重最高的 .env.stage.local 文件中写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=stage2</span><br><span class="line">VUE_APP_TITLE=stage mode2</span><br><span class="line">NAME=vue</span><br></pre></td></tr></table></figure><p>然后我们尝试在 vue.config.js 中打印 <code>process.env</code>，终端输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    npm_config_ignore_scripts: &apos;&apos;,</span><br><span class="line">    npm_config_version_git_sign: &apos;&apos;,</span><br><span class="line">    npm_config_ignore_optional: &apos;&apos;,</span><br><span class="line">    npm_config_init_version: &apos;1.0.0&apos;,</span><br><span class="line">    npm_package_dependencies_vue_router: &apos;^3.0.1&apos;,</span><br><span class="line">    npm_config_version_tag_prefix: &apos;v&apos;,</span><br><span class="line">    npm_node_execpath: &apos;/usr/local/bin/node&apos;,</span><br><span class="line">    NODE_ENV: &apos;stage2&apos;,</span><br><span class="line">    VUE_APP_TITLE: &apos;stage mode2&apos;,</span><br><span class="line">    NAME: &apos;vue&apos;,</span><br><span class="line">    BABEL_ENV: &apos;development&apos;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到输出内容除了我们环境配置中的变量外还包含了很多 npm 的信息，但是我们在入口文件 main.js 中打印会发现输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;BASE_URL&quot;: &quot;/vue/&quot;,</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;stage2&quot;,</span><br><span class="line">    &quot;VUE_APP_TITLE&quot;: &quot;stage mode2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见注入时过滤调了非 <code>VUE_APP_</code> 开头的变量，其中多出的 <code>BASE_URL</code> 为你在 vue.config.js 设置的值，默认为 /，其在环境配置文件中设置无效。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/167497acd942516e?w=544&h=308&f=png&s=32493" alt></p><h3 id="3-额外配置"><a href="#3-额外配置" class="headerlink" title="3. 额外配置"></a>3. 额外配置</h3><p>以上我们通过新建配置文件的方式为项目不同环境配置不同的变量值，能够实现项目基本的环境管理，但是 .env 这样的配置文件中的参数目前只支持静态值，无法使用动态参数，在某些情况下无法实现特定需求，这时候我们可以在根目录下新建 config 文件夹用于存放一些额外的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* 配置文件 index.js */</span><br><span class="line"></span><br><span class="line">// 公共变量</span><br><span class="line">const com = &#123;</span><br><span class="line">    IP: JSON.stringify(&apos;xxx&apos;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"></span><br><span class="line">    // 开发环境变量</span><br><span class="line">    dev: &#123;</span><br><span class="line">    env: &#123;</span><br><span class="line">            TYPE: JSON.stringify(&apos;dev&apos;),</span><br><span class="line">            ...com</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    // 生产环境变量</span><br><span class="line">    build: &#123;</span><br><span class="line">    env: &#123;</span><br><span class="line">            TYPE: JSON.stringify(&apos;prod&apos;),</span><br><span class="line">            ...com</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方代码我们把环境变量分为了公共变量、开发环境变量和生产环境变量，当然这些变量可能是动态的，比如用户的 ip 等。现在我们要在 vue.config.js 里注入这些变量，我们可以使用 chainWebpack 修改 DefinePlugin 中的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line">const configs = require(&apos;./config&apos;);</span><br><span class="line"></span><br><span class="line">// 用于做相应的 merge 处理</span><br><span class="line">const merge = require(&apos;webpack-merge&apos;);</span><br><span class="line"></span><br><span class="line">// 根据环境判断使用哪份配置</span><br><span class="line">const cfg = process.env.NODE_ENV === &apos;production&apos; ? configs.build.env : configs.dev.env;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    chainWebpack: config =&gt; &#123;</span><br><span class="line">        config.plugin(&apos;define&apos;)</span><br><span class="line">            .tap(args =&gt; &#123;</span><br><span class="line">                let name = &apos;process.env&apos;;</span><br><span class="line">                </span><br><span class="line">                // 使用 merge 保证原始值不变</span><br><span class="line">                args[0][name] = merge(args[0][name], cfg);</span><br><span class="line">    </span><br><span class="line">                return args</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们可以在客户端成功打印出包含动态配置的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;NODE_ENV&quot;: &quot;stage2&quot;,</span><br><span class="line">    &quot;VUE_APP_TITLE&quot;: &quot;stage mode2&quot;,</span><br><span class="line">    &quot;BASE_URL&quot;: &quot;/vue/&quot;,</span><br><span class="line">    &quot;TYPE&quot;: &quot;dev&quot;,</span><br><span class="line">    &quot;IP&quot;: &quot;xxx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-实际场景"><a href="#4-实际场景" class="headerlink" title="4. 实际场景"></a>4. 实际场景</h3><p>结合以上环境变量的配置，我们项目中一般会遇到一些实际场景： 比如在非线上环境我们可以给自己的移动端项目开启 <a href="https://github.com/Tencent/vConsole" target="_blank" rel="noopener">vConsole</a> 调试，但是在线上环境肯定不需要开启这一功能，我们可以在入口文件中进行设置，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* main.js */</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line">import store from &apos;./store&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">// 如果是非线上环境，加载 VConsole</span><br><span class="line">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    var VConsole = require(&apos;vconsole/dist/vconsole.min.js&apos;);</span><br><span class="line">    var vConsole = new VConsole();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><p>vConsole 是一款用于移动网页的轻量级，可扩展的前端开发工具，可以看作是移动端浏览器的控制台，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/25/164d2204ddfd1384?w=320&h=568&f=png&s=57903" alt></p><p>另外我们还可以使用配置中的 BASE_URL 来设置路由的 base 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* router.js */</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">import Home from &apos;./views/Home.vue&apos;</span><br><span class="line">import About from &apos;./views/About.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">let base = `$&#123;process.env.BASE_URL&#125;`; // 获取二级目录</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    base: base, // 设置 base 值</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/&apos;,</span><br><span class="line">            name: &apos;home&apos;,</span><br><span class="line">            component: Home</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/about&apos;,</span><br><span class="line">            name: &apos;about&apos;,</span><br><span class="line">            component: About</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>每一个环境变量你都可以用于项目的一些地方，它提供给了我们一种全局的可访问形式，也是基于 Node 开发的特性所在。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>环境的配置和管理对于项目的构建起到了至关重要的作用，通过给项目配置不同的环境不仅可以增加开发的灵活性、提高程序的拓展性，同时也有助于帮助我们去了解并分析项目在不同环境下的运行机制，建立全局观念。</p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>webpack 通过 DefinePlugin 内置插件将 process.env 注入到客户端代码中时，<code>process.env.NODE_ENV</code> 为什么要进行 JSON.stringify 处理？</p></li><li><p><code>process.env</code> 中如何获取 package.json 中 name 的值？</p></li><li><p>如何在 package.json 中的 scripts 字段中定义一些自定义脚本来切换不同的环境？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建实战篇 3</title>
      <link href="/2018/09/07/%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98%E7%AF%87%203%EF%BC%9A%E5%A4%9A%E9%A1%B5%E8%B7%AF%E7%94%B1%E4%B8%8E%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/09/07/%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98%E7%AF%87%203%EF%BC%9A%E5%A4%9A%E9%A1%B5%E8%B7%AF%E7%94%B1%E4%B8%8E%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="构建实战篇-3：多页路由与模板解析"><a href="#构建实战篇-3：多页路由与模板解析" class="headerlink" title="构建实战篇 3：多页路由与模板解析"></a>构建实战篇 3：多页路由与模板解析</h1><p>上篇文章中我们成功打包并输出了多页文件，而构建一个多页应用能够让我们进一步了解项目配置的可拓展性，可以对学习 Vue 和 webpack 起到强化训练的效果，本文将在此基础上主要针对多页路由及模板的配置进行系列的介绍。</p><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><h3 id="1-跳转"><a href="#1-跳转" class="headerlink" title="1. 跳转"></a>1. 跳转</h3><p>在配置路由前，首先我们要明确一点就是，多页应用中的每个单页都是相互隔离的，即如果你想从 page1 下的路由跳到 page2 下的路由，你无法使用 vue-router 中的方法进行跳转，需要使用原生方法：<code>location.href</code> 或 <code>location.replace</code>。</p><p>此外为了能够清晰的分辨路由属于哪个单页，我们应该给每个单页路由添加前缀，比如：</p><ul><li>index 单页：/vue/</li><li>page1 单页：/vue/page1/</li><li>page2 单页：/vue/page2/</li></ul><p>其中 /vue/ 为项目的二级目录，其后的目录代表路由属于哪个单页。因此我们每个单页的路由配置可以像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* page1 单页路由配置 */</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line"></span><br><span class="line">// 首页</span><br><span class="line">const Home = (resolve =&gt; &#123;</span><br><span class="line">    require.ensure([&apos;../views/home.vue&apos;], () =&gt; &#123;</span><br><span class="line">        resolve(require(&apos;../views/home.vue&apos;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">let base = `$&#123;process.env.BASE_URL&#125;` + &apos;page1&apos;; // 添加单页前缀</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    base: base,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/&apos;,</span><br><span class="line">            name: &apos;home&apos;,</span><br><span class="line">            component: Home</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们通过设置路由的 base 值来为每个单页添加路由前缀，如果是 index 单页我们无需拼接路由前缀，直接跳转至二级目录即可。</p><p>那么在单页间跳转的地方，我们可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;nav&quot;&gt;</span><br><span class="line">      &lt;a @click=&quot;goFn(&apos;&apos;)&quot;&gt;Index&lt;/a&gt; |</span><br><span class="line">      &lt;a @click=&quot;goFn(&apos;page1&apos;)&quot;&gt;Page1&lt;/a&gt; |</span><br><span class="line">      &lt;a @click=&quot;goFn(&apos;page2&apos;)&quot;&gt;Page2&lt;/a&gt; |</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        goFn(name) &#123;</span><br><span class="line">            location.href = `$&#123;process.env.BASE_URL&#125;` + name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>但是为了保持和 Vue 路由跳转同样的风格，我可以对单页之间的跳转做一下封装，实现一个 <code>Navigator</code> 类，类的代码可以查看本文最后的示例，封装完成后我们可以将跳转方法修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.$openRouter(&#123;</span><br><span class="line">    name: name, // 跳转地址</span><br><span class="line">    query: &#123;</span><br><span class="line">        text: &apos;hello&apos; // 可以进行参数传递</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用上述 <code>$openRouter</code> 方法我们还需要一个前提条件，便是将其绑定到 Vue 的原型链上，我们在所有单页的入口文件中添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Navigator &#125; from &apos;../../common&apos; // 引入 Navigator</span><br><span class="line"></span><br><span class="line">Vue.prototype.$openRouter = Navigator.openRouter; // 添加至 Vue 原型链</span><br></pre></td></tr></table></figure><p>至此我们已经能够成功模仿 vue-router 进行单页间的跳转，但是需要注意的是因为其本质使用的是 location 跳转，所以必然会产生浏览器的刷新与重载。</p><h3 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2. 重定向"></a>2. 重定向</h3><p>当我们完成上述路由跳转的功能后，可以在本地服务器上来进行一下测试，你会发现 Index 首页可以正常打开，但是跳转 Page1、Page2 却仍然处于 Index 父组件下，这是因为浏览器认为你所要跳转的页面还是在 Index 根路由下，同时又没有匹配到 Index 单页中对应的路由。这时候我们服务器需要做一次重定向，将下方路由指向对应的 html 文件即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/vue/page1 -&gt; /vue/page1.html</span><br><span class="line">/vue/page2 -&gt; /vue/page2.html</span><br></pre></td></tr></table></figure><p>在 vue.config.js 中，我们需要对 devServer 进行配置，添加 <code>historyApiFallback</code> 配置项，该配置项主要用于解决 HTML5 History API 产生的问题，比如其 rewrites 选项用于重写路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line"></span><br><span class="line">let baseUrl = &apos;/vue/&apos;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: &#123;</span><br><span class="line">            rewrites: [</span><br><span class="line">                &#123; from: new RegExp(baseUrl + &apos;page1&apos;), to: baseUrl + &apos;page1.html&apos; &#125;,</span><br><span class="line">                &#123; from: new RegExp(baseUrl + &apos;page2&apos;), to: baseUrl + &apos;page2.html&apos; &#125;,</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方我们通过 rewrites 匹配正则表达式的方式将 <code>/vue/page1</code> 这样的路由替换为访问服务器下正确 html 文件的形式，如此不同单页间便可以进行正确跳转和访问了。最后需要注意的是如果你的应用发布到正式服务器上，你同样需要让服务器或者中间层作出合理解析，参考：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">HTML5 History 模式 # 后端配置例子</a></p><p>而更多关于 historyApiFallback 的信息可以访问：<a href="https://github.com/bripkens/connect-history-api-fallback" target="_blank" rel="noopener">connect-history-api-fallback</a></p><h2 id="模板配置"><a href="#模板配置" class="headerlink" title="模板配置"></a>模板配置</h2><p>上篇文章我们已经介绍了关于多模板的读取和配置，在配置 html-webpack-plugin 的时候我们提到了自定义配置，这里我将结合模板渲染的功能来进行统一介绍。</p><h3 id="1-模板渲染"><a href="#1-模板渲染" class="headerlink" title="1. 模板渲染"></a>1. 模板渲染</h3><p>这里所说的模板渲染是在我们的 html 模板文件中使用 html-webpack-plugin 提供的 <a href="https://github.com/jaketrent/html-webpack-template/blob/86f285d5c790a6c15263f5cc50fd666d51f974fd/index.html" target="_blank" rel="noopener">default template</a> 语法进行模板编写，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;模板&lt;/title&gt;</span><br><span class="line">    &lt;% for (var chunk in htmlWebpackPlugin.files.css) &#123; %&gt;</span><br><span class="line">        &lt;% if(htmlWebpackPlugin.files.css[chunk]) &#123;%&gt;</span><br><span class="line">            &lt;link href=&quot;&lt;%= htmlWebpackPlugin.files.css[chunk] %&gt;&quot; rel=&quot;stylesheet&quot; /&gt;</span><br><span class="line">        &lt;%&#125;%&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;!-- built files will be auto injected --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;% for (var chunk in htmlWebpackPlugin.files.js) &#123; %&gt;</span><br><span class="line">        &lt;% if(htmlWebpackPlugin.files.js[chunk]) &#123;%&gt;</span><br><span class="line">            &lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= htmlWebpackPlugin.files.js[chunk] %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;%&#125;%&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>以上我们使用模板语法手动获取并遍历 htmlWebpackPlugin 打包后的文件并生成到模板中，其中的 <code>htmlWebpackPlugin</code> 变量是模板提供的可访问变量，其有以下特定数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;htmlWebpackPlugin&quot;: &#123;</span><br><span class="line">    &quot;files&quot;: &#123;</span><br><span class="line">        &quot;css&quot;: [ &quot;main.css&quot; ],</span><br><span class="line">        &quot;js&quot;: [ &quot;assets/head_bundle.js&quot;, &quot;assets/main_bundle.js&quot;],</span><br><span class="line">        &quot;chunks&quot;: &#123;</span><br><span class="line">            &quot;head&quot;: &#123;</span><br><span class="line">                &quot;entry&quot;: &quot;assets/head_bundle.js&quot;,</span><br><span class="line">                &quot;css&quot;: [ &quot;main.css&quot; ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;main&quot;: &#123;</span><br><span class="line">                &quot;entry&quot;: &quot;assets/main_bundle.js&quot;,</span><br><span class="line">                &quot;css&quot;: []</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过 <code>htmlWebpackPlugin.files</code> 可以获取打包输出的 js 及 css 文件路径，包括入口文件路径等。</p><p>需要注意的是如果你在模板中编写了插入对应 js 及 css 的语法，你需要设置 <code>inject</code> 的值为 false 来关闭资源的自动注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* utils.js */</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">let conf = &#123;</span><br><span class="line">    entry: filePath, // page 的入口</span><br><span class="line">    template: filePath, // 模板路径</span><br><span class="line">    filename: filename + &apos;.html&apos;, // 生成 html 的文件名</span><br><span class="line">    chunks: [&apos;manifest&apos;, &apos;vendor&apos;,  filename],</span><br><span class="line">    inject: false, // 关闭资源自动注入</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>否则在页面会引入两次资源，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/3/164fb7b172500b55?w=560&h=512&f=png&s=135647" alt></p><h3 id="2-自定义配置"><a href="#2-自定义配置" class="headerlink" title="2. 自定义配置"></a>2. 自定义配置</h3><p>在模板渲染中，我们只能够使用 htmlWebpackPlugin 内部的一些属性和方法来进行模板的定制化开发，那么如果遇到需要根据不同环境来引入不同资源，同时不同模板间的配置还可能不一样的需求情况的话，我们使用自定义配置会比较方便。比如我们需要在生产环境模板中引入第三方统计脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    pages: utils.setPages(&#123;</span><br><span class="line">        addScript() &#123;</span><br><span class="line">            if (process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">                return `</span><br><span class="line">                    &lt;script src=&quot;https://s95.cnzz.com/z_stat.php?id=xxx&amp;web_id=xxx&quot; language=&quot;JavaScript&quot;&gt;&lt;/script&gt;</span><br><span class="line">                `</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在页面模板中通过 <code>htmlWebpackPlugin.options</code> 获取自定义配置对象并进行输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(htmlWebpackPlugin.options.addScript)&#123; %&gt;</span><br><span class="line">    &lt;%= htmlWebpackPlugin.options.addScript() %&gt;</span><br><span class="line">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure><p>同时你也可以针对个别模板进行配置，比如我想只在 Index 单页中添加统计脚本，在 Page1 单页中添加其他脚本，那么你可以给 addScript 传入标识符来进行判断输出，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(htmlWebpackPlugin.options.addScript)&#123; %&gt;</span><br><span class="line">    &lt;%= htmlWebpackPlugin.options.addScript(&apos;index&apos;) %&gt;</span><br><span class="line">&lt;%&#125;%&gt;</span><br></pre></td></tr></table></figure><p>同时为 addScript 方法添加参数 from：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">addScript(from) &#123;</span><br><span class="line">    if (process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">        let url = &quot;https://xxx&quot;;</span><br><span class="line">    </span><br><span class="line">        if (from === &apos;index&apos;) &#123;</span><br><span class="line">            url = &quot;https://s95.cnzz.com/z_stat.php?id=xxx&amp;web_id=xxx&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return `</span><br><span class="line">            &lt;script src=$&#123;url&#125; language=&quot;JavaScript&quot;&gt;&lt;/script&gt;</span><br><span class="line">        `</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就完成了自定义配置中的模板渲染功能。当然根据实际项目需求你的自定义配置项可能会更加复杂和灵活。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过 2 小节的学习，相信大家对 Vue 多页应用的构建已经有所了解。本文在第 1 节的基础上重点介绍了多页路由及模板的配置，阐述了其与单页应用的不同之处，同时针对模板自定义配置的使用场景给出了简单的实例，希望大家在了解的基础上将下方的实例代码作为参考，进行相应的实战。</p><p>本案例代码地址：<a href="https://github.com/luozhihao/vue-project-code/tree/master/multi-page-project" target="_blank" rel="noopener">multi-page-project</a></p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>多页应用中各自的 <code>Vuex Store</code> 信息能实现共享吗？</p></li><li><p>html-webpack-plugin 如何解析非 .html 的模板，比如 .hbs，应该如何配置？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建实战篇 1</title>
      <link href="/2018/09/07/%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98%E7%AF%87%201%EF%BC%9A%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/07/%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98%E7%AF%87%201%EF%BC%9A%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="构建实战篇-1：单页应用的基本配置"><a href="#构建实战篇-1：单页应用的基本配置" class="headerlink" title="构建实战篇 1：单页应用的基本配置"></a>构建实战篇 1：单页应用的基本配置</h1><p>前几篇文章我们介绍了 Vue 项目构建及运行的前期工作，包括 webpack 的配置、环境变量的使用等，在了解并掌握了这些前期准备工作后，那么接下来我们可以走进 Vue 项目的内部，一探其内部配置的基本构成。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/26/164d69c00ea9e1cc?w=565&h=308&f=png&s=23017" alt></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="1-路由配置"><a href="#1-路由配置" class="headerlink" title="1. 路由配置"></a>1. 路由配置</h3><p>由于 Vue 这类型的框架都是以一个或多个单页构成，在单页内部跳转并不会重新渲染 HTML 文件，其路由可以由前端进行控制，因此我们需要在项目内部编写相应的路由文件，Vue 会解析这些文件中的配置并进行对应的跳转渲染。</p><p>我们来看一下 CLI 给我们生成的 router.js 文件的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* router.js */</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line">import Home from &apos;./views/Home.vue&apos; // 引入 Home 组件</span><br><span class="line">import About from &apos;./views/About.vue&apos; // 引入 About 组件</span><br><span class="line"></span><br><span class="line">Vue.use(Router) // 注册路由</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path: &apos;/&apos;,</span><br><span class="line">        name: &apos;home&apos;,</span><br><span class="line">        component: Home</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        path: &apos;/about&apos;,</span><br><span class="line">        name: &apos;about&apos;,</span><br><span class="line">        component: About</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这份配置可以算是最基础的路由配置，有以下几点需要进行优化：</p><ul><li>如果路由存在二级目录，需要添加 base 属性，否则默认为 “/“</li><li>默认路由模式是 hash 模式，会携带 # 标记，与真实 url 不符，可以改为 history 模式</li><li>页面组件没有进行按需加载，可以使用 <code>require.ensure()</code> 来进行优化</li></ul><p>下面是我们优化结束的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* router.js */</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Router from &apos;vue-router&apos;</span><br><span class="line"></span><br><span class="line">// 引入 Home 组件</span><br><span class="line">const Home = resolve =&gt; &#123;</span><br><span class="line">    require.ensure([&apos;./views/Home.vue&apos;], () =&gt; &#123;</span><br><span class="line">        resolve(require(&apos;./views/Home.vue&apos;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 引入 About 组件</span><br><span class="line">const About = resolve =&gt; &#123;</span><br><span class="line">    require.ensure([&apos;./views/About.vue&apos;], () =&gt; &#123;</span><br><span class="line">        resolve(require(&apos;./views/About.vue&apos;))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">let base = `$&#123;process.env.BASE_URL&#125;` // 动态获取二级目录</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">    mode: &apos;history&apos;,</span><br><span class="line">    base: base,</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path: &apos;/&apos;,</span><br><span class="line">        name: &apos;home&apos;,</span><br><span class="line">        component: Home</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        path: &apos;/about&apos;,</span><br><span class="line">        name: &apos;about&apos;,</span><br><span class="line">        component: About</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>改为 history 后我们 url 的路径就变成了 <code>http://127.0.0.1:8080/vue/about</code>，而不是原来的 <code>http://127.0.0.1:8080/vue/#/about</code>，但是需要注意页面渲染 404 的问题，具体可查阅：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">HTML5 History 模式</a>。</p><p>而在异步加载的优化上，我们使用了 webpack 提供的 require.ensure() 进行了代码拆分，主要区别在于没有优化前，访问 Home 页面会一起加载 About 组件的资源，因为它们打包进了一个 app.js 中：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/27/164d754590f2d34d?w=809&h=87&f=png&s=20677" alt></p><p>但是优化过后，它们分别被拆分成了 2.js 和 3.js：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/27/164d7569cad0a655?w=813&h=107&f=png&s=28384" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/27/164d7567ab535a4c?w=812&h=108&f=png&s=28104" alt></p><p>如此，只有当用户点击了某页面，才会加载对应页面的 js 文件，实现了按需加载的功能。</p><blockquote><p>webpack 在编译时，会静态地解析代码中的 require.ensure()，同时将模块添加到一个分开的 chunk 当中。这个新的 chunk 会被 webpack 通过 jsonp 来按需加载。</p></blockquote><p>关于 <code>require.ensure()</code> 的知识点可以参考官方文档：<a href="https://webpack.js.org/api/module-methods/#require-ensure" target="_blank" rel="noopener">require.ensure</a>。</p><p>当然，除了使用 require.ensure 来拆分代码，<a href="https://router.vuejs.org/zh/guide/advanced/lazy-loading.html#%E6%8A%8A%E7%BB%84%E4%BB%B6%E6%8C%89%E7%BB%84%E5%88%86%E5%9D%97" target="_blank" rel="noopener">Vue Router</a> 官方文档还推荐使用动态 <code>import</code> 语法来进行代码分块，比如上述 require.ensure 代码可以修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 引入 Home 组件</span><br><span class="line">const Home = () =&gt; import(&apos;./views/Home.vue&apos;);</span><br><span class="line"></span><br><span class="line">// 引入 About 组件</span><br><span class="line">const About = () =&gt; import(&apos;./views/About.vue&apos;);</span><br></pre></td></tr></table></figure><p>其余代码可以保持不变，仍然可以实现同样的功能。如果你想给拆分出的文件命名，可以尝试一下 webpack 提供的 <code>Magic Comments</code>（魔法注释）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Home = () =&gt; import(/* webpackChunkName:&apos;home&apos;*/ &apos;./views/Home.vue&apos;);</span><br></pre></td></tr></table></figure><h3 id="2-Vuex-配置"><a href="#2-Vuex-配置" class="headerlink" title="2. Vuex 配置"></a>2. Vuex 配置</h3><p>除了 vue-router，如果你的项目需要用到 <a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex</a> ，那么你应该对它有一定的了解，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。这里我们先来看一下使用 CLI 生成的配置文件 store.js 中的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该配置文件便是 Vuex 的配置文件，主要有 4 个核心点：state、mutations、actions 及 getter，详细的介绍大家可以参考官方文档：<a href="https://vuex.vuejs.org/zh/guide/state.html" target="_blank" rel="noopener">核心概念</a>，这里我用一句话介绍它们之间的关系就是：<strong>我们可以通过 actions 异步提交 mutations 去 修改 state 的值并通过 getter 获取</strong>。</p><p>需要注意的是不是每一个项目都适合使用 Vuex，如果你的项目是中大型项目，那么使用 Vuex 来管理错综复杂的状态数据是很有帮助的，而为了后期的拓展性和可维护性，这里不建议使用 CLI 生成的一份配置文件来管理所有的状态操作，我们可以把它拆分为以下目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── actions.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── moduleA.js    # A模块</span><br><span class="line">        └── moduleB.js    # B模块</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c0985b8c2ae68?w=885&h=301&f=png&s=45534" alt></p><p>与单个 store.js 文件不同的是，我们按模块进行了划分，每个模块中都可以包含自己 4 个核心功能。比如模块 A 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* moduleA.js */</span><br><span class="line"></span><br><span class="line">const moduleA = &#123;</span><br><span class="line">    state: &#123; </span><br><span class="line">        text: &apos;hello&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        addText (state, txt) &#123;</span><br><span class="line">            // 这里的 `state` 对象是模块的局部状态</span><br><span class="line">            state.text += txt</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    actions: &#123;</span><br><span class="line">        setText (&#123; commit &#125;) &#123;</span><br><span class="line">            commit(&apos;addText&apos;, &apos; world&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    getters: &#123;</span><br><span class="line">        getText (state) &#123;</span><br><span class="line">            return state.text + &apos;!&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default moduleA</span><br></pre></td></tr></table></figure><p>上方我们导出 A 模块，并在 index.js 中引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* index.js */</span><br><span class="line"></span><br><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import moduleA from &apos;./modules/moduleA&apos;</span><br><span class="line">import moduleB from &apos;./modules/moduleB&apos;</span><br><span class="line">import &#123; mutations &#125; from &apos;./mutations&apos;</span><br><span class="line">import actions from &apos;./actions&apos;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        groups: [1]</span><br><span class="line">    &#125;,</span><br><span class="line">    modules: &#123;</span><br><span class="line">        moduleA, // 引入 A 模块</span><br><span class="line">        moduleB, // 引入 B 模块</span><br><span class="line">    &#125;,</span><br><span class="line">    actions, // 根级别的 action</span><br><span class="line">    mutations, // 根级别的 mutations</span><br><span class="line">    </span><br><span class="line">    // 根级别的 getters</span><br><span class="line">    getters: &#123;</span><br><span class="line">        getGroups (state) &#123;</span><br><span class="line">            return state.groups</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样项目中状态的模块划分就更加清晰，对应模块的状态我们只需要修改相应模块文件即可。详细的案例代码可参考文末 github 地址。</p><h3 id="3-接口配置"><a href="#3-接口配置" class="headerlink" title="3. 接口配置"></a>3. 接口配置</h3><p>在项目的开发过程中，我们也少不了与后台服务器进行数据的获取和交互，这一般都是通过接口完成的，那么我们如何进行合理的接口配置呢？我们可以在 src 目录下新建 services 文件夹用于存放接口文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── src</span><br><span class="line">    └── services</span><br><span class="line">        ├── http.js      # 接口封装</span><br><span class="line">        ├── moduleA.js    # A模块接口</span><br><span class="line">        └── moduleB.js    # B模块接口</span><br></pre></td></tr></table></figure><p>为了让接口便于管理，我们同样使用不同的文件来配置不同模块的接口，同时由于接口的调用 ajax 请求代码重复部分较多，我们可以对其进行简单的封装，比如在 http.js 中（fetch为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/* http.js */</span><br><span class="line">import &apos;whatwg-fetch&apos;</span><br><span class="line"></span><br><span class="line">// HTTP 工具类</span><br><span class="line">export default class Http &#123;</span><br><span class="line">    static async request(method, url, data) &#123;</span><br><span class="line">        const param = &#123;</span><br><span class="line">            method: method,</span><br><span class="line">            headers: &#123;</span><br><span class="line">                &apos;Content-Type&apos;: &apos;application/json&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        if (method === &apos;GET&apos;) &#123;</span><br><span class="line">            url += this.formatQuery(data)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            param[&apos;body&apos;] = JSON.stringify(data)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Tips.loading(); // 可调用 loading 组件</span><br><span class="line"></span><br><span class="line">        return fetch(url, param).then(response =&gt; this.isSuccess(response))</span><br><span class="line">                .then(response =&gt; &#123;</span><br><span class="line">                    return response.json()</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断请求是否成功</span><br><span class="line">    static isSuccess(res) &#123;</span><br><span class="line">        if (res.status &gt;= 200 &amp;&amp; res.status &lt; 300) &#123;</span><br><span class="line">            return res</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.requestException(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 处理异常</span><br><span class="line">    static requestException(res) &#123;</span><br><span class="line">        const error = new Error(res.statusText)</span><br><span class="line"></span><br><span class="line">        error.response = res</span><br><span class="line"></span><br><span class="line">        throw error</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // url处理</span><br><span class="line">    static formatQuery(query) &#123;</span><br><span class="line">        let params = [];</span><br><span class="line"></span><br><span class="line">        if (query) &#123;</span><br><span class="line">            for (let item in query) &#123;</span><br><span class="line">                let vals = query[item];</span><br><span class="line">                if (vals !== undefined) &#123;</span><br><span class="line">                    params.push(item + &apos;=&apos; + query[item])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return params.length ? &apos;?&apos; + params.join(&apos;&amp;&apos;) : &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理 get 请求</span><br><span class="line">    static get(url, data) &#123;</span><br><span class="line">        return this.request(&apos;GET&apos;, url, data)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理 put 请求</span><br><span class="line">    static put(url, data) &#123;</span><br><span class="line">        return this.request(&apos;PUT&apos;, url, data)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理 post 请求</span><br><span class="line">    static post(url, data) &#123;</span><br><span class="line">        return this.request(&apos;POST&apos;, url, data)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理 patch 请求</span><br><span class="line">    static patch(url, data) &#123;</span><br><span class="line">        return this.request(&apos;PATCH&apos;, url, data)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 处理 delete 请求</span><br><span class="line">    static delete(url, data) &#123;</span><br><span class="line">        return this.request(&apos;DELETE&apos;, url, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装完毕后我们在 moduleA.js 中配置一个 github 的开放接口：<code>https://api.github.com/repos/octokit/octokit.rb</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* moduleA.js */</span><br><span class="line">import Http from &apos;./http&apos;</span><br><span class="line"></span><br><span class="line">// 获取测试数据</span><br><span class="line">export const getTestData = () =&gt; &#123;</span><br><span class="line">    return Http.get(&apos;https://api.github.com/repos/octokit/octokit.rb&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在项目页面中进行调用，会成功获取 github 返回的数据，但是一般我们在项目中配置接口的时候会直接省略项目 url 部分，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* moduleA.js */</span><br><span class="line">import Http from &apos;./http&apos;</span><br><span class="line"></span><br><span class="line">// 获取测试数据</span><br><span class="line">export const getTestData = () =&gt; &#123;</span><br><span class="line">    return Http.get(&apos;/repos/octokit/octokit.rb&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候我们再次调用接口的时候会发现其调用地址为本地地址：<code>http://127.0.0.1:8080/repos/octokit/octokit.rb</code>，那么为了让其指向 <code>https://api.github.com</code>，我们需要在 vue.config.js 中进行 devServer 的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    devServer: &#123;</span><br><span class="line">    </span><br><span class="line">        // string | Object 代理设置</span><br><span class="line">        proxy: &#123;</span><br><span class="line">        </span><br><span class="line">            // 接口是 &apos;/repos&apos; 开头的才用代理</span><br><span class="line">            &apos;/repos&apos;: &#123;</span><br><span class="line">                target: &apos;https://api.github.com&apos;, // 目标地址</span><br><span class="line">                changeOrigin: true, // 是否改变源地址</span><br><span class="line">                // pathRewrite: &#123;&apos;^/api&apos;: &apos;&apos;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 devServer 中 我们配置 proxy 进行接口的代理，将我们本地地址转换为真实的服务器地址，此时我们同样能顺利的获取到数据，不同点在于接口状态变成了 304（重定向）：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/29/164e55db6ccb45cb" alt></p><h3 id="4-公共设施配置"><a href="#4-公共设施配置" class="headerlink" title="4. 公共设施配置"></a>4. 公共设施配置</h3><p>最后我们项目开发中肯定需要对一些公共的方法进行封装使用，这里我把它称之为公共设施，那么我们可以在 src 目录下建一个 common 文件夹来存放其配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── src</span><br><span class="line">    └── common</span><br><span class="line">        ├── index.js      # 公共配置入口</span><br><span class="line">        ├── validate.js   # 表单验证配置</span><br><span class="line">        └── other.js      # 其他配置</span><br></pre></td></tr></table></figure><p>在入口文件中我们可以向外暴露其他功能配置的模块，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* index.js */</span><br><span class="line">import Validate from &apos;./validate&apos;</span><br><span class="line">import Other from &apos;./other&apos;</span><br><span class="line"></span><br><span class="line">export &#123;</span><br><span class="line">    Validate,</span><br><span class="line">    Other,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们在页面中只需要引入一个 index.js 即可。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了 Vue 单页应用的一些基本配置，从项目构建层面阐述了各文件的主要配置方式和注意点，由于本文并不是一篇文档类的配置说明，并不会详细介绍各配置文件的 API 功能，大家可以访问文中列出的官方文档进行查阅。</p><p>本案例代码地址：<a href="https://github.com/luozhihao/vue-project-code/tree/master/single-page-project" target="_blank" rel="noopener">single-page-project</a></p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>devServer 中 proxy 的 key 值代表什么？如果再添加一个 <code>/reposed</code> 的配置会产生什么隐患？</p></li><li><p>如何配置 webpack 使得 <code>require.ensure()</code> 拆分出的 js 文件具有自定义文件名？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建实战篇 2</title>
      <link href="/2018/09/07/%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98%E7%AF%87%202%EF%BC%9A%E4%BD%BF%E7%94%A8%20pages%20%E6%9E%84%E5%BB%BA%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8/"/>
      <url>/2018/09/07/%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98%E7%AF%87%202%EF%BC%9A%E4%BD%BF%E7%94%A8%20pages%20%E6%9E%84%E5%BB%BA%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="构建实战篇-2：使用-pages-构建多页应用"><a href="#构建实战篇-2：使用-pages-构建多页应用" class="headerlink" title="构建实战篇 2：使用 pages 构建多页应用"></a>构建实战篇 2：使用 pages 构建多页应用</h1><p>经过对单页应用配置的了解，相信大家应该对如何构建一个 Vue 单页应用项目已经有所收获和体会，在大部分实际场景中，我们都可以构建单页应用来进行项目的开发和迭代，然而对于项目复杂度过高或者页面模块之间差异化较大的项目，我们可以选择构建多页应用来实现。那么什么是多页应用，如何构建一个多页应用便是本文所要阐述的内容。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>首先我们可以把多页应用理解为由多个单页构成的应用，而何谓多个单页呢？其实你可以把一个单页看成是一个 html 文件，那么多个单页便是多个 html 文件，多页应用便是由多个 html 组成的应用，如下图所示：</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/7/30/164eb40e7ae7fb85?w=730&h=253&f=png&s=17448" alt></p><p>既然多页应用拥有多个 html，那么同样其应该拥有多个独立的入口文件、组件、路由、vuex 等。没错，说简单一点就是<strong>多页应用的每个单页都可以拥有单页应用 src 目录下的文件及功能</strong>，我们来看一下一个基础多页应用的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── node_modules               # 项目依赖包目录</span><br><span class="line">├── build                      # 项目 webpack 功能目录</span><br><span class="line">├── config                     # 项目配置项文件夹</span><br><span class="line">├── src                        # 前端资源目录</span><br><span class="line">│   ├── images                 # 图片目录</span><br><span class="line">│   ├── components             # 公共组件目录</span><br><span class="line">│   ├── pages                  # 页面目录</span><br><span class="line">│   │   ├── page1              # page1 目录</span><br><span class="line">│   │   │   ├── components     # page1 组件目录</span><br><span class="line">│   │   │   ├── router         # page1 路由目录</span><br><span class="line">│   │   │   ├── views          # page1 页面目录</span><br><span class="line">│   │   │   ├── page1.html     # page1 html 模板</span><br><span class="line">│   │   │   ├── page1.vue      # page1 vue 配置文件</span><br><span class="line">│   │   │   └── page1.js       # page1 入口文件</span><br><span class="line">│   │   ├── page2              # page2 目录</span><br><span class="line">│   │   └── index              # index 目录</span><br><span class="line">│   ├── common                 # 公共方法目录</span><br><span class="line">│   └── store                  # 状态管理 store 目录</span><br><span class="line">├── .gitignore                 # git 忽略文件</span><br><span class="line">├── .env                       # 全局环境配置文件</span><br><span class="line">├── .env.dev                   # 开发环境配置文件</span><br><span class="line">├── .postcssrc.js              # postcss 配置文件</span><br><span class="line">├── babel.config.js            # babel 配置文件</span><br><span class="line">├── package.json               # 包管理文件</span><br><span class="line">├── vue.config.js              # CLI 配置文件</span><br><span class="line">└── yarn.lock                  # yarn 依赖信息文件</span><br></pre></td></tr></table></figure><p>根据上方目录结构我们可以看出其实 pages 下的一个目录就是一个单页包含的功能，这里我们包含了 3 个目录就构成了多页应用。</p><p>除了目录结构的不同外，其实区别单页应用，多页应用在很多配置上都需要进行修改，比如单入口变为多入口、单模板变为多模板等，那么下面我们就来了解一下多页应用的具体实现。</p><h2 id="多入口"><a href="#多入口" class="headerlink" title="多入口"></a>多入口</h2><p>在单页应用中，我们的入口文件只有一个，CLI 默认配置的是 main.js，但是到了多页应用，我们的入口文件便包含了 page1.js、page2.js、index.js等，数量取决于 pages 文件夹下目录的个数，这时候为了项目的可拓展性，我们需要自动计算入口文件的数量并解析路径配置到 webpack 中的 entry 属性上，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    entry: &#123;</span><br><span class="line">        page1: &apos;/xxx/pages/page1/page1.js&apos;,</span><br><span class="line">        page2: &apos;/xxx/pages/page2/page2.js&apos;,</span><br><span class="line">        index: &apos;/xxx/pages/index/index.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们如何读取并解析这样的路径呢，这里就需要使用工具和函数来解决了。我们可以在根目录新建 build 文件夹存放 utils.js 这样共用的 webpack 功能性文件，并加入多入口读取解析方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* utils.js */</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">// glob 是 webpack 安装时依赖的一个第三方模块，该模块允许你使用 * 等符号,</span><br><span class="line">// 例如 lib/*.js 就是获取 lib 文件夹下的所有 js 后缀名的文件</span><br><span class="line">const glob = require(&apos;glob&apos;);</span><br><span class="line"></span><br><span class="line">// 取得相应的页面路径，因为之前的配置，所以是 src 文件夹下的 pages 文件夹</span><br><span class="line">const PAGE_PATH = path.resolve(__dirname, &apos;../src/pages&apos;);</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">* 多入口配置</span><br><span class="line">* 通过 glob 模块读取 pages 文件夹下的所有对应文件夹下的 js * 后缀文件，如果该文件存在</span><br><span class="line">* 那么就作为入口处理</span><br><span class="line">*/</span><br><span class="line">exports.getEntries = () =&gt; &#123;</span><br><span class="line">    let entryFiles = glob.sync(PAGE_PATH + &apos;/*/*.js&apos;) // 同步读取所有入口文件</span><br><span class="line">    let map = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    // 遍历所有入口文件</span><br><span class="line">    entryFiles.forEach(filePath =&gt; &#123;</span><br><span class="line">        // 获取文件名</span><br><span class="line">        let filename = filePath.substring(filePath.lastIndexOf(&apos;\/&apos;) + 1, filePath.lastIndexOf(&apos;.&apos;))</span><br><span class="line">        </span><br><span class="line">        // 以键值对的形式存储</span><br><span class="line">        map[filename] = filePath </span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c0c419bc53201?w=665&h=236&f=png&s=31154" alt></p><p>上方我们使用了 <a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">glob</a> 这一第三方模块读取所有 pages 文件夹下的入口文件，其需要进行安装：<code>yarn add glob --dev</code></p><p>读取并存储完毕后，我们得到了一个入口文件的对象集合，这个对象我们便可以将其设置到 webpack 的 entry 属性上，这里我们需要修改 vue.config.js 的配置来间接修改 webpack 的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line"></span><br><span class="line">const utils = require(&apos;./build/utils&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        config.entry = utils.getEntries()</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们多入口的设置便完成了，当然这并不是 CLI 所希望的操作，后面我们会进行改进。</p><h2 id="多模板"><a href="#多模板" class="headerlink" title="多模板"></a>多模板</h2><p>相对于多入口来说，多模板的配置也是大同小异，这里所说的模板便是每个 page 下的 html 模板文件，而模板文件的作用主要用于 webpack 中 <code>html-webpack-plugin</code> 插件的配置，其会根据模板文件生产一个编译后的 html 文件并自动加入携带 hash 的脚本和样式，基本配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* webpack 配置文件 */</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) // 安装并引用插件</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    plugins: [</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: &apos;My Page&apos;, // 生成 html 中的 title</span><br><span class="line">            filename: &apos;demo.html&apos;, // 生成 html 的文件名</span><br><span class="line">            template: &apos;xxx/xxx/demo.html&apos;, // 模板路径</span><br><span class="line">            chunks: [&apos;manifest&apos;, &apos;vendor&apos;, &apos;demo&apos;], // 所要包含的模块</span><br><span class="line">            inject: true, // 是否注入资源</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是单模板的配置，那么如果是多模板只要继续往 plugins 数组中添加 HtmlWebpackPlugin 即可，但是为了和多入口一样能够灵活的获取 pages 目录下所有模板文件并进行配置，我们可以在 utils.js 中添加多模板的读取解析方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* utils.js */</span><br><span class="line"></span><br><span class="line">// 多页面输出配置</span><br><span class="line">// 与上面的多页面入口配置相同，读取 page 文件夹下的对应的 html 后缀文件，然后放入数组中</span><br><span class="line">exports.htmlPlugin = configs =&gt; &#123;</span><br><span class="line">    let entryHtml = glob.sync(PAGE_PATH + &apos;/*/*.html&apos;)</span><br><span class="line">    let arr = []</span><br><span class="line">    </span><br><span class="line">    entryHtml.forEach(filePath =&gt; &#123;</span><br><span class="line">        let filename = filePath.substring(filePath.lastIndexOf(&apos;\/&apos;) + 1, filePath.lastIndexOf(&apos;.&apos;))</span><br><span class="line">        let conf = &#123;</span><br><span class="line">            template: filePath, // 模板路径</span><br><span class="line">            filename: filename + &apos;.html&apos;, // 生成 html 的文件名</span><br><span class="line">            chunks: [&apos;manifest&apos;, &apos;vendor&apos;,  filename],</span><br><span class="line">            inject: true,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 如果有自定义配置可以进行 merge</span><br><span class="line">        if (configs) &#123;</span><br><span class="line">            conf = merge(conf, configs)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 针对生产环境配置</span><br><span class="line">        if (process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">            conf = merge(conf, &#123;</span><br><span class="line">                minify: &#123;</span><br><span class="line">                    removeComments: true, // 删除 html 中的注释代码</span><br><span class="line">                    collapseWhitespace: true, // 删除 html 中的空白符</span><br><span class="line">                    // removeAttributeQuotes: true // 删除 html 元素中属性的引号</span><br><span class="line">                &#125;,</span><br><span class="line">                chunksSortMode: &apos;manual&apos; // 按 manual 的顺序引入</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr.push(new HtmlWebpackPlugin(conf))</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/10/30/166c0c888939ac36?w=668&h=327&f=png&s=41082" alt></p><p>以上我们仍然是使用 glob 读取所有模板文件，然后将其遍历并设置每个模板的 config，同时针对一些自定义配置和生产环境的配置进行了 merge 处理，其中自定义配置的功能我会在下节进行介绍，这里介绍一下生产环境下 <code>minify</code> 配置的作用：<strong>将 html-minifier 的选项作为对象来缩小输出</strong>。</p><p><a href="https://github.com/kangax/html-minifier" target="_blank" rel="noopener">html-minifier</a> 是一款用于缩小 html 文件大小的工具，其有很多配置项功能，包括上述所列举的常用的删除注释、空白、引号等。</p><p>当我们编写完了多模板的方法后，我们同样可以在 vue.config.js 中进行配置，与多入口不同的是我们在 configureWebpack 中不能直接替换 plugins 的值，因为它还包含了其他插件，这时候大家还记得第 3 节中讲到的使用 return 返回一个对象来进行 merge 操作吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line"></span><br><span class="line">const utils = require(&apos;./build/utils&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        config.entry = utils.getEntries() // 直接覆盖 entry 配置</span><br><span class="line">        </span><br><span class="line">        // 使用 return 一个对象会通过 webpack-merge 进行合并，plugins 不会置空</span><br><span class="line">        return &#123;</span><br><span class="line">            plugins: [...utils.htmlPlugin()]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此我们多页应用的多入口和多模板的配置就完成了，这时候我们运行命令 <code>yarn build</code> 后你会发现 dist 目录下生成了 3 个 html 文件，分别是 index.html、page1.html 和 page2.html。</p><h2 id="使用-pages-配置"><a href="#使用-pages-配置" class="headerlink" title="使用 pages 配置"></a>使用 pages 配置</h2><p>其实，在 vue.config.js 中，我们还有一个配置没有使用，便是 pages。pages 对象允许我们为应用配置多个入口及模板，这就为我们的多页应用提供了开放的配置入口。官方示例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    pages: &#123;</span><br><span class="line">        index: &#123;</span><br><span class="line">            // page 的入口</span><br><span class="line">            entry: &apos;src/index/main.js&apos;,</span><br><span class="line">            // 模板来源</span><br><span class="line">            template: &apos;public/index.html&apos;,</span><br><span class="line">            // 在 dist/index.html 的输出</span><br><span class="line">            filename: &apos;index.html&apos;,</span><br><span class="line">            // 当使用 title 选项时，</span><br><span class="line">            // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line">            title: &apos;Index Page&apos;,</span><br><span class="line">            // 在这个页面中包含的块，默认情况下会包含</span><br><span class="line">            // 提取出来的通用 chunk 和 vendor chunk。</span><br><span class="line">            chunks: [&apos;chunk-vendors&apos;, &apos;chunk-common&apos;, &apos;index&apos;]</span><br><span class="line">        &#125;,</span><br><span class="line">        // 当使用只有入口的字符串格式时，</span><br><span class="line">        // 模板会被推导为 `public/subpage.html`</span><br><span class="line">        // 并且如果找不到的话，就回退到 `public/index.html`。</span><br><span class="line">        // 输出文件名会被推导为 `subpage.html`。</span><br><span class="line">        subpage: &apos;src/subpage/main.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不难发现，pages 对象中的 key 就是入口的别名，而其 value 对象其实是入口 entry 和模板属性的合并，这样我们上述介绍的获取多入口和多模板的方法就可以合并成一个函数来进行多页的处理，合并后的 setPages 方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// pages 多入口配置</span><br><span class="line">exports.setPages = configs =&gt; &#123;</span><br><span class="line">    let entryFiles = glob.sync(PAGE_PATH + &apos;/*/*.js&apos;)</span><br><span class="line">    let map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    entryFiles.forEach(filePath =&gt; &#123;</span><br><span class="line">        let filename = filePath.substring(filePath.lastIndexOf(&apos;\/&apos;) + 1, filePath.lastIndexOf(&apos;.&apos;))</span><br><span class="line">        let tmp = filePath.substring(0, filePath.lastIndexOf(&apos;\/&apos;))</span><br><span class="line"></span><br><span class="line">        let conf = &#123;</span><br><span class="line">            // page 的入口</span><br><span class="line">            entry: filePath, </span><br><span class="line">            // 模板来源</span><br><span class="line">            template: tmp + &apos;.html&apos;, </span><br><span class="line">            // 在 dist/index.html 的输出</span><br><span class="line">            filename: filename + &apos;.html&apos;, </span><br><span class="line">            // 页面模板需要加对应的js脚本，如果不加这行则每个页面都会引入所有的js脚本</span><br><span class="line">            chunks: [&apos;manifest&apos;, &apos;vendor&apos;, filename], </span><br><span class="line">            inject: true,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        if (configs) &#123;</span><br><span class="line">            conf = merge(conf, configs)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (process.env.NODE_ENV === &apos;production&apos;) &#123;</span><br><span class="line">            conf = merge(conf, &#123;</span><br><span class="line">                minify: &#123;</span><br><span class="line">                    removeComments: true, // 删除 html 中的注释代码</span><br><span class="line">                    collapseWhitespace: true, // 删除 html 中的空白符</span><br><span class="line">                    // removeAttributeQuotes: true // 删除 html 元素中属性的引号</span><br><span class="line">                &#125;,</span><br><span class="line">                chunksSortMode: &apos;manual&apos;// 按 manual 的顺序引入</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[filename] = conf</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们 return 出的 map 对象就是 pages 所需要的配置项结构，我们只需在 vue.config.js 中引用即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line"></span><br><span class="line">const utils = require(&apos;./build/utils&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    pages: utils.setPages(),</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们多页应用基于 pages 配置的改进就大功告成了，当你运行打包命令来查看输出结果的时候，你会发现和之前的方式相比并没有什么变化，这就说明这两种方式都适用于多页的构建，但是这里还是推荐大家使用更便捷的 pages 配置。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要讲解了多页应用开发中多入口和多模板的实现方式，通过针对 webpack 配置的修改我们基本了解了多页模式与单页模式的差异性，下篇文章我们将以本文内容为基础进一步完善我们的多页应用配置，使其能够正常适应实际的开发与生产。</p><p>本案例代码地址：<a href="https://github.com/luozhihao/vue-project-code/tree/master/multi-page-project" target="_blank" rel="noopener">multi-page-project</a></p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>多页应用相比单页应用有哪些优点和缺点？</p></li><li><p><code>chunksSortMode</code> 除了文中介绍的 <code>manual</code> 手动排序外，还有哪些排序方式？</p></li><li><p>glob 中 <code>*</code> 和 <code>**</code> 的区别是什么？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建实战篇 3</title>
      <link href="/2018/09/07/%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98%E7%AF%87%204%EF%BC%9A%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/2018/09/07/%E6%9E%84%E5%BB%BA%E5%AE%9E%E6%88%98%E7%AF%87%204%EF%BC%9A%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="构建实战篇-4：项目整合与优化"><a href="#构建实战篇-4：项目整合与优化" class="headerlink" title="构建实战篇 4：项目整合与优化"></a>构建实战篇 4：项目整合与优化</h1><p>前几小节，我们讲述了 Vue 项目构建的整体流程，从无到有的实现了单页和多页应用的功能配置，但在实现的过程中不乏一些可以整合的功能点及可行性的优化方案，就像大楼造完需要进行最后的项目验收改进一样，有待我们进一步的去完善。</p><h2 id="使用-alias-简化路径"><a href="#使用-alias-简化路径" class="headerlink" title="使用 alias 简化路径"></a>使用 alias 简化路径</h2><p>使用 webpack 构建过 Vue 项目的同学应该知道 <code>alias</code> 的作用，我们可以使用它将复杂的文件路径定义成一个变量来访问。在不使用 alias 的项目中，我们引入文件的时候通常会去计算被引入文件对于引入它的文件的相对路径，比如像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import HelloWorld from &apos;../../../../HelloWorld.vue&apos;</span><br></pre></td></tr></table></figure><p>一旦相对层次结构较深，我们就很难去定位所引入文件的具体位置，其实这并不是我们应该操心的地方，完全可以交给 webpack 来进行处理。在原生的 webpack 配置中我们可以定义 alias 来解决这一问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">const resolve = dir =&gt; &#123;</span><br><span class="line">    return path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &apos;@&apos;: resolve(&apos;src&apos;), // 定义 src 目录变量</span><br><span class="line">            _lib: resolve(&apos;src/common&apos;), // 定义 common 目录变量,</span><br><span class="line">            _com: resolve(&apos;src/components&apos;), // 定义 components 目录变量,</span><br><span class="line">            _img: resolve(&apos;src/images&apos;), // 定义 images 目录变量,</span><br><span class="line">            _ser: resolve(&apos;src/services&apos;), // 定义 services 目录变量,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方我们在 webpack resolve（解析）对象下配置 alias 的值，将常用的一些路径赋值给了我们自定义的变量，这样我们便可以将第一个例子简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import HelloWorld from &apos;_com/HelloWorld.vue&apos;</span><br></pre></td></tr></table></figure><p>而在 CLI 3.x 中我们无法直接操作 webpack 的配置文件，我们需要通过 chainWebpack 来进行间接修改，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    chainWebpack: config =&gt; &#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">            .set(&apos;@&apos;, resolve(&apos;src&apos;))</span><br><span class="line">            .set(&apos;_lib&apos;, resolve(&apos;src/common&apos;))</span><br><span class="line">            .set(&apos;_com&apos;, resolve(&apos;src/components&apos;))</span><br><span class="line">            .set(&apos;_img&apos;, resolve(&apos;src/images&apos;))</span><br><span class="line">            .set(&apos;_ser&apos;, resolve(&apos;src/services&apos;))</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们修改 webpack alias 来简化路径的优化就实现了。但是需要注意的是对于在样式及 html 模板中引用路径的简写时，前面需要加上 <code>～</code> 符，否则路径解析会失败，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.img &#123;</span><br><span class="line">    background: (~_img/home.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整合功能模块"><a href="#整合功能模块" class="headerlink" title="整合功能模块"></a>整合功能模块</h2><p>在多页应用的构建中，由于存在多个入口文件，因此会出现重复书写相同入口配置的情况，这样对于后期的修改和维护都不是特别友好，需要修改所有入口文件的相同配置，比如在 index 单页的入口中我们引用了 VConsole 及 performance 的配置，同时在 Vue 实例上还添加了 $openRouter 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./index.vue&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line">import store from &apos;@/store/&apos;</span><br><span class="line">import &#123; Navigator &#125; from &apos;../../common&apos;</span><br><span class="line"></span><br><span class="line">// 如果是非线上环境，不加载 VConsole</span><br><span class="line">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">    var VConsole = require(&apos;vconsole/dist/vconsole.min.js&apos;);</span><br><span class="line">    var vConsole = new VConsole();</span><br><span class="line"></span><br><span class="line">    Vue.config.performance = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.$openRouter = Vue.prototype.$openRouter = Navigator.openRouter;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><p>而在 page1 和 page2 的入口文件中也同样进行了上述配置，那我们该如何整合这些重复代码，使其能够实现一次修改多处生效的功能呢？最简单的方法便是封装成一个共用方法来进行调用，这里我们可以在 common 文件夹下新建 entryConfig 文件夹用于放置入口文件中公共配置的封装，封装代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Navigator &#125; from &apos;../index&apos;</span><br><span class="line"></span><br><span class="line">export default (Vue) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    // 如果是非线上环境，不加载 VConsole</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        var VConsole = require(&apos;vconsole/dist/vconsole.min.js&apos;);</span><br><span class="line">        var vConsole = new VConsole();</span><br><span class="line"></span><br><span class="line">        Vue.config.performance = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vue.$openRouter = Vue.prototype.$openRouter = Navigator.openRouter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们向外暴露了一个函数，在调用它的入口文件中传入 Vue 实例作为参数即可实现内部功能的共用，我们可以将原本的入口文件简化为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import App from &apos;./index.vue&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line">import store from &apos;@/store/&apos;</span><br><span class="line">import entryConfig from &apos;_lib/entryConfig/&apos;</span><br><span class="line"></span><br><span class="line">// 调用公共方法加载配置</span><br><span class="line">entryConfig(Vue)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure><p>这样我们便完成了入口文件配置的整合，当然你还可以给该函数传入 router 实例及自定义参数用于其他共用配置的封装。</p><h2 id="开启-Gzip-压缩"><a href="#开启-Gzip-压缩" class="headerlink" title="开启 Gzip 压缩"></a>开启 Gzip 压缩</h2><p>在《webpack 在 CLI 3 中的应用》章节，我们介绍了 CLI 为我们内置的 webpack plugins，使用这些内置插件基本已经能够满足我们大多数项目的构建和优化，当然你仍然可以为项目添加自己想要的插件来实现一些差异化的功能，比如使用 <a href="https://www.npmjs.com/package/compression-webpack-plugin" target="_blank" rel="noopener">compression-webpack-plugin</a> 来开启 Gzip 压缩。在 vue.config.js 配置文件中，我们通过 configureWebpack 中返回一个对象来实现 plugins 的合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* vue.config.js */</span><br><span class="line">const isPro = process.env.NODE_ENV === &apos;production&apos;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        if (isPro) &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    new CompressionWebpackPlugin(&#123;</span><br><span class="line">                         // 目标文件名称。[path] 被替换为原始文件的路径和 [query] 查询</span><br><span class="line">                        asset: &apos;[path].gz[query]&apos;,</span><br><span class="line">                        // 使用 gzip 压缩</span><br><span class="line">                        algorithm: &apos;gzip&apos;, </span><br><span class="line">                        // 处理与此正则相匹配的所有文件</span><br><span class="line">                        test: new RegExp(</span><br><span class="line">                            &apos;\\.(js|css)$&apos;</span><br><span class="line">                        ),</span><br><span class="line">                        // 只处理大于此大小的文件</span><br><span class="line">                        threshold: 10240,</span><br><span class="line">                        // 最小压缩比达到 0.8 时才会被压缩</span><br><span class="line">                        minRatio: 0.8，</span><br><span class="line">                    &#125;)</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方我们通过在生产环境中增加 Gzip 压缩配置实现了打包后输出增加对应的 .gz 为后缀的文件，而由于我们配置项中配置的是只压缩大小超过 10240B（10kB）的 JS 及 CSS，因此不满足条件的文件不会进行 Gzip 压缩。</p><p>Gzip 压缩能在普通压缩的基础上再进行 50% 以上 的压缩，我们可以直接来看下控制台的输出对比图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/19/1654de7a38472ab8?w=621&h=355&f=png&s=54900" alt></p><p>很明显，Gzip 压缩后的文件体积得到了很大程度的减小，这对于浏览器资源加载速度的提升起到了非常有效的帮助。但是需要注意的是访问 Gzip 压缩的文件需要服务端进行相应配置，以下是 Nginx Gzip 压缩的流程：</p><blockquote><p>Nginx 开启 Gzip 压缩配置后，其会根据配置情况对指定的类型文件进行压缩，主要针对 JS 与 CSS 。如果文件路径中存在与原文件同名（加了个 .gz），Nginx 会获取 gz 文件，如果找不到，会主动进行 Gzip 压缩。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，一路走来，我们成功完成了本小册 Vue 项目构建部分的教程，从 CLI 3.x 的使用到项目内外部环境的配置，再到最后多页应用的拓展，我们循序渐进、由浅入深的讲解了 Vue 项目构建的主要知识点及详细流程，希望大家能够在此基础上举一反三，结合实际代码，将理论知识转化为实际运用，配合自己的理解，一步步实现自己的项目构建，并为构建出的项目添砖加瓦，实现质的飞跃。</p><h2 id="思考-amp-作业"><a href="#思考-amp-作业" class="headerlink" title="思考 &amp; 作业"></a>思考 &amp; 作业</h2><ul><li><p>除了本文中介绍的项目优化方法，还有哪些常见的优化手段？如何通过 Vue CLI 3 配置实现？</p></li><li><p>总结并对比 Vue CLI 2.x，Vue CLI 3.x 在项目构建方面有哪些优势和不足？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件的通信 1</title>
      <link href="/2018/09/07/%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%201%EF%BC%9Aprovide%20%20%20inject/"/>
      <url>/2018/09/07/%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%201%EF%BC%9Aprovide%20%20%20inject/</url>
      
        <content type="html"><![CDATA[<h1 id="组件的通信-1：provide-inject"><a href="#组件的通信-1：provide-inject" class="headerlink" title="组件的通信 1：provide / inject"></a>组件的通信 1：provide / inject</h1><p>上一节中我们说到，<code>ref</code> 和 <code>$parent / $children</code> 在<strong>跨级</strong>通信时是有弊端的。当组件 A 和组件 B 中间隔了数代（甚至不确定具体级别）时，以往会借助 Vuex 或 Bus 这样的解决方案，不得不引入三方库来支持。本小节则介绍一种无依赖的组件通信方法：Vue.js 内置的 provide / inject 接口。</p><h2 id="什么是-provide-inject"><a href="#什么是-provide-inject" class="headerlink" title="什么是 provide / inject"></a>什么是 provide / inject</h2><p><code>provide / inject</code> 是 Vue.js 2.2.0 版本后新增的 API，在文档中这样介绍 ：</p><blockquote><p><a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#provide-inject</a></p><p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。</p></blockquote><p>并且文档中有如下提示：</p><blockquote><p>provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。</p></blockquote><p>看不懂上面的介绍没有关系，不过上面的这句提示应该明白，就是说 Vue.js 不建议在业务中使用这对 API，而是在插件 / 组件库（比如 iView，事实上 iView 的很多组件都在用）。<strong>不过建议归建议，如果你用好了，这个 API 会非常有用。</strong></p><p>我们先来看一下这个 API 怎么用，假设有两个组件： <strong>A.vue</strong> 和 <strong>B.vue</strong>，B 是 A 的子组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// A.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    name: &apos;Aresn&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// B.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&apos;name&apos;],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    console.log(this.name);  // Aresn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 A.vue 里，我们设置了一个 <strong>provide: name</strong>，值为 Aresn，它的作用就是将 <strong>name</strong> 这个变量提供给它的所有子组件。而在 B.vue 中，通过 <code>inject</code> 注入了从 A 组件中提供的 <strong>name</strong> 变量，那么在组件 B 中，就可以直接通过 <strong><a href="http://this.name" target="_blank" rel="noopener">this.name</a></strong> 访问这个变量了，它的值也是 Aresn。这就是 provide / inject API 最核心的用法。</p><p>需要注意的是：</p><blockquote><p>provide 和 inject 绑定并<strong>不是可响应</strong>的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</p></blockquote><p>所以，上面 A.vue 的 name 如果改变了，B.vue 的 <a href="http://this.name" target="_blank" rel="noopener">this.name</a> 是不会改变的，仍然是 Aresn。</p><h2 id="替代-Vuex"><a href="#替代-Vuex" class="headerlink" title="替代 Vuex"></a>替代 Vuex</h2><p>我们知道，在做 Vue 大型项目时，可以使用 Vuex 做状态管理，它是一个专为 Vue.js 开发的<strong>状态管理模式</strong>，用于集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>那了解了 provide / inject 的用法，下面来看怎样替代 Vuex。当然，我们的目的并不是为了替代 Vuex，它还是有相当大的用处，这里只是介绍另一种可行性。</p><p>使用 Vuex，最主要的目的是跨组件通信、全局数据维护、多人协同开发。需求比如有：用户的登录信息维护、通知信息维护等全局的状态和数据。</p><p>一般在 webpack 中使用 Vue.js，都会有一个入口文件 <strong>main.js</strong>，里面通常导入了 Vue、VueRouter、iView 等库，通常也会导入一个入口组件 <code>app.vue</code> 作为根组件。一个简单的 app.vue 可能只有以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用 provide / inject 替代 Vuex，就是在这个 app.vue 文件上做文章。</p><p>我们把 app.vue 理解为一个最外层的根组件，用来存储所有需要的全局数据和状态，甚至是计算属性（computed）、方法（methods）等。因为你的项目中所有的组件（包含路由），它的父组件（或根组件）都是 app.vue，所以我们<strong>把整个 app.vue 实例通过 <code>provide</code> 对外提供</strong>。</p><p><em>app.vue：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    provide () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        app: this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面，我们把整个 app.vue 的实例 <code>this</code> 对外提供，命名为 <strong>app</strong>（这个名字可以自定义，推荐使用 app，使用这个名字后，子组件不能再使用它作为局部属性）。接下来，任何组件（或路由）只要通过 <code>inject</code> 注入 app.vue 的 app 的话，都可以直接通过 <strong><a href="http://this.app.xxx" target="_blank" rel="noopener">this.app.xxx</a></strong> 来访问 app.vue 的 <code>data</code>、<code>computed</code>、<code>methods</code> 等内容。</p><p>app.vue 是整个项目第一个被渲染的组件，而且只会渲染一次（即使切换路由，app.vue 也不会被再次渲染），利用这个特性，很适合做一次性全局的状态数据管理，例如，我们将用户的登录信息保存起来：</p><p><em>app.vue，部分代码省略：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    provide () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        app: this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        userInfo: null</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getUserInfo () &#123;</span><br><span class="line">        // 这里通过 ajax 获取用户信息后，赋值给 this.userInfo，以下为伪代码</span><br><span class="line">        $.ajax(&apos;/user/info&apos;, (data) =&gt; &#123;</span><br><span class="line">          this.userInfo = data;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      this.getUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样，任何页面或组件，只要通过 <code>inject</code> 注入 <code>app</code> 后，就可以直接访问 <code>userInfo</code> 的数据了，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; app.userInfo &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    inject: [&apos;app&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>是不是很简单呢。除了直接使用数据，还可以调用方法。比如在某个页面里，修改了个人资料，这时一开始在 <code>app.vue</code> 里获取的 <code>userInfo</code> 已经不是最新的了，需要重新获取。可以这样使用：</p><p><em>某个页面：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; app.userInfo &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    inject: [&apos;app&apos;],</span><br><span class="line">    methods: &#123;</span><br><span class="line">      changeUserInfo () &#123;</span><br><span class="line">        // 这里修改完用户数据后，通知 app.vue 更新，以下为伪代码</span><br><span class="line">        $.ajax(&apos;/user/update&apos;, () =&gt; &#123;</span><br><span class="line">          // 直接通过 this.app 就可以调用 app.vue 里的方法</span><br><span class="line">          this.app.getUserInfo();</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>同样非常简单。只要理解了 <code>this.app</code> 是直接获取整个 <code>app.vue</code> 的实例后，使用起来就得心应手了。想一想，配置复杂的 Vuex 的全部功能，现在是不是都可以通过 <code>provide / inject</code> 来实现了呢？</p><h2 id="进阶技巧"><a href="#进阶技巧" class="headerlink" title="进阶技巧"></a>进阶技巧</h2><p>如果你的项目足够复杂，或需要多人协同开发时，在 <code>app.vue</code> 里会写非常多的代码，多到结构复杂难以维护。这时可以使用 Vue.js 的混合 <code>mixins</code>，将不同的逻辑分开到不同的 js 文件里。</p><p>比如上面的用户信息，就可以放到混合里：</p><p><em>user.js：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      userInfo: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    getUserInfo () &#123;</span><br><span class="line">      // 这里通过 ajax 获取用户信息后，赋值给 this.userInfo，以下为伪代码</span><br><span class="line">      $.ajax(&apos;/user/info&apos;, (data) =&gt; &#123;</span><br><span class="line">        this.userInfo = data;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    this.getUserInfo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>app.vue</code> 中混合：</p><p><em>app.vue：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import mixins_user from &apos;../mixins/user.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    mixins: [mixins_user],</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样，跟用户信息相关的逻辑，都可以在 <code>user.js</code> 里维护，或者由某个人来维护，<code>app.vue</code> 也就很容易维护了。</p><h2 id="独立组件中使用"><a href="#独立组件中使用" class="headerlink" title="独立组件中使用"></a>独立组件中使用</h2><p>如果你顾忌 Vue.js 文档中所说，provide / inject 不推荐直接在应用程序中使用，那没有关系，仍然使用你熟悉的 Vuex 或 Bus 来管理你的项目就好。我们介绍的这对 API，主要还是在独立组件中发挥作用的。</p><p>只要一个组件使用了 <code>provide</code> 向下提供数据，那其下所有的子组件都可以通过 <code>inject</code> 来注入，不管中间隔了多少代，而且可以注入多个来自不同父级提供的数据。需要注意的是，一旦注入了某个数据，比如上面示例中的 <code>app</code>，那这个组件中就不能再声明 <code>app</code> 这个数据了，因为它已经被父级占有。</p><p>独立组件使用 provide / inject 的场景，主要是具有联动关系的组件，比如接下来很快会介绍的第一个实战：具有数据校验功能的表单组件 Form。它其实是两个组件，一个是 Form，一个是 FormItem，FormItem 是 Form 的子组件，它会依赖 Form 组件上的一些特性（props），所以就需要得到父组件 Form，这在 Vue.js 2.2.0 版本以前，是没有 provide / inject 这对 API 的，而 Form 和 FormItem 不一定是父子关系，中间很可能间隔了其它组件，所以不能单纯使用 <code>$parent</code> 来向上获取实例。在 Vue.js 2.2.0 之前，一种比较可行的方案是用计算属性动态获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  form () &#123;</span><br><span class="line">    let parent = this.$parent;</span><br><span class="line">    while (parent.$options.name !== &apos;Form&apos;) &#123;</span><br><span class="line">      parent = parent.$parent;</span><br><span class="line">    &#125;</span><br><span class="line">    return parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个组件都可以设置 <code>name</code> 选项，作为组件名的标识，利用这个特点，通过向上遍历，直到找到需要的组件。这个方法可行，但相比一个 <code>inject</code> 来说，太费劲了，而且不那么优雅和 native。如果用 inject，可能只需要一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  inject: [&apos;form&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，这一切的前提是你使用 Vue.js 2.2.0 以上版本。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果这是你第一次听说 provide / inject 这对 API，一定觉得它太神奇了，至少笔者第一时间知晓时是这样的。它解决了独立组件间通信的问题，用好了还有出乎意料的效果。笔者在开发 <a href="https://dev.iviewui.com" target="_blank" rel="noopener">iView Developer</a> 时，全站就是使用这种方法来做全局数据的管理的，如果你有机会一个人做一个项目时，不妨试试这种方法。</p><p>下一节，将介绍另一种组件间通信的方法，不同于 provide / inject 的是，它们不是 Vue.js 内置的 API。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件的通信 3</title>
      <link href="/2018/09/07/%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%203%EF%BC%9A%E6%89%BE%E5%88%B0%E4%BB%BB%E6%84%8F%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94findComponents%20%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95/"/>
      <url>/2018/09/07/%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%203%EF%BC%9A%E6%89%BE%E5%88%B0%E4%BB%BB%E6%84%8F%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E2%80%94%E2%80%94findComponents%20%E7%B3%BB%E5%88%97%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="组件的通信-3：找到任意组件实例——findComponents-系列方法"><a href="#组件的通信-3：找到任意组件实例——findComponents-系列方法" class="headerlink" title="组件的通信 3：找到任意组件实例——findComponents 系列方法"></a>组件的通信 3：找到任意组件实例——findComponents 系列方法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前面的小节我们已经介绍了两种组件间通信的方法：provide / inject 和 dispatch / broadcast。它们有各自的使用场景和局限，比如前者多用于子组件获取父组件的状态，后者常用于父子组件间通过自定义事件通信。</p><p>本节将介绍第 3 种组件通信方法，也就是 findComponents 系列方法，它并非 Vue.js 内置，而是需要自行实现，以工具函数的形式来使用，它是一系列的函数，可以说是组件通信的终极方案。findComponents 系列方法最终都是返回组件的实例，进而可以读取或调用该组件的数据和方法。</p><p>它适用于以下场景：</p><ul><li>由一个组件，向上找到最近的指定组件；</li><li>由一个组件，向上找到所有的指定组件；</li><li>由一个组件，向下找到最近的指定组件；</li><li>由一个组件，向下找到所有指定的组件；</li><li>由一个组件，找到指定组件的兄弟组件。</li></ul><p>5 个不同的场景，对应 5 个不同的函数，实现原理也大同小异。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>5 个函数的原理，都是通过递归、遍历，找到指定组件的 <code>name</code> 选项匹配的组件实例并返回。</p><blockquote><p>本节以及后续章节，都是基于上一节的工程来完成，后续不再重复说明。</p><p>完整源码地址：<a href="https://github.com/icarusion/vue-component-book" target="_blank" rel="noopener">https://github.com/icarusion/vue-component-book</a></p></blockquote><p>在目录 <code>src</code> 下新建文件夹 <code>utils</code> 用来放置工具函数，并新建文件 <code>assist.js</code>，本节所有函数都在这个文件里完成，每个函数都通过 <code>export</code> 对外提供（如果你不了解 export，请查看扩展阅读1）。</p><h3 id="向上找到最近的指定组件——findComponentUpward"><a href="#向上找到最近的指定组件——findComponentUpward" class="headerlink" title="向上找到最近的指定组件——findComponentUpward"></a>向上找到最近的指定组件——findComponentUpward</h3><p>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// assist.js</span><br><span class="line">// 由一个组件，向上找到最近的指定组件</span><br><span class="line">function findComponentUpward (context, componentName) &#123;</span><br><span class="line">  let parent = context.$parent;</span><br><span class="line">  let name = parent.$options.name;</span><br><span class="line"></span><br><span class="line">  while (parent &amp;&amp; (!name || [componentName].indexOf(name) &lt; 0)) &#123;</span><br><span class="line">    parent = parent.$parent;</span><br><span class="line">    if (parent) name = parent.$options.name;</span><br><span class="line">  &#125;</span><br><span class="line">  return parent;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; findComponentUpward &#125;;</span><br></pre></td></tr></table></figure><p>findComponentUpward 接收两个参数，第一个是当前上下文，比如你要基于哪个组件来向上寻找，一般都是基于当前的组件，也就是传入 <code>this</code>；第二个参数是要找的组件的 <code>name</code> 。</p><p>findComponentUpward 方法会在 while 语句里不断向上覆盖当前的 <code>parent</code> 对象，通过判断组件（即 parent）的 name 与传入的 componentName 是否一致，直到直到最近的一个组件为止。</p><p>与 dispatch 不同的是，findComponentUpward 是直接拿到组件的实例，而非通过事件通知组件。比如下面的示例，有组件 A 和组件 B，A 是 B 的父组件，在 B 中获取和调用 A 中的数据和方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- component-a.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 A</span><br><span class="line">    &lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import componentB from &apos;./component-b.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;componentA&apos;,</span><br><span class="line">    components: &#123; componentB &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &apos;Aresn&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sayHello () &#123;</span><br><span class="line">        console.log(&apos;Hello, Vue.js&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- component-b.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 B</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; findComponentUpward &#125; from &apos;../utils/assist.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;componentB&apos;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      const comA = findComponentUpward(this, &apos;componentA&apos;);</span><br><span class="line">      </span><br><span class="line">      if (comA) &#123;</span><br><span class="line">        console.log(comA.name);  // Aresn</span><br><span class="line">        comA.sayHello();  // Hello, Vue.js</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用起来很简单，只要在需要的地方调用 findComponentUpward 方法就行，第一个参数一般都是传入 this，即当前组件的上下文（实例）。</p><p>上例的 comA，保险起见，加了一层 <code>if (comA)</code> 来判断是否找到了组件 A，如果没有指定的组件而调用的话，是会报错的。</p><p>findComponentUpward 只会找到最近的一个组件实例，如果要找到全部符合要求的组件，就需要用到下面的这个方法。</p><h3 id="向上找到所有的指定组件——findComponentsUpward"><a href="#向上找到所有的指定组件——findComponentsUpward" class="headerlink" title="向上找到所有的指定组件——findComponentsUpward"></a>向上找到所有的指定组件——findComponentsUpward</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// assist.js</span><br><span class="line">// 由一个组件，向上找到所有的指定组件</span><br><span class="line">function findComponentsUpward (context, componentName) &#123;</span><br><span class="line">  let parents = [];</span><br><span class="line">  const parent = context.$parent;</span><br><span class="line"></span><br><span class="line">  if (parent) &#123;</span><br><span class="line">    if (parent.$options.name === componentName) parents.push(parent);</span><br><span class="line">    return parents.concat(findComponentsUpward(parent, componentName));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; findComponentsUpward &#125;;</span><br></pre></td></tr></table></figure><p>与 findComponentUpward 不同的是，findComponentsUpward 返回的是一个数组，包含了所有找到的组件实例（注意函数名称中多了一个“s”）。</p><p>findComponentsUpward 的使用场景较少，一般只用在递归组件里面（后面小节会介绍），因为这个函数是一直向上寻找父级（parent）的，只有递归组件的父级才是自身。事实上，iView 在使用这个方法也都是用在递归组件的场景，比如菜单组件 Menu。由于递归组件在 Vue.js 组件里面并不常用，那自然 findComponentsUpward 也不常用了。</p><h3 id="向下找到最近的指定组件——findComponentDownward"><a href="#向下找到最近的指定组件——findComponentDownward" class="headerlink" title="向下找到最近的指定组件——findComponentDownward"></a>向下找到最近的指定组件——findComponentDownward</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// assist.js</span><br><span class="line">// 由一个组件，向下找到最近的指定组件</span><br><span class="line">function findComponentDownward (context, componentName) &#123;</span><br><span class="line">  const childrens = context.$children;</span><br><span class="line">  let children = null;</span><br><span class="line"></span><br><span class="line">  if (childrens.length) &#123;</span><br><span class="line">    for (const child of childrens) &#123;</span><br><span class="line">      const name = child.$options.name;</span><br><span class="line"></span><br><span class="line">      if (name === componentName) &#123;</span><br><span class="line">        children = child;</span><br><span class="line">        break;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        children = findComponentDownward(child, componentName);</span><br><span class="line">        if (children) break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return children;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; findComponentDownward &#125;;</span><br></pre></td></tr></table></figure><p><code>context.$children</code> 得到的是当前组件的全部子组件，所以需要遍历一遍，找到有没有匹配到的组件 <code>name</code>，如果没找到，继续递归找每个 $children 的 $children，直到找到最近的一个为止。</p><p>来看个示例，仍然是 A、B 两个组件，A 是 B 的父组件，在 A 中找到 B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- component-b.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 B</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;componentB&apos;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &apos;Aresn&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      sayHello () &#123;</span><br><span class="line">        console.log(&apos;Hello, Vue.js&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- component-a.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 A</span><br><span class="line">    &lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import componentB from &apos;./component-b.vue&apos;;</span><br><span class="line">  import &#123; findComponentDownward &#125; from &apos;../utils/assist.js&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;componentA&apos;,</span><br><span class="line">    components: &#123; componentB &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      const comB = findComponentDownward(this, &apos;componentB&apos;);</span><br><span class="line">      if (comB) &#123;</span><br><span class="line">        console.log(comB.name);  // Aresn</span><br><span class="line">        comB.sayHello();  // Hello, Vue.js</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>示例中的 A 和 B 是父子关系，因此也可以直接用 <code>ref</code> 来访问，但如果不是父子关系，中间间隔多代，用它就很方便了。</p><h3 id="向下找到所有指定的组件——findComponentsDownward"><a href="#向下找到所有指定的组件——findComponentsDownward" class="headerlink" title="向下找到所有指定的组件——findComponentsDownward"></a>向下找到所有指定的组件——findComponentsDownward</h3><p>如果要向下找到所有的指定组件，要用到 findComponentsDownward 函数，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// assist.js</span><br><span class="line">// 由一个组件，向下找到所有指定的组件</span><br><span class="line">function findComponentsDownward (context, componentName) &#123;</span><br><span class="line">  return context.$children.reduce((components, child) =&gt; &#123;</span><br><span class="line">    if (child.$options.name === componentName) components.push(child);</span><br><span class="line">    const foundChilds = findComponentsDownward(child, componentName);</span><br><span class="line">    return components.concat(foundChilds);</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line">export &#123; findComponentsDownward &#125;;</span><br></pre></td></tr></table></figure><p>这个函数实现的方式有很多，这里巧妙使用 <code>reduce</code> 做累加器，并用递归将找到的组件合并为一个数组并返回，代码量较少，但理解起来稍困难。</p><p>用法与 findComponentDownward 大同小异，就不再写用例了。</p><h3 id="找到指定组件的兄弟组件——findBrothersComponents"><a href="#找到指定组件的兄弟组件——findBrothersComponents" class="headerlink" title="找到指定组件的兄弟组件——findBrothersComponents"></a>找到指定组件的兄弟组件——findBrothersComponents</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// assist.js</span><br><span class="line">// 由一个组件，找到指定组件的兄弟组件</span><br><span class="line">function findBrothersComponents (context, componentName, exceptMe = true) &#123;</span><br><span class="line">  let res = context.$parent.$children.filter(item =&gt; &#123;</span><br><span class="line">    return item.$options.name === componentName;</span><br><span class="line">  &#125;);</span><br><span class="line">  let index = res.findIndex(item =&gt; item._uid === context._uid);</span><br><span class="line">  if (exceptMe) res.splice(index, 1);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line">export &#123; findBrothersComponents &#125;;</span><br></pre></td></tr></table></figure><p>相比其它 4 个函数，findBrothersComponents 多了一个参数 <code>exceptMe</code>，是否把本身除外，默认是 true。寻找兄弟组件的方法，是先获取 <code>context.$parent.$children</code>，也就是父组件的全部子组件，这里面当前包含了本身，所有也会有第三个参数 exceptMe。Vue.js 在渲染组件时，都会给每个组件加一个内置的属性 <code>_uid</code>，这个 _uid 是不会重复的，借此我们可以从一系列兄弟组件中把自己排除掉。</p><p>举个例子，组件 A 是组件 B 的父级，在 B 中找到所有在 A 中的兄弟组件（也就是所有在 A 中的 B 组件）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- component-a.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 A</span><br><span class="line">    &lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import componentB from &apos;./component-b.vue&apos;;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;componentA&apos;,</span><br><span class="line">    components: &#123; componentB &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- component-b.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 B</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; findBrothersComponents &#125; from &apos;../utils/assist.js&apos;;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;componentB&apos;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      const comsB = findBrothersComponents(this, &apos;componentB&apos;);</span><br><span class="line">      console.log(comsB);  // ① []，空数组</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在 ① 的位置，打印出的内容为空数组，原因是当前 A 中只有一个 B，而 findBrothersComponents 的第三个参数默认是 true，也就是将自己除外。如果在 A 中再写一个 B：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- component-a.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 A</span><br><span class="line">    &lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">    &lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>这时就会打印出 <code>[VueComponent]</code>，有一个组件了，但要注意在控制台会打印两遍，因为在 A 中写了两个 B，而 <code>console.log</code> 是在 B 中定义的，所以两个都会执行到。如果你看懂了这里，那应该明白打印的两遍 <code>[VueComponent]</code>，分别是另一个 <code>&lt;component-b&gt;</code>（如果没有搞懂，要仔细琢磨琢磨哦）。</p><p>如果将 B 中 findBrothersComponents 的第三个参数设置为 false：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// component-b.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;componentB&apos;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    const comsB = findBrothersComponents(this, &apos;componentB&apos;, false);</span><br><span class="line">    console.log(comsB);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就会打印出 <code>[VueComponent, VueComponent]</code>，也就是包含自身了。</p><p>以上就是 5 个函数的详细介绍，get 到这 5 个，以后就再也不用担心组件通信了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>只有你认真开发过 Vue.js 独立组件，才会明白这 5 个函数的强大之处。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ES6 Module 的语法</a></li></ul><p>注：本节部分代码参考 <a href="https://github.com/iview/iview/blob/2.0/src/utils/assist.js" target="_blank" rel="noopener">iView</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件的通信 2</title>
      <link href="/2018/09/07/%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%202%EF%BC%9A%E6%B4%BE%E5%8F%91%E4%B8%8E%E5%B9%BF%E6%92%AD%E2%80%94%E2%80%94%E8%87%AA%E8%A1%8C%E5%AE%9E%E7%8E%B0%20dispatch%20%E5%92%8C%20broadcast%20%E6%96%B9%E6%B3%95/"/>
      <url>/2018/09/07/%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%202%EF%BC%9A%E6%B4%BE%E5%8F%91%E4%B8%8E%E5%B9%BF%E6%92%AD%E2%80%94%E2%80%94%E8%87%AA%E8%A1%8C%E5%AE%9E%E7%8E%B0%20dispatch%20%E5%92%8C%20broadcast%20%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="组件的通信-2：派发与广播——自行实现-dispatch-和-broadcast-方法"><a href="#组件的通信-2：派发与广播——自行实现-dispatch-和-broadcast-方法" class="headerlink" title="组件的通信 2：派发与广播——自行实现 dispatch 和 broadcast 方法"></a>组件的通信 2：派发与广播——自行实现 dispatch 和 broadcast 方法</h1><p>上一讲的 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。然后有两种场景它不能很好的解决：</p><ul><li>父组件向子组件（支持跨级）传递数据；</li><li>子组件向父组件（支持跨级）传递数据。</li></ul><p>这种父子（含跨级）传递数据的通信方式，Vue.js 并没有提供原生的 API 来支持，而是推荐使用大型数据状态管理工具 Vuex，而我们之前已经介绍过 Vuex 的场景与在独立组件（或库）中使用的限制。本小节则介绍一种在父子组件间通信的方法 <code>dispatch</code> 和 <code>broadcast</code>。</p><h2 id="on-与-emit"><a href="#on-与-emit" class="headerlink" title="$on 与 $emit"></a>$on 与 $emit</h2><p>如果您使用过较早的 Vue.js 1.x 版本，肯定对 <em>$dispatch</em> 和 <em>$broadcast</em> 这两个内置的方法很熟悉，不过它们都在 Vue.js 2.x 里废弃了。在正式介绍主角前，我们先看看 <code>$on</code> 与 <code>$emit</code> 这两个 API，因为它们是本节内容的基础。</p><p><code>$emit</code> 会在<strong>当前组件</strong>实例上触发自定义事件，并传递一些参数给监听器的回调，一般来说，都是在父级调用这个组件时，使用 <code>@on</code> 的方式来监听自定义事件的，比如在子组件中触发事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// child.vue，部分代码省略</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleEmitEvent () &#123;</span><br><span class="line">      this.$emit(&apos;test&apos;, &apos;Hello Vue.js&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在父组件中监听由 <em>child.vue</em> 触发的自定义事件 <strong>test</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- parent.vue，部分代码省略--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;child-component @test=&quot;handleEvent&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleEvent (text) &#123;</span><br><span class="line">      console.log(text);  // Hello Vue.js</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这里看似是在父组件 <em>parent.vue</em> 中绑定的自定义事件 <strong>test</strong> 的处理句柄，然而事件 test 并不是在父组件上触发的，而是在子组件 <em>child.vue</em> 里触发的，只是通过 <code>v-on</code> 在父组件中监听。既然是子组件自己触发的，那它自己也可以监听到，这就要使用 <code>$on</code> 来监听实例上的事件，换言之，组件使用 <code>$emit</code> 在自己实例上触发事件，并用 <code>$on</code> 监听它。</p><p>听起来这种神（sāo）操作有点多此一举，我们不妨先来看个示例：</p><p>（也可通过在线链接 <a href="https://run.iviewui.com/ggsomfHM" target="_blank" rel="noopener">https://run.iviewui.com/ggsomfHM</a> 直接运行该示例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;handleEmitEvent&quot;&gt;触发自定义事件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleEmitEvent () &#123;</span><br><span class="line">        // 在当前组件上触发自定义事件 test，并传值</span><br><span class="line">        this.$emit(&apos;test&apos;, &apos;Hello Vue.js&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      // 监听自定义事件 test</span><br><span class="line">      this.$on(&apos;test&apos;, (text) =&gt; &#123;</span><br><span class="line">        window.alert(text);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>$on</code> 监听了自己触发的自定义事件 test，因为有时不确定何时会触发事件，一般会在 <code>mounted</code> 或 <code>created</code> 钩子中来监听。</p><p>仅上面的示例，的确是多此一举的，因为大可在 handleEmitEvent 里直接写 window.alert(text)，没必要绕一圈。</p><p>之所以多此一举，是因为 handleEmitEvent 是当前组件内的 <code>&lt;button&gt;</code> 调用的，如果这个方法不是它自己调用，而是其它组件调用的，那这个用法就大有可为了。</p><p>了解了 <code>$on</code> 和 <code>$emit</code> 的用法后，我们再来看两个“过时的” API。</p><h2 id="Vue-js-1-x-的-dispatch-与-broadcast"><a href="#Vue-js-1-x-的-dispatch-与-broadcast" class="headerlink" title="Vue.js 1.x 的 $dispatch 与 $broadcast"></a>Vue.js 1.x 的 $dispatch 与 $broadcast</h2><p>虽然 Vue.js 1.x 已经成为过去时，但为了充分理解本节通信方法的使用场景，还是有必要来了解一点它的历史。</p><p>在 Vue.js 1.x 中，提供了两个方法：<code>$dispatch</code> 和 <code>$broadcast</code> ，前者用于向上级派发事件，只要是它的父级（一级或多级以上），都可以在组件内通过 <code>$on</code> （或 events，2.x 已废弃）监听到，后者相反，是由上级向下级广播事件的。</p><p>来看一个简单的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注意：该示例为 Vue.js 1.x 版本 --&gt;</span><br><span class="line">&lt;!-- 子组件 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;handleDispatch&quot;&gt;派发事件&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleDispatch () &#123;</span><br><span class="line">      this.$dispatch(&apos;test&apos;, &apos;Hello, Vue.js&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 父组件，部分代码省略 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;child-component&gt;&lt;/child-component&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      this.$on(&apos;test&apos;, (text) =&gt; &#123;</span><br><span class="line">        console.log(text);  // Hello, Vue.js</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>$broadcast 类似，只不过方向相反。这两种方法一旦发出事件后，任何组件都是可以接收到的，就近原则，而且会在第一次接收到后停止冒泡，除非返回 true。</p><p>这两个方法虽然看起来很好用，但是在 Vue.js 2.x 中都废弃了，官方给出的解释是：</p><blockquote><p>因为基于组件树结构的事件流方式有时让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。</p></blockquote><p>虽然在业务开发中，它没有 Vuex 这样专门管理状态的插件清晰好用，但对独立组件（库）的开发，绝对是福音。因为独立组件一般层级并不会很复杂，并且剥离了业务，不会变的难以维护。</p><p>知道了 <em>$dispatch</em> 和 <em>$broadcast</em> 的前世今生，接下来我们就在 Vue.js 2.x 中自行实现这两个方法。</p><h2 id="自行实现-dispatch-和-broadcast-方法"><a href="#自行实现-dispatch-和-broadcast-方法" class="headerlink" title="自行实现 dispatch 和 broadcast 方法"></a>自行实现 dispatch 和 broadcast 方法</h2><p>自行实现的 dispatch 和 broadcast 方法，不能保证跟 Vue.js 1.x 的 <em>$dispatch</em> 和 <em>$broadcast</em> 具有完全相同的体验，但基本功能是一样的，都是解决父子组件（含跨级）间的通信问题。</p><p>通过目前已知的信息，我们要实现的 dispatch 和 broadcast 方法，将具有以下功能：</p><ul><li>在子组件调用 dispatch 方法，向上级指定的组件实例（最近的）上触发自定义事件，并传递数据，且该上级组件已预先通过 <code>$on</code> 监听了这个事件；</li><li>相反，在父组件调用 broadcast 方法，向下级指定的组件实例（最近的）上触发自定义事件，并传递数据，且该下级组件已预先通过 <code>$on</code> 监听了这个事件。</li></ul><p>实现这对方法的关键点在于，如何正确地向上或向下找到对应的组件实例，并在它上面触发方法。在设计一个新功能（features）时，可以先确定这个功能的 API 是什么，也就是说方法名、参数、使用样例，确定好 API，再来写具体的代码。</p><p>因为 Vue.js 内置的方法，才是以 <code>$</code> 开头的，比如 <code>$nextTick</code>、<code>$emit</code> 等，为了避免不必要的冲突并遵循规范，这里的 dispatch 和 broadcast 方法名前不加 <code>$</code>。并且该方法可能在很多组件中都会使用，复用起见，我们封装在混合（mixins）里。那它的使用样例可能是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 部分代码省略</span><br><span class="line">import Emitter from &apos;../mixins/emitter.js&apos;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mixins: [ Emitter ],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleDispatch () &#123;</span><br><span class="line">      this.dispatch();  // ①</span><br><span class="line">    &#125;,</span><br><span class="line">    handleBroadcast () &#123;</span><br><span class="line">      this.broadcast();  // ②</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中行 ① 和行 ② 的两个方法就是在导入的混合 <strong>emitter.js</strong> 中定义的，这个稍后我们再讲，先来分析这两个方法应该传入什么参数。一般来说，为了跟 Vue.js 1.x 的方法一致，第一个参数应当是自定义事件名，比如 “test”，第二个参数是传递的数据，比如 “Hello, Vue.js”，但在这里，有什么问题呢？只通过这两个参数，我们没办法知道要在哪个组件上触发事件，因为自行实现的这对方法，与 Vue.js 1.x 的原生方法机理上是有区别的。上文说到，实现这对方法的关键点在于准确地<strong>找到组件实例</strong>。那在寻找组件实例上，我们的“惯用伎俩”就是通过遍历来匹配组件的 <code>name</code> 选项，在独立组件（库）里，每个组件的 <code>name</code> 值应当是唯一的，name 主要用于递归组件，在后面小节会单独介绍。</p><p>先来看下 <strong>emitter.js</strong> 的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function broadcast(componentName, eventName, params) &#123;</span><br><span class="line">  this.$children.forEach(child =&gt; &#123;</span><br><span class="line">    const name = child.$options.name;</span><br><span class="line"></span><br><span class="line">    if (name === componentName) &#123;</span><br><span class="line">      child.$emit.apply(child, [eventName].concat(params));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      broadcast.apply(child, [componentName, eventName].concat([params]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    dispatch(componentName, eventName, params) &#123;</span><br><span class="line">      let parent = this.$parent || this.$root;</span><br><span class="line">      let name = parent.$options.name;</span><br><span class="line"></span><br><span class="line">      while (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">        parent = parent.$parent;</span><br><span class="line"></span><br><span class="line">        if (parent) &#123;</span><br><span class="line">          name = parent.$options.name;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (parent) &#123;</span><br><span class="line">        parent.$emit.apply(parent, [eventName].concat(params));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    broadcast(componentName, eventName, params) &#123;</span><br><span class="line">      broadcast.call(this, componentName, eventName, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为是用作 mixins 导入，所以在 methods 里定义的 dispatch 和 broadcast 方法会被混合到组件里，自然就可以用 <code>this.dispatch</code> 和 <code>this.broadcast</code> 来使用。</p><p>这两个方法都接收了三个参数，第一个是组件的 <code>name</code> 值，用于向上或向下递归遍历来寻找对应的组件，第二个和第三个就是上文分析的自定义事件名称和要传递的数据。</p><p>可以看到，在 dispatch 里，通过 <em>while</em> 语句，不断向上遍历更新当前组件（即上下文为当前调用该方法的组件）的父组件实例（变量 parent 即为父组件实例），直到匹配到定义的 <code>componentName</code> 与某个上级组件的 <code>name</code> 选项一致时，结束循环，并在找到的组件实例上，调用 <code>$emit</code> 方法来触发自定义事件 <code>eventName</code>。broadcast 方法与之类似，只不过是向下遍历寻找。</p><p>来看一下具体的使用方法。有 <strong>A.vue</strong> 和 <strong>B.vue</strong> 两个组件，其中 B 是 A 的子组件，中间可能跨多级，在 A 中向 B 通信：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- A.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;button @click=&quot;handleClick&quot;&gt;触发事件&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Emitter from &apos;../mixins/emitter.js&apos;;</span><br><span class="line">  </span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;componentA&apos;,</span><br><span class="line">    mixins: [ Emitter ],</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick () &#123;</span><br><span class="line">        this.broadcast(&apos;componentB&apos;, &apos;on-message&apos;, &apos;Hello Vue.js&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// B.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;componentB&apos;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    this.$on(&apos;on-message&apos;, this.showMessage);</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showMessage (text) &#123;</span><br><span class="line">      window.alert(text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，如果是 B 向 A 通信，在 B 中调用 dispatch 方法，在 A 中使用 $on 监听事件即可。</p><p>以上就是自行实现的 dispatch 和 broadcast 方法，相比 Vue.js 1.x，有以下不同：</p><ul><li>需要额外传入组件的 name 作为第一个参数；</li><li>无冒泡机制；</li><li>第三个参数传递的数据，只能是一个（较多时可以传入一个对象），而 Vue.js 1.x 可以传入多个参数，当然，你对 emitter.js 稍作修改，也能支持传入多个参数，只是一般场景传入一个对象足以。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Vue.js 的组件通信到此还没完全结束，如果你想“趁热打铁”一口气看完，可以先阅读第 6 节组件的通信 3。亦或按顺序看下一节的实战，来进一步加深理解 provide / inject 和 dispatch / broadcast 这两对通信方法的使用场景。</p><p>注：本节部分代码参考 <a href="https://github.com/iview/iview/blob/2.0/src/mixins/emitter.js" target="_blank" rel="noopener">iView</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归组件与动态组件</title>
      <link href="/2018/09/07/%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/09/07/%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="递归组件与动态组件"><a href="#递归组件与动态组件" class="headerlink" title="递归组件与动态组件"></a>递归组件与动态组件</h1><h2 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h2><p>递归组件就是指组件在模板中调用自己，开启递归组件的必要条件，就是在组件中设置一个 <code>name</code> 选项。比如下面的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;my-component&gt;&lt;/my-component&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;my-component&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在 Webpack 中导入一个 Vue.js 组件，一般是通过 <code>import myComponent from &#39;xxx&#39;</code> 这样的语法，然后在当前组件（页面）的 <code>components: { myComponent }</code> 里注册组件。这种组件是不强制设置 <code>name</code> 字段的，组件的名字都是使用者在 import 进来后自定义的，但递归组件的使用者是组件自身，它得知道这个组件叫什么，因为没有用 <code>components</code> 注册，所以 <code>name</code> 字段就是必须的了。除了递归组件用 <code>name</code>，我们在之前的小节也介绍过，用一些特殊的方法，通过遍历匹配组件的 name 选项来寻找组件实例。</p><p>不过呢，上面的示例是有问题的，如果直接运行，会抛出 <code>max stack size exceeded</code> 的错误，因为组件会无限递归下去，死循环。解决这个问题，就要给递归组件一个限制条件，一般会在递归组件上用 <code>v-if</code> 在某个地方设置为 <code>false</code> 来终结。比如我们给上面的示例加一个属性 count，当大于 5 时就不再递归：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;my-component :count=&quot;count + 1&quot; v-if=&quot;count &lt;= 5&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &apos;my-component&apos;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      count: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>所以，总结下来，实现一个递归组件的必要条件是：</p><ul><li>要给组件设置 <strong>name</strong>；</li><li>要有一个明确的结束条件</li></ul><p>递归组件常用来开发具有未知层级关系的独立组件，在业务开发中很少使用。比如常见的有级联选择器和树形控件：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/167398b8f5a828b1?w=1600&h=676&f=png&s=44587" alt></p><p>这类组件一般都是数据驱动型的，父级有一个字段 children，然后递归。下一节的实战，会开发一个树形控件 Tree。</p><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><p>有的时候，我们希望根据一些条件，动态地切换某个组件，或动态地选择渲染某个组件。在之前小节介绍函数式组件 Functional Render 时，已经说过，它是一个没有上下文的函数，常用于程序化地在多个组件中选择一个。使用 Render 或 Functional Render 可以解决动态切换组件的需求，不过那是基于一个 JS 对象（Render 函数），而 Vue.js 提供了另外一个内置的组件 <code>&lt;component&gt;</code> 和 <code>is</code> 特性，可以更好地实现动态组件。</p><p>先来看一个 <code>&lt;component&gt;</code> 和 <code>is</code> 的基本示例，首先定义三个普通组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 A</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- b.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 B</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- c.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 C</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后在父组件中导入这 3 个组件，并动态切换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;handleChange(&apos;A&apos;)&quot;&gt;显示 A 组件&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;handleChange(&apos;B&apos;)&quot;&gt;显示 B 组件&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;handleChange(&apos;C&apos;)&quot;&gt;显示 C 组件&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;component :is=&quot;component&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import componentA from &apos;../components/a.vue&apos;;</span><br><span class="line">  import componentB from &apos;../components/b.vue&apos;;</span><br><span class="line">  import componentC from &apos;../components/c.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        component: componentA</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleChange (component) &#123;</span><br><span class="line">        if (component === &apos;A&apos;) &#123;</span><br><span class="line">          this.component = componentA;</span><br><span class="line">        &#125; else if (component === &apos;B&apos;) &#123;</span><br><span class="line">          this.component = componentB;</span><br><span class="line">        &#125; else if (component === &apos;C&apos;) &#123;</span><br><span class="line">          this.component = componentC;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>is</code> 动态绑定的是一个组件对象（Object），它直接指向 a / b / c 三个组件中的一个。除了直接绑定一个 Object，还可以是一个 String，比如标签名、组件名。下面的这个组件，将原生的按钮 button 进行了封装，如果传入了 <code>prop: to</code>，那它会渲染为一个 <code>&lt;a&gt;</code> 标签，用于打开这个链接地址，如果没有传入 <code>to</code>，就当作普通 button 使用。来看下面的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- button.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component :is=&quot;tagName&quot; v-bind=&quot;tagProps&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/component&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      // 链接地址</span><br><span class="line">      to: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &apos;&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 链接打开方式，如 _blank</span><br><span class="line">      target: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &apos;_self&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      // 动态渲染不同的标签</span><br><span class="line">      tagName () &#123;</span><br><span class="line">        return this.to === &apos;&apos; ? &apos;button&apos; : &apos;a&apos;;</span><br><span class="line">      &#125;,</span><br><span class="line">      // 如果是链接，把这些属性都绑定在 component 上</span><br><span class="line">      tagProps () &#123;</span><br><span class="line">        let props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        if (this.to) &#123;</span><br><span class="line">          props = &#123;</span><br><span class="line">            target: this.target,</span><br><span class="line">            href: this.to</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return props;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>使用组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;i-button&gt;普通按钮&lt;/i-button&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;i-button to=&quot;https://juejin.im&quot;&gt;链接按钮&lt;/i-button&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;i-button to=&quot;https://juejin.im&quot; target=&quot;_blank&quot;&gt;新窗口打开链接按钮&lt;/i-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import iButton from &apos;../components/a.vue&apos;;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    components: &#123; iButton &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>最终会渲染出一个原生的 <code>&lt;button&gt;</code> 按钮和两个原生的链接 <code>&lt;a&gt;</code>，且第二个点击会在新窗口中打开链接，如图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/167398c004dc0c60?w=328&h=166&f=png&s=18861" alt></p><p>i-button 组件中的 <code>&lt;component&gt;</code> <code>is</code> 绑定的就是一个标签名称 button / a，并且通过 <code>v-bind</code> 将一些额外的属性全部绑定到了 <code>&lt;component&gt;</code> 上。</p><p>再回到第一个 a / b / c 组件切换的示例，如果这类的组件，频繁切换，事实上组件是会重新渲染的，比如我们在组件 A 里加两个生命周期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    组件 A</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      console.log(&apos;组件创建了&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy () &#123;</span><br><span class="line">      console.log(&apos;组件销毁了&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>只要切换到 A 组件，<code>mounted</code> 就会触发一次，切换到其它组件，<code>beforeDestroy</code> 也会触发一次，说明组件再重新渲染，这样有可能导致性能问题。为了避免组件的重复渲染，可以在 <code>&lt;component&gt;</code> 外层套一个 Vue.js 内置的 <code>&lt;keep-alive&gt;</code> 组件，这样，组件就会被缓存起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is=&quot;component&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p>这时，只有 <code>mounted</code> 触发了，如果不离开当前页面，切换到其它组件，<code>beforeDestroy</code> 不会被触发，说明组件已经被缓存了。</p><p>keep-alive 还有一些额外的 props 可以配置：</p><ul><li><code>include</code>：字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li><code>exclude</code>：字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li><code>max</code>：数字。最多可以缓存多少组件实例。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>还有一类是异步组件，Vue.js 文档已经介绍的很清楚了，可以阅读文末的扩展阅读 1。事实上异步组件我们用的很多，比如 router 的配置列表，一般都是用的异步组件形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: &apos;/form&apos;,</span><br><span class="line">  component: () =&gt; import(&apos;./views/form.vue&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每个页面才会在路由到时才加载对应的 JS 文件，否则入口文件会非常庞大。</p><p>递归组件、动态组件和异步组件是 Vue.js 中相对冷门的 3 种组件模式，不过在封装复杂的独立组件时，前两者会经常使用。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">异步组件</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看win主机IP</title>
      <link href="/2016/06/07/1.%E6%9F%A5%E7%9C%8BWin%E4%B8%BB%E6%9C%BAIP/"/>
      <url>/2016/06/07/1.%E6%9F%A5%E7%9C%8BWin%E4%B8%BB%E6%9C%BAIP/</url>
      
        <content type="html"><![CDATA[<h2 id="查看win主机IP"><a href="#查看win主机IP" class="headerlink" title="查看win主机IP"></a>查看win主机IP</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipconfig -all // windows</span><br><span class="line">ifconfig // linux</span><br></pre></td></tr></table></figure><ul><li><p>服务器：没有图形化界面支持，图形化界面支持会导致系统不稳定</p><ul><li><p>window server：可视化工具</p><ul><li>可视化：能看见</li></ul></li><li><p>Unix：大部分Linux操作系统，是不包含图形化界面，稳定了</p><ul><li>unix</li><li>linux</li></ul></li><li><p>不好管理：</p><ul><li>运维：网管，管理服务器</li></ul></li><li><p>linxu跑服务：</p><ul><li><p><code>centos6</code>、 <code>centos7</code></p></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">centos6: service mysql start|status|stop</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>SSH协议：加密的协议</p><ul><li>专门可以通过22端口远程连接目标主机</li><li>直接通过远端连接进行命令行操作</li></ul></li><li><p>FTP、SFTP</p><ul><li>文件传输协议 </li><li>file transport portocol</li></ul></li></ul><table><thead><tr><th>words</th><th>describ</th></tr></thead><tbody><tr><td>HTTP、FTP、…，有TCP协议而来，适用于不同业务</td><td>应用层</td></tr><tr><td>TCP：定义数据传输方式</td><td>传输层</td></tr><tr><td>IP：定义目标及客户端主机地址，常与端口结合ip:port  127.0.0.1:8000</td><td>IP层</td></tr><tr><td>网卡设备、交换传输格式等</td><td>链路层</td></tr></tbody></table><ul><li><p>tcp</p><blockquote><p>传输数据 传输如果结束不了，那么连接不会断的 </p><p>TCP / UDP</p><p>打电话 / 发简讯</p><p>流式协议 / 报文协议</p></blockquote></li><li><p>SYN泛洪攻击：通过构建TCP SYN握手包，使目标服务器处于大量的连接等待状态，消耗资源，占用端口资源，使服务器没有办法做正事</p></li></ul><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><h3 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h3>]]></content>
      
      
      <categories>
          
          <category> Windos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-登录状态</title>
      <link href="/2016/06/07/10.Djanago-Cookie%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%99%BB%E9%99%86/"/>
      <url>/2016/06/07/10.Djanago-Cookie%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%99%BB%E9%99%86/</url>
      
        <content type="html"><![CDATA[<h2 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h2><ul><li><p>1：用户第一次访问服务端的时候，</p></li><li><p>2：服务端会返回一个COOKIE值给客户</p></li><li><p>3：客户端接下来的访问要带着COOKIE值来访问服务端</p></li><li><p>4：服务端检查cookie值是否存在，如果存在，则说明状态保留，反之没有cookie，代表没有状态</p></li><li><p>COOKIE存储在浏览器中，客户的手里</p></li><li><p>服务端返回COOKIE，设置COOKIE在Response函数中</p><ul><li>res = HttpResponse()<ul><li>res.set_cookie(‘is_login’, ‘张三’, max_age)</li><li>max_age：默认的在浏览器关闭之后，cookie值消失</li></ul></li><li>redirect()</li><li>render()</li></ul></li><li><p>服务端捕捉COOKIE，在参数request中</p><ul><li>request.COOKIES.get(‘is_login’)</li></ul></li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><blockquote><p>再看看三次握手 四次挥手</p><p>真正了解 流式协议  长连接 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django基础</title>
      <link href="/2016/06/07/1.Django%E5%9F%BA%E7%A1%80/"/>
      <url>/2016/06/07/1.Django%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>#Django</p><h2 id="一-软件框架"><a href="#一-软件框架" class="headerlink" title="一.软件框架"></a>一.软件框架</h2><p>一个软件框架是有期中<strong><em>各个软件模块组</em></strong>成的，<strong><em>每一个模块都有特定功能</em></strong>，模块与模块之间通过<strong><em>相互配合</em></strong>来完成软件开发。</p><h2 id="二-MVC框架"><a href="#二-MVC框架" class="headerlink" title="二.MVC框架"></a>二.MVC框架</h2><p>MVC的核心思想：<strong>解耦</strong> </p><p>MVC框架里面的三个模块：</p><ul><li>M：Model模型，和数据库进行交互。</li><li>V：View视图，产生HTML页面。</li><li>C：Controller控制器，接收请求，进行处理，与M和V进行交互，返回应答。</li></ul><h2 id="三-MVT"><a href="#三-MVT" class="headerlink" title="三.MVT"></a>三.MVT</h2><ul><li>M：Model模型。和MVC中的M功能相同，和数据库进行交互。</li><li>V：View视图。和MVC中C功能相同，接收请求，进行处理，与M和T进行交互，返回应答。</li><li>T：Template,模板。和MVC中V功能相同，产生HTML页面。</li></ul><h2 id="四：虚拟环境"><a href="#四：虚拟环境" class="headerlink" title="四：虚拟环境"></a>四：虚拟环境</h2><p>点击查看：Django网站<a href="http://www.djangoproject.com" target="_blank" rel="noopener">www.djangoproject.com</a></p><p>点击查看：Django1.8.2中文文档<a href="http://www.python.usyiyi.cn" target="_blank" rel="noopener">www.python.usyiyi.cn</a></p><ul><li><p>之前安装的Python包的命令：sudo pip3 install 包名</p></li><li><p>包的安装路径： /usr/local/lib/python3.5.0/dist-packages</p></li><li><p>安装同一个包不同版本，后安装的包会把原来安装的包覆盖掉。这样，如同一台机器上两个项目依赖于相同包的不同版本，则会导致一些项目运行失败。</p></li><li><p><strong>解决方案就是:虚拟环境</strong></p></li><li><p><strong>虚拟环境就是Phthon环境的复制版本。</strong></p></li><li><p><strong>在虚拟环境中使用的Python是复制的Python安装Python包也是安装在复制的Python中。</strong></p></li></ul><p>安装虚拟环境的命令：</p><blockquote><p>安装虚拟环境所需要的包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install virtialenv             //安装虚拟环境</span><br><span class="line">sudo pip install virtualenvwrapper       //安装虚拟环境拓展包</span><br></pre></td></tr></table></figure><blockquote><p>在主目录下边编辑配置文件</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">编辑家目录下面的     </span><br><span class="line">vi .bashrc文件，                   <span class="comment">//添加下面两行到末尾</span></span><br><span class="line">i              <span class="comment">//写入</span></span><br><span class="line">export WORKON_HOME=$HOME/.virtualenvs          <span class="comment">//￥HOME 代表家目录的路径</span></span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh     <span class="comment">//创建虚拟环境要使用一些命令要想直接使用命令就得把这两句话加上</span></span><br><span class="line">Esc    </span><br><span class="line">：wq   <span class="comment">//保存退出</span></span><br><span class="line">source.bashrc        <span class="comment">//使其生效一下</span></span><br></pre></td></tr></table></figure><blockquote><p>创建虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">makvirtualenv         //创建虚拟环境</span><br><span class="line">例子：</span><br><span class="line">mkvirtualenv -p python3 bj18_py3</span><br><span class="line">创建虚拟环境      指定版本  虚拟环境的名称</span><br></pre></td></tr></table></figure><blockquote><p>退出虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate              //退出虚拟环境</span><br></pre></td></tr></table></figure><blockquote><p>进入虚拟环境 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">workon       //进入虚拟环境</span><br><span class="line">列:workon bj18_py3        输入命令 指定需要进入到那个虚拟环境</span><br></pre></td></tr></table></figure><blockquote><p>查看机器上有多少个虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 workon 加上 空格 和两个 Tab</span><br></pre></td></tr></table></figure><blockquote><p>删除虚拟环境</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmvirtualenv 加上 需要删除虚拟环境的名字</span><br></pre></td></tr></table></figure><blockquote><p>查看当前虚拟环境下面安装了多少Python包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip list</span><br><span class="line">pip freeze</span><br></pre></td></tr></table></figure><blockquote><p>安装指定版本的包</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django==2.0.4</span><br></pre></td></tr></table></figure><h2 id="五-项目创建"><a href="#五-项目创建" class="headerlink" title="五:项目创建"></a>五:项目创建</h2><blockquote><p>命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">django-admin startproject 项目名</span><br></pre></td></tr></table></figure><h3 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__init__.py                   //说着这个文件是一个python包</span><br><span class="line">settings.py                   //项目的配置文件</span><br><span class="line">urls.py                     //进行Url路由的配置</span><br><span class="line">wsgi.py                //web服务器和我们的Django交互的入口</span><br><span class="line">manage.py              //项目的管理文件</span><br></pre></td></tr></table></figure><h3 id="2-创建应用"><a href="#2-创建应用" class="headerlink" title="2.创建应用"></a>2.创建应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp booktest</span><br><span class="line">python  manage.py  startapp  应用名字</span><br></pre></td></tr></table></figure><ul><li><p>应用文件下面的文件作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  __init__.py               //说明目录是一个Python模块</span><br><span class="line">  models.py                    //写和数据库相关的内容</span><br><span class="line">  views.py           //接受请求、进行处理、与M和T进行交互、返回应答.定义处理函数（视图函数）</span><br><span class="line">  tests.py       //写测试代码的文件</span><br><span class="line">admin.py        //网站后台管理相关的文件</span><br></pre></td></tr></table></figure></li></ul><p>  建立应用和项目之间的连续，需要对应用进行注册</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">项目名————&gt;settings.py   --↓</span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &apos;django.contrib.admin&apos;,</span><br><span class="line">    &apos;django.contrib.auth&apos;,</span><br><span class="line">    &apos;django.contrib.contenttypes&apos;,</span><br><span class="line">    &apos;django.contrib.sessions&apos;,</span><br><span class="line">    &apos;django.contrib.messages&apos;,</span><br><span class="line">    &apos;django.contrib.staticfiles&apos;,</span><br><span class="line">    &apos;booktes&apos;,         &lt;-----以应用的名字进行项目注册</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>启动项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure><h2 id="六-ORM"><a href="#六-ORM" class="headerlink" title="六.ORM"></a>六.ORM</h2><p>ORM 可以通过类和对象去操作他对应的表，不需要sql语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object:对象 - 类</span><br><span class="line">Mapping:映射</span><br><span class="line">Relations:关系，关系数据库中的表</span><br></pre></td></tr></table></figure><p>models.py            //这个文件的作用是 设计和表对应的类，模型类</p><h2 id="七-模型类"><a href="#七-模型类" class="headerlink" title="七.模型类"></a>七.模型类</h2><h3 id="1-模型类设计"><a href="#1-模型类设计" class="headerlink" title="1.模型类设计"></a>1.模型类设计</h3><p>在应用models.py 中设计模型类。</p><p>必须继承与models.Model类</p><p>Models.ForeignKey可以建立两个模型之间一对多的关系，Django在成功生成表的时候，就会在表中管创建一列作为外键，建立两个表之间一对多的关系。</p><h3 id="2-模型类生成表"><a href="#2-模型类生成表" class="headerlink" title="2.模型类生成表"></a>2.模型类生成表</h3><ul><li><p>生成迁移文件</p><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure><p>迁移文件是根据模型类生成的</p></li><li><p>执行迁移生成表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>migrate 里面的迁移文件不能删，因为每次迁移都有依赖关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator\Desktop\Django&gt;python manage.py migrate</span><br><span class="line">Operations to perform:</span><br><span class="line">  Apply all migrations: admin, auth, booktest, contenttypes, sessions</span><br><span class="line">Running migrations:</span><br><span class="line">  Applying contenttypes<span class="number">.0001</span>_initial... OK</span><br><span class="line">  Applying auth<span class="number">.0001</span>_initial... OK</span><br><span class="line">  Applying admin<span class="number">.0001</span>_initial... OK</span><br><span class="line">  Applying admin<span class="number">.0002</span>_logentry_remove_auto_add... OK</span><br><span class="line">  Applying contenttypes<span class="number">.0002</span>_remove_content_type_name... OK</span><br><span class="line">  Applying auth<span class="number">.0002</span>_alter_permission_name_max_length... OK</span><br><span class="line">  Applying auth<span class="number">.0003</span>_alter_user_email_max_length... OK</span><br><span class="line">  Applying auth<span class="number">.0004</span>_alter_user_username_opts... OK</span><br><span class="line">  Applying auth<span class="number">.0005</span>_alter_user_last_login_null... OK</span><br><span class="line">  Applying auth<span class="number">.0006</span>_require_contenttypes_0002... OK</span><br><span class="line">  Applying auth<span class="number">.0007</span>_alter_validators_add_error_messages... OK</span><br><span class="line">  Applying auth<span class="number">.0008</span>_alter_user_username_max_length... OK</span><br><span class="line">  Applying auth<span class="number">.0009</span>_alter_user_last_name_max_length... OK</span><br><span class="line">  Applying booktest<span class="number">.0001</span>_initial... OK</span><br><span class="line">  Applying sessions<span class="number">.0001</span>_initial... OK       //这是对他来执行的迁移文件</span><br></pre></td></tr></table></figure></li><li><p>Django 默认使用的数据库是 sqlite3 的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- sqlite3 是一个关系型数据库</span><br><span class="line">- 也是一个小型数据库经常用在移动端，手机端</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-通过模型类操作数据表"><a href="#3-通过模型类操作数据表" class="headerlink" title="3.通过模型类操作数据表"></a>3.通过模型类操作数据表</h3><p>实例实行和例属性不是一种</p><p>通过shell操作数据表：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">python manage.py shell               <span class="comment">//进入shell命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">增加：</span><br><span class="line">from booktest.models import BookInfo        <span class="comment">//引入数据库</span></span><br><span class="line">b = BookInfo()                <span class="comment">//实例化一个数据库</span></span><br><span class="line">b.btitle = <span class="string">'天龙八部'</span>           <span class="comment">//添加名称</span></span><br><span class="line">from datetime import date        <span class="comment">//导入日期模块</span></span><br><span class="line">b.bpub_date = date(<span class="number">1990.1</span><span class="number">.1</span>)           <span class="comment">//添加日期</span></span><br><span class="line">b.save()                       <span class="comment">//保存数据</span></span><br><span class="line"></span><br><span class="line">查找：</span><br><span class="line">b2 = BookInfo.objects.get(id=<span class="number">1</span>)       <span class="comment">//通过ID查找</span></span><br><span class="line">type(b2)        <span class="comment">//返回Booktest.models.BookInfo 类型</span></span><br><span class="line">b2.btitle           <span class="comment">//返回数据</span></span><br><span class="line">b2.id                <span class="comment">//返回数据</span></span><br><span class="line">  </span><br><span class="line">修改：       <span class="comment">//修改是建立在查找的基础伤</span></span><br><span class="line">b2.bpub_date = date(<span class="number">1990.10</span><span class="number">.10</span>)       <span class="comment">//直接修改玩是不会改变</span></span><br><span class="line">b2.save()                <span class="comment">//需要save保存</span></span><br><span class="line">    </span><br><span class="line">删除：</span><br><span class="line">b2.delete()                 <span class="comment">//指定删除</span></span><br></pre></td></tr></table></figure><h2 id="八-后台管理"><a href="#八-后台管理" class="headerlink" title="八.后台管理"></a>八.后台管理</h2><ul><li><p>本地化</p><ul><li><p>语言和时区的本地化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE=&apos;zh-hans&apos;</span><br><span class="line">TIME_ZONE=&apos;Asia/Shanghai&apos;        //这里面没有背景时间，只有亚洲上海的时间</span><br></pre></td></tr></table></figure></li><li><p>修改setting.py文件</p></li></ul></li><li><p>创建管理员</p><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure></li><li><p>注册模型类</p><ul><li>在应用下的admin.py 中注册模型类</li><li>告诉Django框架根据注册的模型类来生成对表管理页面</li><li>进入admin后如果想直接显示name可以：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __str__(self):</span><br><span class="line">return self.name              //返回表的name字段</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>自定义管理页面</p><ul><li><p>自定义模型管理类。模型管理类就是告诉Django再生产管理页面上显示那些内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .<span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment">#自定义模型管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    <span class="string">'''图书模型管理类'''</span></span><br><span class="line">    list_display = [<span class="string">'id'</span>,<span class="string">'btitle'</span>,<span class="string">'bpub_date'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二个参数放模型管理类的类名 </span></span><br><span class="line">admin.site.register(models.BookInfo,BookInfoAdmin)  </span><br><span class="line">admin.site.register(models.Studeng)</span><br><span class="line">admin.site.register(models.HeroInfo)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="九-视图"><a href="#九-视图" class="headerlink" title="九.视图"></a>九.视图</h2><p>在Django中，通过浏览器去请求一个页面时，使用视图函数来处理这个请求的视图函数处理之后，要给浏览器返回页面内容。</p><h3 id="1-视图函数的使用-仅供参考"><a href="#1-视图函数的使用-仅供参考" class="headerlink" title="1.视图函数的使用(仅供参考)"></a>1.视图函数的使用(仅供参考)</h3><h4 id="定义视图函数"><a href="#定义视图函数" class="headerlink" title="- 定义视图函数"></a>- 定义视图函数</h4><ul><li><p>视图函数定义在views.py中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="comment">#Create your views here.</span></span><br><span class="line"><span class="comment">#1.定义视图函数，HttpResponse</span></span><br><span class="line"><span class="comment">#2.进行url配置，建立url地址和视图的对应关系</span></span><br><span class="line"><span class="comment">#http://127.0.0.1:8000/index</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line"><span class="comment">#进行处理 ,和M和T进行交互</span></span><br><span class="line"><span class="keyword">return</span> HttpResponse(<span class="string">'hello python'</span>)</span><br></pre></td></tr></table></figure><p>视图函数必须有一个 request ，进行处理之后，需要返回一个HttpResponse的类对象，Hello python 就是返回给浏览器的内容</p><p>####- 进行url配置</p><ol><li>所有的url配置都定义一个叫做urlpattems的列表中</li><li>每一个配置都会调用url函数第一个参数是正则表达式，第二个参数是对应的处理动作，可以写一个视图函数的名字。</li><li>和url 字符串进行正则匹配，匹配成功则执行后面响应的动作。</li><li><strong>对应的动作可以是一个视图函数的名字，也可以是包含一个应用的urls.py文件</strong></li></ol><p>url 配置的目的是让建立url和视图函数的对应关系，url配置定义在urlpatterns的列表中，每一个配置项都调用url函数。</p><h5 id="主路由"><a href="#主路由" class="headerlink" title="主路由"></a>主路由</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin             //主路由文件的admin管理员</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path,re_path,include     //include 是命名子路由用的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>,include(<span class="string">'booktest.urls'</span>))            //定义子路由 （应用名字+子路由文件）</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="子路由"><a href="#子路由" class="headerlink" title="子路由"></a>子路由</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">  from django.urls import path,re_path</span><br><span class="line">  from .import views</span><br><span class="line"></span><br><span class="line">  urlpatterns = [</span><br><span class="line">      path(&apos;index/&apos;, views.index),</span><br><span class="line">      path(&apos;&apos;,views.index),</span><br><span class="line">      url(r&apos;^index/$&apos;,views.index),</span><br><span class="line">      re_path(r&apos;index&apos;,views.index),</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li></ul><p>  url函数有两个参数，第一个是一个正则表达式，第二个是对应的处理动作。</p><p>  配置url时候有两种语法格式：</p><ol><li><p>url(正则表达式，视图函数名)</p></li><li><p>url(正则表达式，include(应用中的urls文件))</p><p>工作中配置url时，首先在项目的ulrs.py 文件中添加配置项是，并不写具体的url和视图函数之间的对应关系，而是包含具体应用的urls.py 文件，在应用的urls.py文件中写 url 和视图函数的对应关系。</p></li></ol><h3 id="2-url匹配过程-（正则）"><a href="#2-url匹配过程-（正则）" class="headerlink" title="2.url匹配过程 （正则）"></a>2.url匹配过程 （正则）</h3><p>  在项目的urls.py 文件中包含具体应用的urls.py文件，应用的urls.py文件中写url和视图函数的对应关系。</p><h2 id="十-模板"><a href="#十-模板" class="headerlink" title="十.模板"></a>十.模板</h2><p>模板不仅仅是一个HTML文件，</p><ul><li>可以在里面定义变量。</li><li>还可以写类似于编程语言的语句。</li></ul><h3 id="1-模板的使用"><a href="#1-模板的使用" class="headerlink" title="1.模板的使用"></a>1.模板的使用</h3><ol><li><p>创建模板文件夹   template</p></li><li><p>配置模板目录</p><p>项目的setting.py里面有一个TEMPLATES配置项</p><p>配置文件里面有一个常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#项目目录的绝对路径，项目不论放到哪个目录下面都能通过BASE_DIR把它的绝对路径拿到</span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br></pre></td></tr></table></figure><p>设置的时候我们就可以把我们的 BASE_DIR和tmplate拼接一下就可以了</p><p>拼接的时候要使用os.path.json(BASE_DIR,’template’)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>)],   //设置模板文件目录</span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>使用模板文件      ps:老款的</p><ul><li><p>加载模板文件</p><p>去模板目录下面获取html的内容，得到一个模板对象</p></li><li><p>定义模板上下文</p><p>向模板文件传递数据</p></li><li><p>模板渲染</p><p>得到一个标准的html内容</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader,RequestContext</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index2</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">'''使用模板'''</span></span><br><span class="line">    <span class="comment"># 1.加载模板文件，模板对象</span></span><br><span class="line">    temp = loader.get_template(<span class="string">'booktest/index2.html'</span>)</span><br><span class="line">    <span class="comment"># 2.定义模板上下文：给模板传递数据</span></span><br><span class="line">    context = RequestContext(request,&#123;&#125;)</span><br><span class="line">    <span class="comment"># 3.模板渲染：产生标准的HTML内容</span></span><br><span class="line">    res_html = temp.render(context)</span><br><span class="line">    <span class="comment"># 4.返回给浏览器</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(res_html)</span><br></pre></td></tr></table></figure><blockquote><p>定义一个方法提供模板复用           //其实这个函数封装是多余的 ,Django给我们封装了render直接使用就行了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader,RequestContext</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_render</span><span class="params">(request,template_path,context_dict)</span>:</span></span><br><span class="line">    <span class="string">'''使用模板文件'''</span></span><br><span class="line">    <span class="comment"># 1.加载模板文件，模板对象</span></span><br><span class="line">    temp = loader.get_template(template_path)</span><br><span class="line">    <span class="comment"># 2.定义模板上下文：给模板传递数据</span></span><br><span class="line">    context = RequestContext(request,context_dict)</span><br><span class="line">    <span class="comment"># 3.模板渲染：产生标准的HTML内容</span></span><br><span class="line">    res_html = temp.render(context)</span><br><span class="line">    <span class="comment"># 4.返回给浏览器</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(res_html)</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-给模板文件传递数据"><a href="#2-给模板文件传递数据" class="headerlink" title="2.给模板文件传递数据"></a>2.给模板文件传递数据</h3><ul><li><p>模板变量使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;  模板变量名 &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>for循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for i in list %&#125;</span><br><span class="line">    &#123;&#123; i &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04-拓展User模型-一对一方式拓展</title>
      <link href="/2016/06/07/114-%E6%8B%93%E5%B1%95User%E6%A8%A1%E5%9E%8B-%E4%B8%80%E5%AF%B9%E4%B8%80%E6%96%B9%E5%BC%8F%E6%8B%93%E5%B1%95/"/>
      <url>/2016/06/07/114-%E6%8B%93%E5%B1%95User%E6%A8%A1%E5%9E%8B-%E4%B8%80%E5%AF%B9%E4%B8%80%E6%96%B9%E5%BC%8F%E6%8B%93%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h4 id="2-一对一外键："><a href="#2-一对一外键：" class="headerlink" title="2.一对一外键："></a>2.一对一外键：</h4><p>如果你对用户验证方法authenticate没有其他要求，就是使用username和password即可完成。但是想要在原来模型的基础之上添加新的字段，那么可以使用一对一外键的方式。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_save</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserExtension</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name=<span class="string">'extension'</span>)</span><br><span class="line">    birthday = models.DateField(null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    school = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#监听user的变化，括号内第一个值为接收什么新号 第二个值为接收谁发出的新号</span></span><br><span class="line"><span class="meta">@receiver(post_save, sender=User)</span></span><br><span class="line"><span class="comment">#第三个值为是否是新创建的。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_user_extension</span><span class="params">(sender, instance, created, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment">#如果是第一次创建，那就创建一个userex进行绑定。</span></span><br><span class="line">    <span class="keyword">if</span> created:</span><br><span class="line">        UserExtension.objects.create(user=instance)</span><br><span class="line">    <span class="comment">#如果不是第一次创建，将进行保存</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        instance.extension.save()</span><br></pre></td></tr></table></figure><p>以上定义一个UserExtension的模型，并且让她和User模型进行一对一的绑定，以后我们新增的字段，就添加到UserExtension上。并且还写了一个接受保存模型的信号处理方法，只要是User调用了save方法，那么就会创建一个UserExtension和User进行绑定。</p><p>一对一的关系会更加的安全。</p><p>这种方法不会破坏原有的user，进行实际开发的时候建议使用这种方法。</p><p>就是比较麻烦一点。</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-拓展User模型-使用proxy模型</title>
      <link href="/2016/06/07/113-%E6%8B%93%E5%B1%95User%E6%A8%A1%E5%9E%8B-%E4%BD%BF%E7%94%A8Proxy%E6%A8%A1%E5%9E%8B/"/>
      <url>/2016/06/07/113-%E6%8B%93%E5%B1%95User%E6%A8%A1%E5%9E%8B-%E4%BD%BF%E7%94%A8Proxy%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="扩展用户模型"><a href="#扩展用户模型" class="headerlink" title="扩展用户模型"></a>扩展用户模型</h3><p><strong>在中国一般都是使用手机号邮箱等其他方式来登录，一般不适用用户名，所以需要拓展模型。</strong></p><p>Django内置的User模型虽然已经足够强大了。但是有时候还是不能满足我们的需求。比如在验证用户登录的时候，他用的是用户名作为验证，而我们有时候需要通过手机号码或者邮箱来进行验证。还有比如我们想要增加一些新的字段。那么这时候我们就需要扩展用户模型了。扩展用户模型有多种方式。这里我们来一一讨论下。</p><h4 id="1-设置Proxy模型："><a href="#1-设置Proxy模型：" class="headerlink" title="1.设置Proxy模型："></a>1.设置Proxy模型：</h4><p><strong>第一种方式使用代理，可插拔。</strong></p><p>如果你对Django提供的字段，以及验证的方法都比较满意，没有什么需要改的。但是只是需要在他原有的基础之上增加一些操作的方法。那么建议使用这种方式。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(User)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        proxy = <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_blacklist</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.objects.filter(is_active=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>在以上，我们定义了一个Person类，让他继承自User，并且在Meta中设置proxy=True，说明这个只是User的一个代理模型。他并不会影响原来User模型在数据库中表的结构。以后如果你想方便的获取所有黑名单的人，那么你就可以通过Person.get_blacklist()就可以获取到。并且User.objects.all()和Person.objects.all()其实是等价的。因为他们都是从User这个模型中获取所有的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-验证和授权系统概述</title>
      <link href="/2016/06/07/111-%E9%AA%8C%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2016/06/07/111-%E9%AA%8C%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="验证和授权概述："><a href="#验证和授权概述：" class="headerlink" title="验证和授权概述："></a>验证和授权概述：</h3><p>django有一个内置授权系统，它用来处理用户、分组、权限以及基于cookie的会话系统.</p><p>django的授权系统包括验证和授权两个部分。</p><p>验证是验证这个用户是否是他声称的人呢（比如用户名和密码验证，角色验证），授权是给与他响应的权限。</p><p>Django内置的权限系统包括以下方面：</p><ol><li>用户。</li><li>权限。</li><li>分组。</li><li>一个可以配置的密码哈希系统。</li><li>一个可以插拔的后台管理系统。<ul><li>比较灵活，想用就用不想用可以不适用。</li></ul></li></ol><h3 id="使用授权系统："><a href="#使用授权系统：" class="headerlink" title="使用授权系统："></a>使用授权系统：</h3><p>默认中创建完一个django项目后，其实就是已经集成了授权系统。</p><p>哪哪部分是跟授权系统相关的配置呢。</p><p>下面做一个简单的列表：</p><p><strong>INSTALLED_APPS:</strong></p><ol><li><p><code>django.contrib.auth</code>    包含一个核心授权框架，以及大部分的模型定义。</p></li><li><p><code>django.contrib.contenttypes</code>   : <code>Content Tpye</code> 系统，可以用来关联模型和权限。</p></li></ol><h3 id="中间件："><a href="#中间件：" class="headerlink" title="中间件："></a>中间件：</h3><ol><li><code>SessionMiddleware</code>  ：用来管理 <code>session</code>.</li><li><code>AuthenticationMiddleware</code>：用来处理当前  <code>session</code> 相关联的用户。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="comment">#包含一个核心授权框架，以及大部分的模型定义。</span></span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="comment">#content type 系统，可以用来关联模型和权限</span></span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,  <span class="comment">#用来管理session</span></span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,   <span class="comment">#用来处理和当前session相关联的用户。</span></span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-内置User模型基本使用</title>
      <link href="/2016/06/07/112-%E5%86%85%E7%BD%AEUser%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/06/07/112-%E5%86%85%E7%BD%AEUser%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="用户对象"><a href="#用户对象" class="headerlink" title="用户对象"></a>用户对象</h1><h2 id="User模型"><a href="#User模型" class="headerlink" title="User模型"></a>User模型</h2><p>User模型是这个框架的核心部分。他的完整的路径是在django.contrib.auth.models.User。以下对这个User对象做一个简单了解：</p><h3 id="字段："><a href="#字段：" class="headerlink" title="字段："></a>字段：</h3><p>内置的User模型拥有以下的字段：</p><ul><li><p>username：用户名。150个字符以内。可以包含数字和英文字符，以及_、@、+、.和-字符。不能为空，且必须唯一！</p></li><li><p>first_name：歪果仁的first_name，在30个字符以内。可以为空。</p></li><li><p>last_name：歪果仁的last_name，在150个字符以内。可以为空。</p></li><li><p>email：邮箱。可以为空。</p></li><li><p>password：密码。经过哈希过后的密码。</p></li><li><p>groups：分组。一个用户可以属于多个分组，一个分组可以拥有多个用户。groups这个字段是跟Group的一个多对多的关系。</p></li><li><p>user_permissions：权限。一个用户可以拥有多个权限，一个权限可以被多个用户所有用。和Permission属于一种多对多的关系。</p></li><li><p>is_staff：是否可以进入到admin的站点。代表是否是员工。</p></li><li><p>is_active：是否是可用的。对于一些想要删除账号的数据，我们设置这个值为False就可以了，而不是真正的从数据库中删除。</p></li><li><p>is_superuser：是否是超级管理员。如果是超级管理员，那么拥有整个网站的所有权限。</p></li><li><p>last_login：上次登录的时间。</p></li><li><p>date_joined：账号创建的时间。</p></li></ul><h3 id="Models类"><a href="#Models类" class="headerlink" title="Models类"></a>Models类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> auth</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.base_user <span class="keyword">import</span> AbstractBaseUser, BaseUserManager</span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.models <span class="keyword">import</span> ContentType</span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> PermissionDenied</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.db.models.manager <span class="keyword">import</span> EmptyManager</span><br><span class="line"><span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> gettext_lazy <span class="keyword">as</span> _</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .validators <span class="keyword">import</span> UnicodeUsernameValidator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_last_login</span><span class="params">(sender, user, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A signal receiver which updates the last_login date for</span></span><br><span class="line"><span class="string">    the user logging in.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    user.last_login = timezone.now()</span><br><span class="line">    user.save(update_fields=[<span class="string">'last_login'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermissionManager</span><span class="params">(models.Manager)</span>:</span></span><br><span class="line">    use_in_migrations = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_by_natural_key</span><span class="params">(self, codename, app_label, model)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.get(</span><br><span class="line">            codename=codename,</span><br><span class="line">            content_type=ContentType.objects.db_manager(self.db).get_by_natural_key(app_label, model),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Permission</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    The permissions system provides a way to assign permissions to specific</span></span><br><span class="line"><span class="string">    users and groups of users.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The permission system is used by the Django admin site, but may also be</span></span><br><span class="line"><span class="string">    useful in your own code. The Django admin site uses permissions as follows:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        - The "add" permission limits the user's ability to view the "add" form</span></span><br><span class="line"><span class="string">          and add an object.</span></span><br><span class="line"><span class="string">        - The "change" permission limits a user's ability to view the change</span></span><br><span class="line"><span class="string">          list, view the "change" form and change an object.</span></span><br><span class="line"><span class="string">        - The "delete" permission limits the ability to delete an object.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Permissions are set globally per type of object, not per specific object</span></span><br><span class="line"><span class="string">    instance. It is possible to say "Mary may change news stories," but it's</span></span><br><span class="line"><span class="string">    not currently possible to say "Mary may change news stories, but only the</span></span><br><span class="line"><span class="string">    ones she created herself" or "Mary may only change news stories that have a</span></span><br><span class="line"><span class="string">    certain status or publication date."</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Three basic permissions -- add, change and delete -- are automatically</span></span><br><span class="line"><span class="string">    created for each Django model.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name = models.CharField(_(<span class="string">'name'</span>), max_length=<span class="number">255</span>)</span><br><span class="line">    content_type = models.ForeignKey(</span><br><span class="line">        ContentType,</span><br><span class="line">        models.CASCADE,</span><br><span class="line">        verbose_name=_(<span class="string">'content type'</span>),</span><br><span class="line">    )</span><br><span class="line">    codename = models.CharField(_(<span class="string">'codename'</span>), max_length=<span class="number">100</span>)</span><br><span class="line">    objects = PermissionManager()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = _(<span class="string">'permission'</span>)</span><br><span class="line">        verbose_name_plural = _(<span class="string">'permissions'</span>)</span><br><span class="line">        unique_together = ((<span class="string">'content_type'</span>, <span class="string">'codename'</span>),)</span><br><span class="line">        ordering = (<span class="string">'content_type__app_label'</span>, <span class="string">'content_type__model'</span>,</span><br><span class="line">                    <span class="string">'codename'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%s | %s | %s"</span> % (</span><br><span class="line">            self.content_type.app_label,</span><br><span class="line">            self.content_type,</span><br><span class="line">            self.name,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">natural_key</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.codename,) + self.content_type.natural_key()</span><br><span class="line">    natural_key.dependencies = [<span class="string">'contenttypes.contenttype'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupManager</span><span class="params">(models.Manager)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    The manager for the auth's Group model.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    use_in_migrations = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_by_natural_key</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.get(name=name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Groups are a generic way of categorizing users to apply permissions, or</span></span><br><span class="line"><span class="string">    some other label, to those users. A user can belong to any number of</span></span><br><span class="line"><span class="string">    groups.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A user in a group automatically has all the permissions granted to that</span></span><br><span class="line"><span class="string">    group. For example, if the group 'Site editors' has the permission</span></span><br><span class="line"><span class="string">    can_edit_home_page, any user in that group will have that permission.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Beyond permissions, groups are a convenient way to categorize users to</span></span><br><span class="line"><span class="string">    apply some label, or extended functionality, to them. For example, you</span></span><br><span class="line"><span class="string">    could create a group 'Special users', and you could write code that would</span></span><br><span class="line"><span class="string">    do special things to those users -- such as giving them access to a</span></span><br><span class="line"><span class="string">    members-only portion of your site, or sending them members-only email</span></span><br><span class="line"><span class="string">    messages.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    name = models.CharField(_(<span class="string">'name'</span>), max_length=<span class="number">80</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    permissions = models.ManyToManyField(</span><br><span class="line">        Permission,</span><br><span class="line">        verbose_name=_(<span class="string">'permissions'</span>),</span><br><span class="line">        blank=<span class="literal">True</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    objects = GroupManager()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = _(<span class="string">'group'</span>)</span><br><span class="line">        verbose_name_plural = _(<span class="string">'groups'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">natural_key</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.name,)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span><span class="params">(BaseUserManager)</span>:</span></span><br><span class="line">    use_in_migrations = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_user</span><span class="params">(self, username, email, password, **extra_fields)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Create and save a user with the given username, email, and password.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> username:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'The given username must be set'</span>)</span><br><span class="line">        email = self.normalize_email(email)</span><br><span class="line">        username = self.model.normalize_username(username)</span><br><span class="line">        user = self.model(username=username, email=email, **extra_fields)</span><br><span class="line">        user.set_password(password)</span><br><span class="line">        user.save(using=self._db)</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self, username, email=None, password=None, **extra_fields)</span>:</span></span><br><span class="line">        extra_fields.setdefault(<span class="string">'is_staff'</span>, <span class="literal">False</span>)</span><br><span class="line">        extra_fields.setdefault(<span class="string">'is_superuser'</span>, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> self._create_user(username, email, password, **extra_fields)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_superuser</span><span class="params">(self, username, email, password, **extra_fields)</span>:</span></span><br><span class="line">        extra_fields.setdefault(<span class="string">'is_staff'</span>, <span class="literal">True</span>)</span><br><span class="line">        extra_fields.setdefault(<span class="string">'is_superuser'</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> extra_fields.get(<span class="string">'is_staff'</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Superuser must have is_staff=True.'</span>)</span><br><span class="line">        <span class="keyword">if</span> extra_fields.get(<span class="string">'is_superuser'</span>) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'Superuser must have is_superuser=True.'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self._create_user(username, email, password, **extra_fields)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># A few helper functions for common logic between User and AnonymousUser.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_user_get_all_permissions</span><span class="params">(user, obj)</span>:</span></span><br><span class="line">    permissions = set()</span><br><span class="line">    <span class="keyword">for</span> backend <span class="keyword">in</span> auth.get_backends():</span><br><span class="line">        <span class="keyword">if</span> hasattr(backend, <span class="string">"get_all_permissions"</span>):</span><br><span class="line">            permissions.update(backend.get_all_permissions(user, obj))</span><br><span class="line">    <span class="keyword">return</span> permissions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_user_has_perm</span><span class="params">(user, perm, obj)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A backend can raise `PermissionDenied` to short-circuit permission checking.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> backend <span class="keyword">in</span> auth.get_backends():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(backend, <span class="string">'has_perm'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> backend.has_perm(user, perm, obj):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> PermissionDenied:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_user_has_module_perms</span><span class="params">(user, app_label)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A backend can raise `PermissionDenied` to short-circuit permission checking.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> backend <span class="keyword">in</span> auth.get_backends():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(backend, <span class="string">'has_module_perms'</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> backend.has_module_perms(user, app_label):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> PermissionDenied:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PermissionsMixin</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Add the fields and methods necessary to support the Group and Permission</span></span><br><span class="line"><span class="string">    models using the ModelBackend.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    is_superuser = models.BooleanField(</span><br><span class="line">        _(<span class="string">'superuser status'</span>),</span><br><span class="line">        default=<span class="literal">False</span>,</span><br><span class="line">        help_text=_(</span><br><span class="line">            <span class="string">'Designates that this user has all permissions without '</span></span><br><span class="line">            <span class="string">'explicitly assigning them.'</span></span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    groups = models.ManyToManyField(</span><br><span class="line">        Group,</span><br><span class="line">        verbose_name=_(<span class="string">'groups'</span>),</span><br><span class="line">        blank=<span class="literal">True</span>,</span><br><span class="line">        help_text=_(</span><br><span class="line">            <span class="string">'The groups this user belongs to. A user will get all permissions '</span></span><br><span class="line">            <span class="string">'granted to each of their groups.'</span></span><br><span class="line">        ),</span><br><span class="line">        related_name=<span class="string">"user_set"</span>,</span><br><span class="line">        related_query_name=<span class="string">"user"</span>,</span><br><span class="line">    )</span><br><span class="line">    user_permissions = models.ManyToManyField(</span><br><span class="line">        Permission,</span><br><span class="line">        verbose_name=_(<span class="string">'user permissions'</span>),</span><br><span class="line">        blank=<span class="literal">True</span>,</span><br><span class="line">        help_text=_(<span class="string">'Specific permissions for this user.'</span>),</span><br><span class="line">        related_name=<span class="string">"user_set"</span>,</span><br><span class="line">        related_query_name=<span class="string">"user"</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_group_permissions</span><span class="params">(self, obj=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return a list of permission strings that this user has through their</span></span><br><span class="line"><span class="string">        groups. Query all available auth backends. If an object is passed in,</span></span><br><span class="line"><span class="string">        return only permissions matching this object.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        permissions = set()</span><br><span class="line">        <span class="keyword">for</span> backend <span class="keyword">in</span> auth.get_backends():</span><br><span class="line">            <span class="keyword">if</span> hasattr(backend, <span class="string">"get_group_permissions"</span>):</span><br><span class="line">                permissions.update(backend.get_group_permissions(self, obj))</span><br><span class="line">        <span class="keyword">return</span> permissions</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_all_permissions</span><span class="params">(self, obj=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> _user_get_all_permissions(self, obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perm</span><span class="params">(self, perm, obj=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return True if the user has the specified permission. Query all</span></span><br><span class="line"><span class="string">        available auth backends, but return immediately if any backend returns</span></span><br><span class="line"><span class="string">        True. Thus, a user who has permission from a single auth backend is</span></span><br><span class="line"><span class="string">        assumed to have permission in general. If an object is provided, check</span></span><br><span class="line"><span class="string">        permissions for that object.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># Active superusers have all permissions.</span></span><br><span class="line">        <span class="keyword">if</span> self.is_active <span class="keyword">and</span> self.is_superuser:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Otherwise we need to check the backends.</span></span><br><span class="line">        <span class="keyword">return</span> _user_has_perm(self, perm, obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perms</span><span class="params">(self, perm_list, obj=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return True if the user has each of the specified permissions. If</span></span><br><span class="line"><span class="string">        object is passed, check if the user has all required perms for it.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> all(self.has_perm(perm, obj) <span class="keyword">for</span> perm <span class="keyword">in</span> perm_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_module_perms</span><span class="params">(self, app_label)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return True if the user has any permissions in the given app label.</span></span><br><span class="line"><span class="string">        Use simlar logic as has_perm(), above.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># Active superusers have all permissions.</span></span><br><span class="line">        <span class="keyword">if</span> self.is_active <span class="keyword">and</span> self.is_superuser:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> _user_has_module_perms(self, app_label)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractUser</span><span class="params">(AbstractBaseUser, PermissionsMixin)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    An abstract base class implementing a fully featured User model with</span></span><br><span class="line"><span class="string">    admin-compliant permissions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Username and password are required. Other fields are optional.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#用户名</span></span><br><span class="line">    username_validator = UnicodeUsernameValidator()</span><br><span class="line"><span class="comment">#设置为唯一，并且以后验证用户名和密码是否正确的时候就是用的username</span></span><br><span class="line">    username = models.CharField(</span><br><span class="line">        _(<span class="string">'username'</span>),</span><br><span class="line">        max_length=<span class="number">150</span>,</span><br><span class="line">        unique=<span class="literal">True</span>,</span><br><span class="line">        help_text=_(<span class="string">'Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.'</span>),</span><br><span class="line">        validators=[username_validator],</span><br><span class="line">        error_messages=&#123;</span><br><span class="line">            <span class="string">'unique'</span>: _(<span class="string">"A user with that username already exists."</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#姓</span></span><br><span class="line">    first_name = models.CharField(_(<span class="string">'first name'</span>), max_length=<span class="number">30</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#名</span></span><br><span class="line">    last_name = models.CharField(_(<span class="string">'last name'</span>), max_length=<span class="number">150</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    email = models.EmailField(_(<span class="string">'email address'</span>), blank=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#是否是员工</span></span><br><span class="line">    is_staff = models.BooleanField(</span><br><span class="line">        _(<span class="string">'staff status'</span>),</span><br><span class="line">        default=<span class="literal">False</span>,</span><br><span class="line">        help_text=_(<span class="string">'Designates whether the user can log into this admin site.'</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#是否是可用</span></span><br><span class="line">    is_active = models.BooleanField(</span><br><span class="line">        _(<span class="string">'active'</span>),</span><br><span class="line">        default=<span class="literal">True</span>,</span><br><span class="line">        help_text=_(</span><br><span class="line">            <span class="string">'Designates whether this user should be treated as active. '</span></span><br><span class="line">            <span class="string">'Unselect this instead of deleting accounts.'</span></span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">#创建时间，什么时候加入的</span></span><br><span class="line">    date_joined = models.DateTimeField(_(<span class="string">'date joined'</span>), default=timezone.now)</span><br><span class="line"></span><br><span class="line">    objects = UserManager()</span><br><span class="line"></span><br><span class="line">    EMAIL_FIELD = <span class="string">'email'</span></span><br><span class="line">    USERNAME_FIELD = <span class="string">'username'</span></span><br><span class="line">    REQUIRED_FIELDS = [<span class="string">'email'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = _(<span class="string">'user'</span>)</span><br><span class="line">        verbose_name_plural = _(<span class="string">'users'</span>)</span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().clean()</span><br><span class="line">        self.email = self.__class__.objects.normalize_email(self.email)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_full_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return the first_name plus the last_name, with a space in between.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        full_name = <span class="string">'%s %s'</span> % (self.first_name, self.last_name)</span><br><span class="line">        <span class="keyword">return</span> full_name.strip()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_short_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return the short name for the user."""</span></span><br><span class="line">        <span class="keyword">return</span> self.first_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">email_user</span><span class="params">(self, subject, message, from_email=None, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Send an email to this user."""</span></span><br><span class="line">        send_mail(subject, message, from_email, [self.email], **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractUser)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Users within the Django authentication system are represented by this</span></span><br><span class="line"><span class="string">    model.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Username, password and email are required. Other fields are optional.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(AbstractUser.Meta)</span>:</span></span><br><span class="line">        swappable = <span class="string">'AUTH_USER_MODEL'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousUser</span>:</span></span><br><span class="line">    id = <span class="literal">None</span></span><br><span class="line">    pk = <span class="literal">None</span></span><br><span class="line">    username = <span class="string">''</span></span><br><span class="line">    is_staff = <span class="literal">False</span></span><br><span class="line">    is_active = <span class="literal">False</span></span><br><span class="line">    is_superuser = <span class="literal">False</span></span><br><span class="line">    _groups = EmptyManager(Group)</span><br><span class="line">    _user_permissions = EmptyManager(Permission)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'AnonymousUser'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> isinstance(other, self.__class__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># instances always return the same hash value</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Django doesn't provide a DB representation for AnonymousUser."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Django doesn't provide a DB representation for AnonymousUser."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_password</span><span class="params">(self, raw_password)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Django doesn't provide a DB representation for AnonymousUser."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_password</span><span class="params">(self, raw_password)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Django doesn't provide a DB representation for AnonymousUser."</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groups</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._groups</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">user_permissions</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._user_permissions</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_group_permissions</span><span class="params">(self, obj=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> set()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_all_permissions</span><span class="params">(self, obj=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> _user_get_all_permissions(self, obj=obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perm</span><span class="params">(self, perm, obj=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> _user_has_perm(self, perm, obj=obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_perms</span><span class="params">(self, perm_list, obj=None)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> perm <span class="keyword">in</span> perm_list:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.has_perm(perm, obj):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_module_perms</span><span class="params">(self, module)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> _user_has_module_perms(self, module)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_anonymous</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authenticated</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_username</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br></pre></td></tr></table></figure><h2 id="User模型的基本用法"><a href="#User模型的基本用法" class="headerlink" title="User模型的基本用法"></a>User模型的基本用法</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p>通过create_user方法可以快速的创建用户。这个方法必须要传递username、email、password。</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line">user = User.objects.create_user(<span class="string">'zhiliao'</span>,<span class="string">'hynever@zhiliao.com'</span>,<span class="string">'111111'</span>)</span><br><span class="line"><span class="comment"># 此时user对象已经存储到数据库中了。当然你还可以继续使用user对象进行一些修改</span></span><br><span class="line">user.last_name = <span class="string">'abc'</span></span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure><h3 id="创建超级用户"><a href="#创建超级用户" class="headerlink" title="创建超级用户"></a>创建超级用户</h3><p>创建超级用户有两种方式。第一种是使用代码的方式。用代码创建超级用户跟创建普通用户非常的类似，只不过是使用create_superuser。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line">User.objects.create_superuser(<span class="string">'admin'</span>,<span class="string">'admin@163.com'</span>,<span class="string">'111111'</span>)</span><br></pre></td></tr></table></figure><p>也可以通过命令行的方式。命令如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><p>后面就会提示你输入用户名、邮箱以及密码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#需要输入的命令</span></span><br><span class="line">C:\Users\Administrator\Desktop\Django项目\Students_comm&gt;python manage.py createsuperuser</span><br><span class="line">Username (leave blank to use <span class="string">'administrator'</span>):      <span class="comment">#用户名</span></span><br><span class="line">Email address:                 <span class="comment">#emali 可以为空</span></span><br><span class="line">Password:                 <span class="comment">#密码：不可以纯数字，低于6位数</span></span><br><span class="line">Password (again):          <span class="comment">#确认密码</span></span><br><span class="line">Superuser created successfully.          <span class="comment">#提示超级用户创建成功</span></span><br></pre></td></tr></table></figure><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>因为密码是需要经过加密后才能存储进去的。所以如果想要修改密码，不能直接修改password字段，而需要通过调用set_password来达到修改密码的目的。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line">user = User.objects.get(pk=<span class="number">1</span>)</span><br><span class="line">user.set_password(<span class="string">'新的密码'</span>)</span><br><span class="line">user.save()</span><br></pre></td></tr></table></figure><h3 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h3><p>Django的验证系统已经帮我们实现了登录验证的功能。通过<strong>django.contrib.auth.authenticate</strong>即可实现。这个方法只能通过username和password来进行验证。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate</span><br><span class="line">user = authenticate(username=<span class="string">'zhiliao'</span>, password=<span class="string">'111111'</span>)</span><br><span class="line"><span class="comment"># 如果验证通过了，那么就会返回一个user对象。</span></span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 执行验证通过后的代码</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 执行验证没有通过的代码。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05-拓展User模型-继承AbstarctUser</title>
      <link href="/2016/06/07/115-%E6%8B%93%E5%B1%95User%E6%A8%A1%E5%9E%8B-%E7%BB%A7%E6%89%BFAbstractUser/"/>
      <url>/2016/06/07/115-%E6%8B%93%E5%B1%95User%E6%A8%A1%E5%9E%8B-%E7%BB%A7%E6%89%BFAbstractUser/</url>
      
        <content type="html"><![CDATA[<h4 id="3-继承自AbstractUser："><a href="#3-继承自AbstractUser：" class="headerlink" title="3.继承自AbstractUser："></a>3.继承自AbstractUser：</h4><p>对于authenticate不满意，并且不想要修改原来User对象上的一些字段，但是想要增加一些字段，那么这时候可以直接继承自django.contrib.auth.models.AbstractUser，其实这个类也是django.contrib.auth.models.User的父类。比如我们想要在原来User模型的基础之上添加一个telephone和school字段。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractUser)</span>:</span></span><br><span class="line">    telephone = models.CharField(max_length=<span class="number">11</span>,unique=<span class="literal">True</span>)</span><br><span class="line">    school = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定telephone作为USERNAME_FIELD，以后使用authenticate</span></span><br><span class="line">    <span class="comment"># 函数验证的时候，就可以根据telephone来验证</span></span><br><span class="line">    <span class="comment"># 而不是原来的username</span></span><br><span class="line">    USERNAME_FIELD = <span class="string">'telephone'</span></span><br><span class="line">    REQUIRED_FIELDS = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新定义Manager对象，在创建user的时候使用telephone和</span></span><br><span class="line">    <span class="comment"># password，而不是使用username和password</span></span><br><span class="line">    objects = UserManager()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span><span class="params">(BaseUserManager)</span>:</span></span><br><span class="line">    use_in_migrations = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_user</span><span class="params">(self,telephone,password,**extra_fields)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> telephone:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"请填入手机号码！"</span>)</span><br><span class="line">        user = self.model(telephone=telephone,*extra_fields)</span><br><span class="line">        user.set_password(password)</span><br><span class="line">        user.save()</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self,telephone,password,**extra_fields)</span>:</span></span><br><span class="line">        extra_fields.setdefault(<span class="string">'is_superuser'</span>,<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> self._create_user(telephone,password)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_superuser</span><span class="params">(self,telephone,password,**extra_fields)</span>:</span></span><br><span class="line">        extra_fields[<span class="string">'is_superuser'</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self._create_user(telephone,password)</span><br></pre></td></tr></table></figure><p>然后再在<code>settings</code>中配置好<code>AUTH_USER_MODEL=youapp.User</code>。</p><p><strong>这种方式因为破坏了原来User模型的表结构，所以必须要在第一次</strong><code>migrate</code><strong>前就先定义好。</strong></p><h4 id="4-继承自AbstractBaseUser模型："><a href="#4-继承自AbstractBaseUser模型：" class="headerlink" title="4.继承自AbstractBaseUser模型："></a>4.继承自AbstractBaseUser模型：</h4><p>如果你想修改默认的验证方式，并且对于原来<code>User</code>模型上的一些字段不想要，那么可以自定义一个模型，然后继承自<code>AbstractBaseUser</code>，再添加你想要的字段。这种方式会比较麻烦，最好是确定自己对<code>Django</code>比较了解才推荐使用。步骤如下：</p><h5 id="1，创建模型。示例代码如下："><a href="#1，创建模型。示例代码如下：" class="headerlink" title="1，创建模型。示例代码如下："></a><strong>1，创建模型。示例代码如下：</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractBaseUser,PermissionsMixin)</span>:</span></span><br><span class="line">     email = models.EmailField(unique=<span class="literal">False</span>)</span><br><span class="line">     username = models.CharField(max_length=<span class="number">150</span>)</span><br><span class="line">     telephone = models.CharField(max_length=<span class="number">11</span>,unique=<span class="literal">True</span>)</span><br><span class="line">     is_active = models.BooleanField(default=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">     USERNAME_FIELD = <span class="string">'telephone'</span></span><br><span class="line">     REQUIRED_FIELDS = []</span><br><span class="line"> </span><br><span class="line">     objects = UserManager()</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">get_full_name</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">return</span> self.username</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">get_short_name</span><span class="params">(self)</span>:</span></span><br><span class="line">         <span class="keyword">return</span> self.username</span><br></pre></td></tr></table></figure><p>其中<code>password</code>和<code>last_login</code>是在<code>AbstractBaseUser</code>中已经添加好了的，我们直接继承就可以了。然后我们再添加我们想要的字段。比如<code>email</code>、<code>username</code>、<code>telephone</code>等。这样就可以实现自己想要的字段了。但是因为我们重写了<code>User</code>，所以应该尽可能的模拟<code>User</code>模型：</p><ul><li><code>USERNAME_FIELD</code>：用来描述<code>User</code>模型名字字段的字符串，作为唯一的标识。如果没有修改，那么会使用<code>USERNAME</code>来作为唯一字段。</li><li><code>REQUIRED_FIELDS</code>：一个字段名列表，用于当通过<code>createsuperuser</code>管理命令创建一个用户时的提示。</li><li><code>is_active</code>：一个布尔值，用于标识用户当前是否可用。</li><li><code>get_full_name()</code>：获取完整的名字。</li><li><code>get_short_name()</code>：一个比较简短的用户名。</li></ul><h5 id="2，重新定义UserManager："><a href="#2，重新定义UserManager：" class="headerlink" title="2，重新定义UserManager："></a><strong>2，重新定义UserManager：</strong></h5><p>我们还需要定义自己的UserManager，因为默认的UserManager在创建用户的时候使用的是username和password，那么我们要替换成telephone。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span><span class="params">(BaseUserManager)</span>:</span></span><br><span class="line">    use_in_migrations = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_user</span><span class="params">(self,telephone,password,**extra_fields)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> telephone:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"请填入手机号码！"</span>)</span><br><span class="line">        user = self.model(telephone=telephone,*extra_fields)</span><br><span class="line">        user.set_password(password)</span><br><span class="line">        user.save()</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self,telephone,password,**extra_fields)</span>:</span></span><br><span class="line">        extra_fields.setdefault(<span class="string">'is_superuser'</span>,<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> self._create_user(telephone,password)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_superuser</span><span class="params">(self,telephone,password,**extra_fields)</span>:</span></span><br><span class="line">        extra_fields[<span class="string">'is_superuser'</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self._create_user(telephone,password)</span><br></pre></td></tr></table></figure><h5 id="3-设置Setting"><a href="#3-设置Setting" class="headerlink" title="3.设置Setting"></a>3.设置Setting</h5><p>在创建了新的<code>User</code>模型后，还需要在<code>settings</code>中配置好。配置<code>AUTH_USER_MODEL=&#39;appname.User&#39;</code>。</p><h5 id="4-使用自定义模型"><a href="#4-使用自定义模型" class="headerlink" title="4.使用自定义模型"></a>4.使用自定义模型</h5><p>如何使用这个自定义的模型：比如以后我们有一个<code>Article</code>模型，需要通过外键引用这个<code>User</code>模型，那么可以通过以下两种方式引用。<br>第一种就是直接将<code>User</code>导入到当前文件中。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> myauth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    author = models.ForeignKey(User, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>这种方式是可以行得通的。但是为了更好的使用性，建议还是将<code>User</code>抽象出来，使用<code>settings.AUTH_USER_MODEL</code>来表示。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><hr><p><strong>这种方式因为破坏了原来User模型的表结构，所以必须要在第一次</strong><code>migrate</code><strong>前就先定义好。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08-权限-基于角色的权限管理系统</title>
      <link href="/2016/06/07/118-%E6%9D%83%E9%99%90-%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2016/06/07/118-%E6%9D%83%E9%99%90-%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E6%9D%83%E9%99%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>基于角色的权限系统</strong></p><p>​       现在各大系统都采用的是基于角色的权限控制，这里就涉及到三个东西：用户、角色、资源（权限），在Django中就是：用户、用户组、权限。用户和角色的关系一般为多对多，角色和资源的关系也为多对多，如下图（此图来源于互联网）</p><p><img src="img%5CRBAC%E6%9D%83%E9%99%90%E6%A8%A1%E5%9E%8B.jpeg" alt></p><p>​       这样设计有一个好处，就是在系统越来越大的时候如果给每个用户逐一赋予权限非常麻烦和繁琐，只需要给角色赋予相应的权限用户赋予他对应的角色即可，如果有新的需求只需要添加有相应权限的角色即可。</p><p><strong>Django权限机制的实现</strong></p><p><strong>1、不依赖于Django中的权限模型</strong></p><p>​       设计三个实体类User、Role、Resource分别对应上面提出的用户、角色、资源，User和Resource之间为多对多的关系，Role和Resource之间为多对多的关系。User中封装的是用户的信息如用户名密码等，Resource可以封装权限标识（后面再进行分析）也可以封装允许访问的URL地址。</p><p>​       编写装饰器对视图处理方法进行拦截</p><ul><li><strong>资源封装URL</strong></li></ul><p>​            在装饰器中获取当前访问的URL，取出当前用户（从Session中取，前题是在登录的时候需要把用户信息放去Session中去），迭代判断用户的所有角色绑定的资源中的URL，如果存在与当前访问URL相同的地址则放行，否则则跳转到无权限的页面。</p><p>​            <strong>弊端：</strong>如果URL发生了变动需要修改资源（权限）</p><ul><li><strong>资源封装权限标识</strong></li></ul><p>​            在装饰器标示在视图处理方法上时传入权限标识参数（如：@auth(“user:add”)），在装饰器中也是从Session中获取用户，迭代用户的所有角色绑定的资源中的权限标识，如果与传入装饰器中的权限标识相同则放行，否则跳转到无权限的页面。</p><p>​            <strong>好处：</strong>如果URL发生了变动无需修改资源（权限），Django内部的权限系统就是采用的这种方式，Java目前越来越流行的权限控制框架Shiro也是采用的这种方式</p><p><strong>2、依赖于Django中的权限模型</strong></p><p>​         Django用<strong>User、Group、Permission</strong>来表示上面的用户、角色、资源（权限），在Django中不管你是否使用其自带的权限控制只要你继承了他的模型类（models.Model）会默认在auth_permission表中插入三个权限信息（以Book为例，会插入如下三个权限信息：add_book、change_book、delete_book，分别代表了添加、修改、删除三个权限），如果需要更多的权限信息可以在定义实体的时候如下定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Book(models.Model):</span><br><span class="line">    name = models.CharField()</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        permissions = (</span><br><span class="line">            (&apos;自定义的权限标识&apos;, &apos;权限说明信息&apos;),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>​        每个permission都是<strong>django.contrib.auth.Permission</strong>类型的实例，该类型包含三个字段name, codename 和 content_type，其中 content_type反应了permission属于哪个model（如上就是Book），codename就是权限标识，代码逻辑中检查权限时要用， name是permission的描述显示的时候会用到。</p><p>​        权限检测装饰器：<strong>request.user</strong>封装了当前登录系统的用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth.decorators import permission_required</span><br><span class="line"></span><br><span class="line">@permission_required(&apos;应用名.权限标识&apos;)</span><br><span class="line">def view(request):</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>​       在模版中使用：模版中使用全局变量<strong>perms</strong>存储当前用户的所有权限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> perms.应用名.权限标识 %&#125;</span><br><span class="line">    &lt;!-- 这里是有权限才显示的内容 --&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>06-拓展User模型-继承AbstractBaseUser</title>
      <link href="/2016/06/07/116-%E6%8B%93%E5%B1%95User%E6%A8%A1%E5%9E%8B-%E7%BB%A7%E6%89%BFAbstractBaseUser%E6%A8%A1%E5%9E%8B/"/>
      <url>/2016/06/07/116-%E6%8B%93%E5%B1%95User%E6%A8%A1%E5%9E%8B-%E7%BB%A7%E6%89%BFAbstractBaseUser%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="4-继承自AbstractBaseUser模型："><a href="#4-继承自AbstractBaseUser模型：" class="headerlink" title="4. 继承自AbstractBaseUser模型："></a>4. 继承自<code>AbstractBaseUser</code>模型：</h3><p>如果你想修改默认的验证方式，并且对于原来<code>User</code>模型上的一些字段不想要，那么可以自定义一个模型，然后继承自<code>AbstractBaseUser</code>，再添加你想要的字段。这种方式会比较麻烦，最好是确定自己对<code>Django</code>比较了解才推荐使用。步骤如下：</p><h4 id="创建模型。示例代码如下："><a href="#创建模型。示例代码如下：" class="headerlink" title="创建模型。示例代码如下："></a>创建模型。示例代码如下：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractBaseUser,PermissionsMixin)</span>:</span></span><br><span class="line">    email = models.EmailField(unique=<span class="literal">False</span>)</span><br><span class="line">    username = models.CharField(max_length=<span class="number">150</span>)</span><br><span class="line">    telephone = models.CharField(max_length=<span class="number">11</span>,unique=<span class="literal">True</span>)</span><br><span class="line">    is_active = models.BooleanField(default=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    USERNAME_FIELD = <span class="string">'telephone'</span></span><br><span class="line">    REQUIRED_FIELDS = []</span><br><span class="line"></span><br><span class="line">    objects = UserManager()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_full_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_short_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br></pre></td></tr></table></figure><p>其中<code>password</code>和<code>last_login</code>是在<code>AbstractBaseUser</code>中已经添加好了的，我们直接继承就可以了。然后我们再添加我们想要的字段。比如<code>email</code>、<code>username</code>、<code>telephone</code>等。这样就可以实现自己想要的字段了。但是因为我们重写了<code>User</code>，所以应该尽可能的模拟<code>User</code>模型：</p><ul><li><code>USERNAME_FIELD</code>：用来描述<code>User</code>模型名字字段的字符串，作为唯一的标识。如果没有修改，那么会使用<code>USERNAME</code>来作为唯一字段。</li><li><code>REQUIRED_FIELDS</code>：一个字段名列表，用于当通过<code>createsuperuser</code>管理命令创建一个用户时的提示。</li><li><code>is_active</code>：一个布尔值，用于标识用户当前是否可用。</li><li><code>get_full_name()</code>：获取完整的名字。</li><li><code>get_short_name()</code>：一个比较简短的用户名。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">This module allows importing AbstractBaseUser even when django.contrib.auth is</span></span><br><span class="line"><span class="string">not in INSTALLED_APPS.</span></span><br><span class="line"><span class="string">这个模块允许导入AbstractBaseUser，即使在django.contrib中也是如此。身份验证是</span></span><br><span class="line"><span class="string">INSTALLED_APPS。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> password_validation</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> (</span><br><span class="line">    check_password, is_password_usable, make_password,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.utils.crypto <span class="keyword">import</span> get_random_string, salted_hmac</span><br><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> gettext_lazy <span class="keyword">as</span> _</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseUserManager</span><span class="params">(models.Manager)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalize_email</span><span class="params">(cls, email)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Normalize the email address by lowercasing the domain part of it.</span></span><br><span class="line"><span class="string">        将电子邮件地址正常化，将其域部分小写。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        email = email <span class="keyword">or</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            email_name, domain_part = email.strip().rsplit(<span class="string">'@'</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            email = email_name + <span class="string">'@'</span> + domain_part.lower()</span><br><span class="line">        <span class="keyword">return</span> email</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_random_password</span><span class="params">(self, length=<span class="number">10</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             allowed_chars=<span class="string">'abcdefghjkmnpqrstuvwxyz'</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="string">'ABCDEFGHJKLMNPQRSTUVWXYZ'</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="string">'23456789'</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Generate a random password with the given length and given</span></span><br><span class="line"><span class="string">        allowed_chars. The default value of allowed_chars does not have "I" or</span></span><br><span class="line"><span class="string">        "O" or letters and digits that look similar -- just to avoid confusion.</span></span><br><span class="line"><span class="string">        生成具有给定长度和给定值的随机密码allowed_chars。</span></span><br><span class="line"><span class="string">        allowed_chars的默认值没有“I”或“O”或看起来相似的字母和数字——只是为了避免混淆。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> get_random_string(length, allowed_chars)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_by_natural_key</span><span class="params">(self, username)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.get(**&#123;self.model.USERNAME_FIELD: username&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractBaseUser</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    password = models.CharField(_(<span class="string">'password'</span>), max_length=<span class="number">128</span>)</span><br><span class="line">    <span class="comment">#Django把password做过特殊的加密处理。</span></span><br><span class="line">    last_login = models.DateTimeField(_(<span class="string">'last login'</span>), blank=<span class="literal">True</span>, null=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#last_login 记录上次的登录时间</span></span><br><span class="line">    is_active = <span class="literal">True</span></span><br><span class="line"><span class="comment">#是否是活跃用户 默认为True</span></span><br><span class="line">    REQUIRED_FIELDS = []</span><br><span class="line">    <span class="comment">#一个字段名列表，用于当通过createsuperuser管理命令创建一个用户时的提示。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Stores the raw password if set_password() is called so that it can</span></span><br><span class="line">    <span class="comment">#如果调用set_password()，则存储原始密码，以便它可以</span></span><br><span class="line">    <span class="comment"># be passed to password_changed() after the model is saved.</span></span><br><span class="line">    <span class="comment">#保存模型后传递给password_changed()。</span></span><br><span class="line">    _password = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_username</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"Return the identifying username for this User"</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self, self.USERNAME_FIELD)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.get_username()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clean</span><span class="params">(self)</span>:</span></span><br><span class="line">        setattr(self, self.USERNAME_FIELD, self.normalize_username(self.get_username()))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super().save(*args, **kwargs)</span><br><span class="line">        <span class="keyword">if</span> self._password <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            password_validation.password_changed(self._password, self)</span><br><span class="line">            self._password = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">natural_key</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.get_username(),)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_anonymous</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Always return False. This is a way of comparing User objects to</span></span><br><span class="line"><span class="string">        anonymous users.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authenticated</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Always return True. This is a way to tell if the user has been</span></span><br><span class="line"><span class="string">        authenticated in templates.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_password</span><span class="params">(self, raw_password)</span>:</span></span><br><span class="line">        self.password = make_password(raw_password)</span><br><span class="line">        self._password = raw_password</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_password</span><span class="params">(self, raw_password)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return a boolean of whether the raw_password was correct. Handles</span></span><br><span class="line"><span class="string">        hashing formats behind the scenes.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">(raw_password)</span>:</span></span><br><span class="line">            self.set_password(raw_password)</span><br><span class="line">            <span class="comment"># Password hash upgrades shouldn't be considered password changes.</span></span><br><span class="line">            self._password = <span class="literal">None</span></span><br><span class="line">            self.save(update_fields=[<span class="string">"password"</span>])</span><br><span class="line">        <span class="keyword">return</span> check_password(raw_password, self.password, setter)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_unusable_password</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Set a value that will never be a valid hash</span></span><br><span class="line">        self.password = make_password(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_usable_password</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return False if set_unusable_password() has been called for this user.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> is_password_usable(self.password)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_session_auth_hash</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Return an HMAC of the password field.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        key_salt = <span class="string">"django.contrib.auth.models.AbstractBaseUser.get_session_auth_hash"</span></span><br><span class="line">        <span class="keyword">return</span> salted_hmac(key_salt, self.password).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_email_field_name</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cls.EMAIL_FIELD</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'email'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalize_username</span><span class="params">(cls, username)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> unicodedata.normalize(<span class="string">'NFKC'</span>, username) <span class="keyword">if</span> isinstance(username, str) <span class="keyword">else</span> username</span><br></pre></td></tr></table></figure><h4 id="重新定义UserManager："><a href="#重新定义UserManager：" class="headerlink" title="重新定义UserManager："></a>重新定义<code>UserManager</code>：</h4><p>我们还需要定义自己的<code>UserManager</code>，因为默认的<code>UserManager</code>在创建用户的时候使用的是<code>username</code>和<code>password</code>，那么我们要替换成<code>telephone</code>。</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManager</span><span class="params">(BaseUserManager)</span>:</span></span><br><span class="line">    use_in_migrations = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create_user</span><span class="params">(self,telephone,password,**extra_fields)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> telephone:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"请填入手机号码！"</span>)</span><br><span class="line">        user = self.model(telephone=telephone,*extra_fields)</span><br><span class="line">        user.set_password(password)</span><br><span class="line">        user.save()</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_user</span><span class="params">(self,telephone,password,**extra_fields)</span>:</span></span><br><span class="line">        extra_fields.setdefault(<span class="string">'is_superuser'</span>,<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> self._create_user(telephone,password)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_superuser</span><span class="params">(self,telephone,password,**extra_fields)</span>:</span></span><br><span class="line">        extra_fields[<span class="string">'is_superuser'</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self._create_user(telephone,password)</span><br></pre></td></tr></table></figure><h4 id="配置settings-py"><a href="#配置settings-py" class="headerlink" title="配置settings.py"></a>配置<code>settings.py</code></h4><p>在创建了新的<code>User</code>模型后，还需要在<code>settings</code>中配置好。配置<code>AUTH_USER_MODEL=&#39;appname.User&#39;</code>。</p><h4 id="使用自定义模型"><a href="#使用自定义模型" class="headerlink" title="使用自定义模型"></a>使用自定义模型</h4><p>如何使用这个自定义的模型：比如以后我们有一个<code>Article</code>模型，需要通过外键引用这个<code>User</code>模型，那么可以通过以下两种方式引用。<br>第一种就是直接将<code>User</code>导入到当前文件中。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> myauth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    author = models.ForeignKey(User, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><p>这种方式是可以行得通的。但是为了更好的使用性，建议还是将<code>User</code>抽象出来，使用<code>settings.AUTH_USER_MODEL</code>来表示。示例代码如下：</p><p><strong>这种方式因为破坏了原来User模型的表结构，所以必须要在第一次</strong><code>migrate</code><strong>前就先定义好。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>07-登录、登出及登录限制</title>
      <link href="/2016/06/07/117-%E7%99%BB%E5%BD%95%E3%80%81%E7%99%BB%E5%87%BA%E5%8F%8A%E7%99%BB%E5%BD%95%E9%99%90%E5%88%B6/"/>
      <url>/2016/06/07/117-%E7%99%BB%E5%BD%95%E3%80%81%E7%99%BB%E5%87%BA%E5%8F%8A%E7%99%BB%E5%BD%95%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="权限和分组"><a href="#权限和分组" class="headerlink" title="权限和分组"></a>权限和分组</h1><h2 id="登录、注销和登录限制："><a href="#登录、注销和登录限制：" class="headerlink" title="登录、注销和登录限制："></a>登录、注销和登录限制：</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>在使用<code>authenticate</code>进行验证后，如果验证通过了。那么会返回一个<code>user</code>对象，拿到<code>user</code>对象后，可以使用<code>django.contrib.auth.login</code>进行登录。示例代码如下：</p><ul><li>切记：这里不可以定义视图名字为login。</li><li>可以使用其他的名字。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user = authenticate(username=username, password=password)</span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> user.is_active:</span><br><span class="line">      <span class="comment">#login登录之后自动把用户信息存入session</span></span><br><span class="line">        login(request, user)</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate, login, logout</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,redirect</span><br><span class="line"><span class="keyword">from</span> url_app.forms <span class="keyword">import</span> LoginForm</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录页面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_login</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method  == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'login.html'</span>,locals())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        form = LoginForm(request.POST)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            telephone = form.cleaned_data.get(<span class="string">'telephone'</span>)</span><br><span class="line">            password = form.cleaned_data.get(<span class="string">'password'</span>)</span><br><span class="line">            remember = form.cleaned_data.get(<span class="string">'remember'</span>)</span><br><span class="line">            user = authenticate(request,username=telephone,password=password)</span><br><span class="line">            <span class="comment">#判断user是否存在和是否是活跃状态。</span></span><br><span class="line">            <span class="keyword">if</span> user <span class="keyword">and</span> user.is_active:</span><br><span class="line">              <span class="comment">#如果是将 保存session</span></span><br><span class="line">                login(request,user)</span><br><span class="line">                <span class="keyword">if</span> remember:</span><br><span class="line">                  <span class="comment">#如果如果过用户选择记住密码则将session状态为永久，最高存储15天</span></span><br><span class="line">                    request.session.set_expiry(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                  <span class="comment">#如果没有选记住密码在用户关闭之后清空session</span></span><br><span class="line">                    request.session.set_expiry(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">'登录成功！'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">'手机号或者密码错误'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(my_login)</span><br></pre></td></tr></table></figure><h3 id="注销："><a href="#注销：" class="headerlink" title="注销："></a>注销：</h3><p>注销，或者说退出登录。我们可以通过<code>django.contrib.auth.logout</code>来实现。他会清理掉这个用户的<code>session</code>数据。</p><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_logout</span><span class="params">(request)</span>:</span></span><br><span class="line">  <span class="comment">#在用户登录状态具有清空当前session的作用。</span></span><br><span class="line">    logout(request)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-权限-添加权限的两种方式</title>
      <link href="/2016/06/07/119-%E6%9D%83%E9%99%90-%E6%B7%BB%E5%8A%A0%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2016/06/07/119-%E6%9D%83%E9%99%90-%E6%B7%BB%E5%8A%A0%E6%9D%83%E9%99%90%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="权限："><a href="#权限：" class="headerlink" title="权限："></a>权限：</h2><p><code>Django</code>中内置了权限的功能。他的权限都是针对表或者说是模型级别的。比如对某个模型上的数据是否可以进行增删改查操作。他不能针对数据级别的，比如对某个表中的某条数据能否进行增删改查操作（如果要实现数据级别的，考虑使用<code>django-guardian</code>）。创建完一个模型后，针对这个模型默认就有三种权限，分别是增/删/改/。可以在执行完<code>migrate</code>命令后，查看数据库中的<code>auth_permission</code>表中的所有权限。</p><p><img src="img%5C%E6%9D%83%E9%99%90.png" alt></p><p>其中的<code>codename</code>表示的是权限的名字。<code>name</code>表示的是这个权限的作用。</p><h3 id="通过定义模型添加权限："><a href="#通过定义模型添加权限：" class="headerlink" title="通过定义模型添加权限："></a>通过定义模型添加权限：</h3><p>如果我们想要增加新的权限，比如查看某个模型的权限，那么我们可以在定义模型的时候在<code>Meta</code>中定义好。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Article</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    content = models.TextField()</span><br><span class="line">    author = models.ForeignKey(get_user_model(),on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        permissions = (</span><br><span class="line">            (<span class="string">'view_article'</span>,<span class="string">'can view article'</span>),</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h3 id="通过代码添加权限："><a href="#通过代码添加权限：" class="headerlink" title="通过代码添加权限："></a>通过代码添加权限：</h3><p>权限都是<code>django.contrib.auth.Permission</code>的实例。这个模型包含三个字段，<code>name</code>、<code>codename</code>以及<code>content_type</code>，其中的<code>content_type</code>表示这个<code>permission</code>是属于哪个<code>app</code>下的哪个<code>models</code>。用<code>Permission</code>模型创建权限的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> Permission,ContentType</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Article</span><br><span class="line">content_type = ContentType.objects.get_for_model(Article)</span><br><span class="line">permission = Permission.objects.create(name=<span class="string">'可以编辑的权限'</span>,codename=<span class="string">'edit_article'</span>,content_type=content_type)</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建权限的第二种方法通过实例模型创建权限</span></span><br><span class="line"><span class="comment">#引入权限表</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.models <span class="keyword">import</span> ContentType</span><br><span class="line"><span class="comment">#引入models类</span></span><br><span class="line"><span class="keyword">from</span> url_app.models <span class="keyword">import</span> Article</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> Permission</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_permission</span><span class="params">(request)</span>:</span></span><br><span class="line">    content_type = ContentType.objects.get_for_model(Article)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    codename  权限的名称</span></span><br><span class="line"><span class="string">    name  权限的描述</span></span><br><span class="line"><span class="string">    content_tpye 指定那个表的权限</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    permission = Permission.objects.create(codename=<span class="string">'black_article'</span>,name=<span class="string">'拉黑文章'</span>,content_type=content_type)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'权限创建成功！'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-权限-权限验证装饰器</title>
      <link href="/2016/06/07/121-%E6%9D%83%E9%99%90-%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2016/06/07/121-%E6%9D%83%E9%99%90-%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="权限限定装饰器："><a href="#权限限定装饰器：" class="headerlink" title="权限限定装饰器："></a>权限限定装饰器：</h3><p>使用<code>django.contrib.auth.decorators.permission_required</code>可以非常方便的检查用户是否拥有这个权限，如果拥有，那么就可以进入到指定的视图函数中，如果不拥有，那么就会报一个<code>400</code>错误。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> permission_required</span><br><span class="line"></span><br><span class="line"><span class="meta">@permission_required('front.view_article')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> permission_required</span><br><span class="line"><span class="comment">#这个装饰器做两件事情</span></span><br><span class="line"><span class="comment">#首先是判断你有没有登录，如果没有登录他就给你跳转到登录页面</span></span><br><span class="line"><span class="comment">#如果登录了再次判断你有没有这个权限，如果没有这个权限将给你跳转到登录页面</span></span><br><span class="line"><span class="comment">#如果 raice_exception = True 就会给你跳转到403的页面，可对这个页面进行编辑</span></span><br><span class="line"><span class="meta">@permission_required('url_app.add_article',login_url='/login/',raise_exception=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_article</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># if request.user.is_authenticated:</span></span><br><span class="line">    <span class="comment">#     print('已经登录了！')</span></span><br><span class="line">    <span class="comment">#     if request.user.has_perm('url_app.add_article'):</span></span><br><span class="line">    <span class="comment">#         return HttpResponse('这是添加文章的页面！')</span></span><br><span class="line">    <span class="comment">#     else:</span></span><br><span class="line">    <span class="comment">#         return HttpResponse('你没有访问这个文章的权限！！')</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment">#     return HttpResponse('很抱歉你没有登录！！')</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'这是添加文章的界面！！'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-权限-在模板中添加权限控制</title>
      <link href="/2016/06/07/123-%E6%9D%83%E9%99%90-%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
      <url>/2016/06/07/123-%E6%9D%83%E9%99%90-%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="在模板中使用权限："><a href="#在模板中使用权限：" class="headerlink" title="在模板中使用权限："></a>在模板中使用权限：</h2><p>在<code>settings.TEMPLATES.OPTIONS.context_processors</code>下，因为添加了<code>django.contrib.auth.context_processors.auth</code>上下文处理器，因此在模板中可以直接通过<code>perms</code>来获取用户的所有权限。</p><p>示例代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if perms.应用名.权限标识 %&#125;</span><br><span class="line">    <span class="comment">&lt;!-- 这里是有权限才显示的内容 --&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-权限-用户和权限相关操作</title>
      <link href="/2016/06/07/120-%E6%9D%83%E9%99%90-%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2016/06/07/120-%E6%9D%83%E9%99%90-%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="用户与权限管理："><a href="#用户与权限管理：" class="headerlink" title="用户与权限管理："></a>用户与权限管理：</h3><p>权限本身只是一个数据，必须和用户进行绑定，才能起到作用。<code>User</code>模型和权限之间的管理，可以通过以下几种方式来管理：</p><ol><li><code>myuser.user_permissions.set(permission_list)</code>：直接给定一个权限的列表。</li><li><code>myuser.user_permissions.add(permission,permission,...)</code>：一个个添加权限。</li><li><code>myuser.user_permissions.remove(permission,permission,...)</code>：一个个删除权限。</li><li><code>myuser.user_permissions.clear()</code>：清除权限。</li><li><code>myuser.has_perm(&#39;&lt;app_name&gt;.&lt;codename&gt;&#39;)</code>：判断是否拥有某个权限。权限参数是一个字符串，格式是<code>app_name.codename</code>。</li><li><code>myuser.get_all_permissons()</code>：获取所有的权限。</li></ol><p><strong>实例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operate_permission</span><span class="params">(request)</span>:</span></span><br><span class="line">    user = User.objects.get(telephone=<span class="string">'1111'</span>)</span><br><span class="line">    <span class="comment">#可以根据content_tpye 的外键关联进行添加</span></span><br><span class="line">    content_type = ContentType.objects.get_for_model(Article)</span><br><span class="line">    permissions = Permission.objects.filter(content_type=content_type)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#里面传递的是一个可迭代对象，上面的permission是一个列表，所以一次性可以将有关这个表的权限全部传给他</span></span><br><span class="line">    user.user_permissions.set(permissions)</span><br><span class="line">    user.save()</span><br><span class="line">    <span class="comment">#删除用户所有权限</span></span><br><span class="line">    <span class="comment"># user.user_permissions.clear()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#一次性添加一个权限</span></span><br><span class="line">    <span class="comment"># user.user_permissions.add(permissions[0])</span></span><br><span class="line">    <span class="comment"># 通过给加星号的方法可以把permissions打散开来，在添加进去</span></span><br><span class="line">    <span class="comment"># *[1,2,3]  = 1,2,3</span></span><br><span class="line">    <span class="comment"># user.user_permissions.add(*permissions)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#删除一个权限</span></span><br><span class="line">    <span class="comment"># user.user_permissions.remove(permissions[0])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取该用户的所有权限</span></span><br><span class="line">    <span class="comment"># print(user.get_all_permissions())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'操作权限完成！！！'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-权限-分组</title>
      <link href="/2016/06/07/122-%E6%9D%83%E9%99%90-%E5%88%86%E7%BB%84/"/>
      <url>/2016/06/07/122-%E6%9D%83%E9%99%90-%E5%88%86%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="分组："><a href="#分组：" class="headerlink" title="分组："></a>分组：</h2><p>权限有很多，一个模型就有最少三个权限，如果一些用户拥有相同的权限，那么每次都要重复添加。这时候分组就可以帮我们解决这种问题了，我们可以把一些权限归类，然后添加到某个分组中，之后再把和把需要赋予这些权限的用户添加到这个分组中，就比较好管理了。分组我们使用的是<code>django.contrib.auth.models.Group</code>模型， 每个用户组拥有<code>id</code>和<code>name</code>两个字段，该模型在数据库被映射为<code>auth_group</code>数据表。</p><h3 id="分组操作："><a href="#分组操作：" class="headerlink" title="分组操作："></a>分组操作：</h3><ol><li><code>Group.object.create(group_name)</code>：创建分组。</li><li><code>group.permissions</code>：某个分组上的权限。多对多的关系。<ul><li><code>group.permissions.add</code>：添加权限。</li><li><code>group.permissions.remove</code>：移除权限。</li><li><code>group.permissions.clear</code>：清除所有权限。</li><li><code>user.get_group_permissions()</code>：获取用户所属组的权限。</li></ul></li><li><code>user.groups</code>：某个用户上的所有分组。多对多的关系。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> Group</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operate_group</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#创建一个分组</span></span><br><span class="line">    <span class="comment">#组和权限是多对多关系 多个组可以拥有多个权限</span></span><br><span class="line">    <span class="comment"># group = Group.objects.create(name='运营')</span></span><br><span class="line">    <span class="comment"># content_type = ContentType.objects.get_for_model(Article)</span></span><br><span class="line">    <span class="comment"># permissions = Permission.objects.filter(content_type=content_type)</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># group.permissions.set(permissions)</span></span><br><span class="line">    <span class="comment"># group.save()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#一个组拥有了权限 一个 用户拥有了组 不就等同于一个用户拥有了权限吗？？</span></span><br><span class="line">    <span class="comment">#给指定用户添加分组，用户和分组是多对多关系一个用户可以拥有多个组</span></span><br><span class="line">    <span class="comment"># 定义user的时候并没有定义group那么 group是哪里来的？？</span></span><br><span class="line">    <span class="comment"># group = Group.objects.get(name='运营')</span></span><br><span class="line">    user = User.objects.get(telephone=<span class="string">'123123'</span>)</span><br><span class="line">    <span class="comment"># user.groups.add(group)</span></span><br><span class="line">    <span class="comment"># user.save()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取用户所属组的权限。</span></span><br><span class="line">    print(user.get_group_permissions())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#user.has_perm:</span></span><br><span class="line">    <span class="comment"># user.has_perms  可以判断多个权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># def has_perms(self, perm_list, obj=None):</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     Return True if the user has each of the specified permissions. If</span></span><br><span class="line">    <span class="comment">#     object is passed, check if the user has all required perms for it.</span></span><br><span class="line">    <span class="comment">#     """</span></span><br><span class="line">    <span class="comment">#     return all(self.has_perm(perm, obj) for perm in perm_list)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#1.首先判断user.permissions 下有没有这个权限，如果有：就True</span></span><br><span class="line">    <span class="comment">#2.如果过user.permission下没有这个权限，就会判断所属分组下有没有这个权限如果有则还是True</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'操作分组！'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">判断权限的装饰器也可以判断是否拥有多个权限那就是把权限放在一个列表中</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-Hello1</title>
      <link href="/2016/06/07/2.Django-Hello1/"/>
      <url>/2016/06/07/2.Django-Hello1/</url>
      
        <content type="html"><![CDATA[<p>Django-Hello</p><ul><li>开启Web项目</li></ul><blockquote><p>django-admin startproject django_hello</p></blockquote><ul><li><p>开启测试服务器</p><blockquote><p>python manage.py runserver 0.0.0.0:8000<br>压力负载很低，只是学习测试时测试<br>守护进程，后台运行</p></blockquote></li><li><p>配置所有人可以访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">ALLOWED_HOSTS = [<span class="string">"*"</span>]</span><br></pre></td></tr></table></figure></li><li><p>框架项目文件夹目录配置</p><ul><li><code>settings.py</code>: 这个是django配置文件</li><li><code>__init__.py</code>: 声明当前文件夹为一个可导入的包</li><li><code>urls.py</code>: 主控路由文件</li><li><code>wsgi.py</code>: uwsgi的服务器，上线时和uwsgi服务器配合使用，用来让uwsgi服务器找到django项目</li><li><code>manage.py</code>: django的项目命令行工具</li></ul></li><li><p>创建app</p><blockquote><p>业务分化，创建多个子app进行不同类型业务的管理<br>python manage.py startapp hello_app</p></blockquote></li><li><p>APP目录结构</p><ul><li><code>admin.py</code>: 注册数据库模型类到django后台admin界面</li><li><code>views.py</code>: 编写和这个app有关的视图函数</li><li><code>models.py</code>: 编写和这个app有关的数据表模型类</li></ul></li><li><p>ORM映射关系</p></li><li><p>将一套规定好的ORM映射函数 自动翻译成所使用SQL的不同语句</p></li><li><p>自己的视图函数业务编写</p><ul><li>1.编写视图函数：app-&gt;views.py-&gt;def</li><li>2.编写映射关系, 路由映射关系是通过path函数找到对应视图<ul><li>路由映射，必须写末尾的斜杠</li><li>路由查找，从上到下，匹配的到某一个，直接调用视图函数即可</li><li>404：页面没找到 403：服务器拒绝 402：保留位 401：用户权限鉴定失败 400：错误的请求、</li></ul></li><li>3.返回模板页面 == HTML页面<ul><li>1.配置模板页面的路径，设置一个路径在settings文件下，保存所有的静态目录，TEMPLATES</li><li>2.视图函数使用render进行页面渲染并返回</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webbench压力测试工具</title>
      <link href="/2016/06/07/3.Django-Hello2/"/>
      <url>/2016/06/07/3.Django-Hello2/</url>
      
        <content type="html"><![CDATA[<h2 id="作业解释"><a href="#作业解释" class="headerlink" title="作业解释"></a>作业解释</h2><ul><li><p>NGINX UWSGI</p><blockquote><p>部署上线模型<br>nginx epoll 异步IO复用套接字模型<br>异步IO：多个事件操作 只在一个线程或进程即可<br>recv accept: 阻塞<br>线程，进程区别：进程是内存独立的，线程共享父进程内存<br>多进程并不是好的，因为要进行进程的上下文切换<br>UWSGI: Web服务器，提高nginx效率，比runserver强多了</p></blockquote></li><li><p>TCP连接</p></li><li><p>webbench：压力测试工具 webbench -c 1000 -t 5<br>  <code>apt-get install gcc ctags</code></p></li></ul><blockquote><p>安装，使用一下</p></blockquote><ul><li>apache: apache-bench</li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul><li>了解异步IO、了解同步</li><li>了解阻塞和非阻塞是什么意思</li><li>使用代码编写简单的单进程IO复用服务器模型及客户端<ul><li>前后端分离：flask / django</li><li>Linux：家目录，根目录是什么 cd cd ~ cd /home</li><li>了解sqllit3数据库的应用场景和mysql的区别</li><li>文件系统有哪些？各有什么特点<ul><li>ntfs ext4 ext3</li></ul></li></ul></li></ul><h2 id="Django-Hello"><a href="#Django-Hello" class="headerlink" title="Django-Hello"></a>Django-Hello</h2><pre><code>* 1.返回了一个HTML页面* 2.构建了静态资源* 3.为模板页面返回模板变量: {{ var }} views-&gt;var* 4.模板标签：必须要有闭合标签 {% for %}* 5.静态资源: css,js,mp3,audio, 路径查找: 绝对、相对    * settings-&gt;STATICFILES_DIR-&gt;    * {% load static %}* 6.让视图函数从数据库里拿数据    * 有一个数据库：sqlite3 学习使用的轻量级数据库文件    * 创建表：吧表创建在对应的app下-&gt; models.py    * python manage.py makemigrations 查找当前数据库差异，迁移文件    * python manage.py migrate 通过迁移文件执行真正的SQL* 7.admin界面 可以管理django中所有用到数据表的app    * 必须创建超级用户才能看到这个界面: python3 manage.py createsuperuser* 8.admin界面注册模型类    * admin.site.register(models.Student)    * `__str__(self)`：用来为数据表具体某一个数据提供一个可读性更高的名字* 9.视图函数操作模型类表    * 让视图函数返回所有学生    * content = models.Student.objects.all()* 10.获取用户表单    * 用户的提交数据方式：get,post request.method == &apos;GET&apos; or &apos;POST&apos;    * 明确防跨站请求伪造令牌 {% csrf_token %}    * 视图函数判断请求方式 post        * request.POST.get() -&gt; form -&gt; value    * 存储数据 models.Student.create(字段=value...)* 1.返回HTML字符串* 2.返回HTML页面* 3.返回模板变量* 4.模板标签使用* 5.返回静态资源* 6.创建模型类* 7.admin界面使用* 8.视图返回数据表内容* 9.视图接收form表单值</code></pre>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django模型M</title>
      <link href="/2016/06/07/2.Django%E6%A8%A1%E5%9E%8BM/"/>
      <url>/2016/06/07/2.Django%E6%A8%A1%E5%9E%8BM/</url>
      
        <content type="html"><![CDATA[<h1 id="模型M"><a href="#模型M" class="headerlink" title="模型M"></a>模型M</h1><h2 id="一-Django-ORM"><a href="#一-Django-ORM" class="headerlink" title="一.Django ORM"></a>一.Django ORM</h2><ol><li>创建项目     django-admin stareproject 项目名</li><li>创建应用        python manae.py startapp 应用名</li><li>连接数据   mysql -u root -p</li><li>创建数据库表   create databases 数据库名 charser=UTF8</li></ol><h2 id="二-Django配置使用mysql数据库"><a href="#二-Django配置使用mysql数据库" class="headerlink" title="二.Django配置使用mysql数据库"></a>二.Django配置使用mysql数据库</h2><p>settings.py      配置下面的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,   <span class="comment">#指定连接mysql数据库</span></span><br><span class="line">        <span class="string">'NAME'</span>:<span class="string">'bj18'</span>,                      <span class="comment">#数据库名字//数据库需要手动创建</span></span><br><span class="line">        <span class="string">'USER'</span>:<span class="string">'root'</span>,                     <span class="comment">#连接mysql的用户名</span></span><br><span class="line">        <span class="string">'PASSWORD'</span>:<span class="string">'mysql'</span>,            <span class="comment">#用户对应的密码</span></span><br><span class="line">        <span class="string">'HOST'</span>:<span class="string">'localhost'</span>,            <span class="comment">#指定mysql数据库只当数据库所在IP</span></span><br><span class="line">        <span class="string">'PORT'</span>:<span class="number">3306</span>,                  <span class="comment">#用户端口号 默认3306</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在settings.py 同级的 <code>__init__.py</code> 下面配置 (看需求配置！！)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure><h2 id="三-重定向"><a href="#三-重定向" class="headerlink" title="三.重定向"></a>三.重定向</h2><h2 id="四-字段属性和选项"><a href="#四-字段属性和选项" class="headerlink" title="四.字段属性和选项"></a>四.字段属性和选项</h2><p>###模型类属性命名限制</p><ol><li><p>不能是python的保留关键字。</p></li><li><p>不允许使用连续的下划线，这是有Django的查询方式决定的。</p></li><li><p>定义属性时需要制定字段类型，通过字段类型的参数指定选项，语法如下：</p><p>#####属性名 = models.字段类型选项</p></li></ol><h3 id="字段类型："><a href="#字段类型：" class="headerlink" title="字段类型："></a>字段类型：</h3><p>使用时候需要引入django.db.models 包</p><table><thead><tr><th align="center"><strong>类型</strong></th><th align="left">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><strong>AutoField</strong></td><td align="left">自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性</td><td align="center"></td></tr><tr><td align="center"><strong>BooleanField</strong></td><td align="left">布尔字段，值为True或False    type(True) ==bool类型</td><td align="center"></td></tr><tr><td align="center"><strong>NullBooleanField</strong></td><td align="left">支持Null、True、False三种值</td><td align="center"></td></tr><tr><td align="center"><strong>CharField(max_length=最大长度)</strong></td><td align="left">字符串。参数max_length表示最大字符个数</td><td align="center"></td></tr><tr><td align="center"><strong>TextField</strong></td><td align="left">大文本字段，一般超过4000个字符使用</td><td align="center"></td></tr><tr><td align="center"><strong>IntegerField</strong></td><td align="left">整数</td><td align="center"></td></tr><tr><td align="center"><strong>DecimalField(<br>max_digits=None,<br>decimal_places=None)</strong></td><td align="left">十进制浮点数。参数manx_digits表示总位。参数decimal_places表示小数位。</td><td align="center"></td></tr><tr><td align="center"><strong>DeteField:(<br>[auto_now=False,<br>auto_now_add=False])</strong></td><td align="left"><strong>日期</strong>。<br>一：参数auto_now表示每次保存对象时，自动设置该子弹为当前时间“”最后一次修改”的时间戳，它总是使用当前日期，默认为false。<br>二：参数auto_now_add表示当对象第一次被创建是自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false.<br>三：参数 auto_now_add 和auto_now 是相互排斥的，组合将会发生错误。</td><td align="center"></td></tr><tr><td align="center"><strong>TimeField</strong></td><td align="left">时间，参数同DateField</td><td align="center"></td></tr><tr><td align="center"><strong>DateTimeField</strong></td><td align="left">日期时间，参数同DateField</td><td align="center"></td></tr><tr><td align="center"><strong>FileField</strong></td><td align="left">上传文件字段。</td><td align="center"></td></tr><tr><td align="center"><strong>ImageField</strong></td><td align="left">继承与FileField，对上传的内容进行校验，确保是有效的图片。</td><td align="center"></td></tr></tbody></table><h3 id="选项："><a href="#选项：" class="headerlink" title="选项："></a>选项：</h3><p><strong>通过选项实现对字符串字段的约束，选项如下：</strong></p><table><thead><tr><th align="center">选项名称</th><th>描述</th></tr></thead><tbody><tr><td align="center"><strong>defaule</strong></td><td>默认值。设置默认值。</td></tr><tr><td align="center"><strong>primary_key</strong></td><td>若为Ture,则该字段会成为模型的主键字段，默认值为False,一般作为Autofield的选项使用。</td></tr><tr><td align="center"><strong>unique</strong></td><td>如果为True,这个字段在表中必须是唯一值，默认值是False.</td></tr><tr><td align="center"><strong>db_index</strong></td><td>若值为True，则在表中会为此字段创建索引，默认值是False.</td></tr><tr><td align="center"><strong>db_column</strong></td><td>字段的名称。如果未指定，则使用属性的名称。</td></tr><tr><td align="center"><strong>null</strong></td><td>如果为True,表示允许为空，默认值是False</td></tr><tr><td align="center"><strong>blank</strong></td><td>如果为True,则该字段允许为空白，默认为False.</td></tr></tbody></table><p><strong>对比：null是数据库范畴的概念，blank是后台管理页面表单验证范畴的。</strong></p><p><strong>经验：</strong></p><p>​    <strong>当修改模型类之后如果添加的选项不影响表结构，则不需要重新做迁移，商品选项中default和blank不影响表结构。</strong></p><h2 id="五-查询"><a href="#五-查询" class="headerlink" title="五.查询"></a>五.查询</h2><p>###1.Linux修改Mysql的日志文件：</p><p>让其产生mysql.log,及是mysql的日志文件，里面记录的对mysql数据库的操作记录。</p><ol><li><p>使用下面的命令打开mysql的配置文件，去除68,69行的注释，然后保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudu vi /etc/mysql/mysql.comf.d/mysqld.cnf</span><br></pre></td></tr></table></figure></li><li><p>重启mysql服务，就会产生mysql的日志文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudu service mysql restart</span><br></pre></td></tr></table></figure></li><li><p>打开mysql日志文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/mysql/mysql.log 是mysql日志文件所在位置。</span><br></pre></td></tr></table></figure><p>使用下面命令可以实现查看mysql的日志文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tail -f /var/log/mysql/mysql.log</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-查询函数："><a href="#2-查询函数：" class="headerlink" title="2.查询函数："></a>2.查询函数：</h3><p>通过模型类：objects 属性可以调用如下函数，实现对模型类对应的数据表查询。</p><table><thead><tr><th>函数名</th><th>功能</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>get</td><td>返回表中满足条件的一条且只能有一条数据。</td><td>返回值是一个模型类对象</td><td>参数中写查询条件。<br>1.如果查到多个数据，则抛出异常 MultipleObjectsReturned.<br>2.查询不到数据，则抛出异常：DoesNotExist.</td></tr><tr><td>all</td><td>返回模型类对应表格中的所有数据</td><td>返回值是ouerySet类型。</td><td>查询集</td></tr><tr><td>filter</td><td>返回满足条件的数据。</td><td>返回值是OuerySer类型。</td><td>参数写查询条件</td></tr><tr><td>exclude</td><td>返回不满足条件的数据。</td><td>返回值是ouerySet类型</td><td>参数写查询条件</td></tr><tr><td>order_by</td><td>对查询结果进行排序</td><td>返回值是OuerySet类型</td><td>参数中写根据那个字段进行排序</td></tr></tbody></table><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>查询一条信息</p><h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>查询所有信息</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>条件格式：</p><p>模型类属性名__条件名 = 值  （双下划线）</p><h5 id="1-判等-exact"><a href="#1-判等-exact" class="headerlink" title="1.判等 exact"></a>1.判等 exact</h5><p>查询编号为1的图书。</p><p>bookInfo.objects.get(id=1)</p><p>bookInfo.objects.get(id__exact=1)</p><h5 id="2-模糊查询"><a href="#2-模糊查询" class="headerlink" title="2.模糊查询"></a>2.模糊查询</h5><ul><li><p>包含 contains</p><p>查询包含传的图书：</p><p>bookInfo.objects.filter(dtitle__contains=’传’)</p></li><li><p>以什么结尾 endswith  </p><p>bookInfo.objects.filter(dtitle__endswith=’xxx’)</p></li><li><p>以什么开头 startswith </p><p>bookInfo.objects.filter(dtitle__ startswith=’xxx’)</p></li></ul><p>#####3.空查询 isnull</p><p>​    bookInfo.objects.filter(btitle__isnull=False)   查询不为空的值</p><h5 id="4-范围查询-in"><a href="#4-范围查询-in" class="headerlink" title="4.范围查询 in"></a>4.范围查询 in</h5><h5 id="5-比较查询"><a href="#5-比较查询" class="headerlink" title="5.比较查询"></a>5.比较查询</h5><table><thead><tr><th><strong>gt</strong></th><th><strong>大于</strong></th></tr></thead><tbody><tr><td><strong>lt</strong></td><td><strong>小于</strong></td></tr><tr><td><strong>gte</strong></td><td><strong>大于等于</strong></td></tr><tr><td><strong>lte</strong></td><td><strong>小于等于</strong></td></tr></tbody></table><h5 id="6-日期查询"><a href="#6-日期查询" class="headerlink" title="6.日期查询"></a>6.日期查询</h5><h5 id="7-exclude-返回不满足条件的值。"><a href="#7-exclude-返回不满足条件的值。" class="headerlink" title="7.exclude 返回不满足条件的值。"></a>7.exclude 返回不满足条件的值。</h5><p>​    与 filter 相反 exclude 返回不满足条件的值。</p><h5 id="8-order-by-方法示例"><a href="#8-order-by-方法示例" class="headerlink" title="8.order_by  方法示例"></a>8.order_by  方法示例</h5><p>​    作用：进行查询结果进行排序。</p><p>​    正序：字段名 .objects .all().order_by(‘字段’)    可以根据多个字段进行排序  升序从小到大</p><p>​    倒序：字段名 .objects .all().order_by(‘-字段’)    可以根据多个字段进行排序  降序从大到小 降序在字段前面加上 负号即可</p><p>​    查询条件加排序：字段名.objects.filter(字段__判断条件=‘判断内容’).order_by(‘排序字段’)  默认升序，加上 负号 降序。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>只有get 返回一个模型的对象，其他查询条件返回的都是 查询集的对象。</p><h4 id="多条件查询："><a href="#多条件查询：" class="headerlink" title="多条件查询："></a>多条件查询：</h4><p>filter,exclude 可以多个条件查询。</p><p>条件之间是且的关系，</p><h2 id="六-F对象"><a href="#六-F对象" class="headerlink" title="六.F对象"></a>六.F对象</h2><p>作用：用于类属性之间的比较。</p><p>解释F：之前我们的查询都是对一个值进行比较，而F对象适用于跟一个 属性之间进行比较。</p><p>使用之前需要导入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br></pre></td></tr></table></figure><p>例：查询阅读量大于评论量图书的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用F把表内字段 包起来就行了。</span><br><span class="line">BookInfo.objects.filter(bread__gt = F( <span class="string">"bcomment"</span> ))</span><br></pre></td></tr></table></figure><p>例：查询图书阅读量大于2倍评论量的图书信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接在后面写 * <span class="number">2</span> 就OK</span><br><span class="line">BookInfo.objects.filter(bread__gt = F( <span class="string">"bcomment"</span> )*<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="七：Q对象、"><a href="#七：Q对象、" class="headerlink" title="七：Q对象、"></a>七：Q对象、</h2><p><strong>作用：用于查询是条件之间的逻辑。and or not ,可以对Q对象进行 &amp;|~ 操作。</strong></p><p>使用之前需要先导入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>Q</strong></th><th><strong>所查询的对象需要被Q()包含</strong></th></tr></thead><tbody><tr><td><strong>|</strong></td><td><strong>逻辑或</strong></td></tr><tr><td><strong>&amp;</strong></td><td><strong>和逻辑与</strong></td></tr><tr><td><strong>~</strong></td><td><strong>逻辑非</strong></td></tr></tbody></table><p>例：查询id大于3且阅读量大于30的图书信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">普通方法  两个条件是逻辑与的关系。</span><br><span class="line">BookInfo.objects.filter( id__gt=<span class="number">3</span> , bread__gt=<span class="number">30</span> )</span><br><span class="line"></span><br><span class="line">Q对象方法 要被查询的字段需要被Q()包含  &amp;代表逻辑与</span><br><span class="line">BookInfo.objects.filter( Q(id__gt=<span class="number">3</span>) &amp; Q(bread__gt=<span class="number">30</span>) )</span><br></pre></td></tr></table></figure><p>例：查询id大于3或者阅读量大于30的图书信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 是逻辑或  用它连接Q的条件。</span><br><span class="line">BookInfo.objects.filter( Q(id__gt=<span class="number">3</span>) | Q(bread__gt=<span class="number">30</span>) )</span><br></pre></td></tr></table></figure><p>例：查询id不等于3的图书信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ 不等于的意思，</span><br><span class="line">BookInfo.objects.filter(~ Q(id=<span class="number">3</span>) )</span><br></pre></td></tr></table></figure><h2 id="八-聚合函数"><a href="#八-聚合函数" class="headerlink" title="八.聚合函数"></a>八.聚合函数</h2><p><strong>作用：对查询结果进行聚合操作。</strong> 导入的时候首字母为大写。</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>sum</td><td>总计</td></tr><tr><td>count</td><td>统计数</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr></tbody></table><p><strong>aggregate</strong>:调用这个函数来使用聚合。返回一个值是字典。</p><p>使用之前需先导入聚合类：    用哪个导入那个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Sum,Count,Max,Min,Avg</span><br></pre></td></tr></table></figure><p>###aggregate函数</p><p>例：查询所有图书的数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">必须制定某一个字段不能使用 * </span><br><span class="line">BookInfo.objects.all() . aggregate( Count (<span class="string">'id'</span>) )</span><br></pre></td></tr></table></figure><p>例：查询所有图书阅读量的综合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookInfo.objects . aggregate( Sum (<span class="string">'bread'</span>) )</span><br></pre></td></tr></table></figure><h3 id="count-函数"><a href="#count-函数" class="headerlink" title="count 函数"></a>count 函数</h3><p>返回值是一个数字。</p><p>作用：统计满足条件数据的数目。</p><p>例：统计所有图书的数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回一个数字 返回所有读书的数量</span><br><span class="line">BookInfo.objects.all().count()</span><br><span class="line">针对查询所有all可以省略。</span><br><span class="line">BookInfo.objects.count()</span><br></pre></td></tr></table></figure><p>例：统计id大于3的所有图书数目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对数据进行筛选之后，在使用count函数。</span><br><span class="line">BookInfo.objects.filter(id__gr=<span class="number">3</span>).count()</span><br></pre></td></tr></table></figure><h3 id="查询相关函数！！"><a href="#查询相关函数！！" class="headerlink" title="查询相关函数！！"></a>查询相关函数！！</h3><ul><li><p>get:返回一个且只能有一条数据，返回值是一个对象，参数可以写查询条件。</p></li><li><p>all:返回模型类对应表的所有数据，返回值是QuerySet.</p></li><li><p>filter:返回满足套件的数据，返回值是QuerySet,参数可以写查询条件。</p></li><li><p>exclude:返回不满足条件的数据，返回值是QuerySer，参数可以写查询条件。</p></li><li><p>order_by:对查询结果进行排序返回值是QuerySet,参数中写排序的字段。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import F,Q,Count,Max,Min</span><br></pre></td></tr></table></figure><ul><li>F对象：用于类属性之间进行比较。</li><li>Q对象：用于条件之间的逻辑关系。</li></ul><ul><li>aggregate:进行聚合操作，返回值是一个字典，进行聚合的时候，需要先导入聚合类。</li><li>count:返回结果集中数据的目的，返回值是一个数字。</li></ul><p>注意：</p><p>​    对一个QuerySet实例对象，可以据需调用上面的所有函数。</p><p>注意：</p><ol><li>通过模型类实现关联查询时，要查那个表中的数据，就需要通过那个类来查。</li><li>写关联查询条件的时候，如果类中没有关系属性，条件需要对应类的名，如果类中有关系属性，直接写关系属性。</li></ol><h2 id="九-查询集"><a href="#九-查询集" class="headerlink" title="九.查询集"></a>九.查询集</h2><p><strong>all  、 filter 、 exclude 、 order_by 调用这些函数会产生查询集，QuerySet类对象可以继续调用上限所有函数。</strong></p><ol><li>惰性查询：只有在实际使用查询集中的数据的时候才会发生对数据的真正查询。</li><li>缓存：当使用的是统计一个查询集的时候，第一次的时候就会发生实际数据库的查询，然后把结果缓存起来，之后在使用这个查询集的时候，使用的是缓存的结果。</li></ol><p><strong>限制查询集：</strong></p><p>可以对一个查询集进行去下表或者切片操作来限制查询集的结果。</p><p>对一个查询集进行切片操作会产生一个新的查询集，下表不允许为负数。</p><p>取出查询集第一条数据的两种方式：</p><table><thead><tr><th>方式</th><th>说明</th></tr></thead><tbody><tr><td>b[0]</td><td>如果  b[0] 不存在，就会抛出一个 IndexError异常。</td></tr><tr><td>b[0:1].get()</td><td>如果 b[0:1].get() 不存在，就会抛出DoesNotExist异常。</td></tr></tbody></table><p>exists:来判断一个查询集中是否有数据。 True False</p><h2 id="十-模型类关系"><a href="#十-模型类关系" class="headerlink" title="十.模型类关系"></a>十.模型类关系</h2><ul><li>一对多关系<ul><li>列：图书类 —– 英雄类</li><li>models.ForeignKey()  定义在多的类中。</li></ul></li><li>多对多关系<ul><li>列：新闻类 —- 新闻类型类 体育信息  国际新闻       </li><li>models.ManyToManyField()      定义在那个类中都行。</li></ul></li><li>一对一关系。<ul><li>列：员工基本信息类 —- 员工详细信息类 。 员工工号 。 员工被删除员工详细信息类还在，但是员工号不消失</li><li>models.OneToOneField 定义在那个类都行。</li></ul></li></ul><p>##十一.关联查询</p><p>###一对多:</p><p>一对多的关系，例如员工跟部门。一个部门有多个员工。那么在django怎么建立这种表关系呢？</p><p>其实就是利用外键，在多的一方，字段指定外键即可。例如员工和部门，员工是多，所以在员工表直接部门即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span><span class="params">(models.Model)</span>:</span>         //建立部门表 继承Model</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>)        //部门名称 字符<span class="number">20</span></span><br><span class="line">    create_data = models.DateField(auto_now_add=<span class="literal">True</span>)   //部门创建时间</span><br><span class="line">    is_delete = models.BooleanField(default=<span class="literal">False</span>)   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">"department"</span>         //别名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(models.Model)</span>:</span>        //建立员工表 继承Model</span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>)    //名字</span><br><span class="line">    age = models.IntegerField()                //年龄</span><br><span class="line">    gender = models.IntegerField(default=<span class="number">0</span>)         //性别</span><br><span class="line">    <span class="comment"># decimal_place = 2表示两位小数，max_digits表示8个数字，包括小数的两位</span></span><br><span class="line">    salary = models.DecimalField(max_digits=<span class="number">8</span>,decimal_places=<span class="number">2</span>)        //工资 使用精度浮点</span><br><span class="line">    <span class="comment"># null=True 表示可以为空,blank=True表示django后台管理输入这个字段可以为空</span></span><br><span class="line">    comment = models.CharField(max_length=<span class="number">300</span>,null=<span class="literal">True</span>,blank=<span class="literal">True</span>) //评论</span><br><span class="line">    hire_data = models.DateField(auto_now_add=<span class="literal">True</span>)   //创建时间</span><br><span class="line">    department = models.ForeignKey(<span class="string">"Department"</span>)        //所在部门 一对多关系</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">"employee"</span>      //别名</span><br></pre></td></tr></table></figure><ul><li><h5 id="在设置外键时，需要通过on-delete-选项指明主表删除数据时，对于外键引用数据表如何处理，在Django-db-models-中包含了可选常量。"><a href="#在设置外键时，需要通过on-delete-选项指明主表删除数据时，对于外键引用数据表如何处理，在Django-db-models-中包含了可选常量。" class="headerlink" title="在设置外键时，需要通过on_delete 选项指明主表删除数据时，对于外键引用数据表如何处理，在Django.db.models 中包含了可选常量。"></a>在设置外键时，需要通过on_delete 选项指明主表删除数据时，对于外键引用数据表如何处理，在Django.db.models 中包含了可选常量。</h5><p>关联属性on_delete 选项的取值</p><ul><li><p><code>models.CASCADE</code> 此为默认值，级联删除，会删除关联数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">department = models.ForeignKey(<span class="string">'Department'</span>,on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure></li><li><p><code>models.PROTECT</code> 只要存在关联数据就不能删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">department = models.ForeignKey(<span class="string">'Department'</span>, on_delete=models.PROTECT)</span><br></pre></td></tr></table></figure></li><li><p><code>models.SET_NULL</code> 删除数据后关联字段设置为NULL，仅在该字段允许为<code>null</code>时可用（<code>null=True</code>）</p></li></ul></li><li><h5 id="如果关联的字段不在该应用文件夹的model-py中，那么要写成这样"><a href="#如果关联的字段不在该应用文件夹的model-py中，那么要写成这样" class="headerlink" title="如果关联的字段不在该应用文件夹的model.py中，那么要写成这样"></a>如果关联的字段不在该应用文件夹的model.py中，那么要写成这样</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">department = models.ForeignKey(<span class="string">"(应用文件夹名).Department"</span>)</span><br></pre></td></tr></table></figure><p>还有一个需要特别注意：</p><blockquote><p>department = models.ForeignKey(“Department”，related_name=’employee’)时，通过部门查找员工的是用employee。如果不设置的话，是用默认的employee_set(类名的小写+_set)</p></blockquote><p>一对多的查询</p><blockquote><p>一个员工所属的部门(查出来的是对象)：</p><p>a = Employee.objects.get(id=1)</p><p>b = a.department</p><p>一个部门的全部员工(查出来的是对象)：</p><p>a = Department.objects.get(id=1)</p><p>b = a.employee_set.all()</p></blockquote></li></ul><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>多对多的关系，例如学生与社团。一个学生可以进多个社团，一个社团可以有多个学生。那么在django怎么建立这种表关系呢？</p><p>django建立多对多关系有两种方法。</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(models.Model)</span>:</span>          //学生表</span><br><span class="line">    name= models.CharField(max_length=<span class="number">16</span>)       //姓名</span><br><span class="line">    birthday=models.DateField()           //生日</span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Club</span><span class="params">(models.Model)</span>:</span>             //班级</span><br><span class="line">    name= models.CharField(max_length=<span class="number">16</span>)            //名称</span><br><span class="line">    members = models.ManyToManyField(<span class="string">"Student"</span>)        //多对多关联</span><br></pre></td></tr></table></figure><p>只需要在任意一方加上类似第6行的ManyToManyField就可以了。Django会自动为多对多关联关系创建一张表，用于两张表的联系。</p><p>那么查询呢？</p><blockquote><p>1.一个社团的全部成员(查出来的是对象)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = Club.objects.get(id=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">c.members.all()</span><br></pre></td></tr></table></figure><blockquote><p>2.一个成员的全部社团(查出来的是对象)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = Student.objects.filter(id=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">s.club_set.all()    <span class="comment"># 类名的小写+_set</span></span><br></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>手动创建一张表关联联系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name= models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line">    birthday=models.DateField()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Club</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name= models.CharField(max_length=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Membership</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    student = models.ForeignKey(<span class="string">"Student"</span>)</span><br><span class="line">    club = models.ForeignKey(<span class="string">"Club"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>一个学生加入的全部社团：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = Student.objects.get(id=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">b = a.membership_set.all()  <span class="comment"># 查出来的是对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    print(i.club.name)</span><br></pre></td></tr></table></figure><blockquote><p>一个社团的全部学生：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = Club.objects.get(id=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">b = a.membership_set.all()  <span class="comment"># 查出来的是对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line"></span><br><span class="line">    print(i.student.name)</span><br></pre></td></tr></table></figure><p>在一对多关系中，一对应的类我们把它叫做一类，多对应的关系我们叫多类，我们把多类中定义的建立关联的类属性叫做关系属性。</p><h2 id="十二-插入、更新和删除"><a href="#十二-插入、更新和删除" class="headerlink" title="十二.插入、更新和删除"></a>十二.插入、更新和删除</h2><p>调用一个模型类的对象save 方法的时候就可以实现对模型类对象数据表的插入和更新。</p><p>调用一个模型类对象的delete方法的时候就可以实现对模型类对应数据表的删除。</p><h2 id="十三-自关联"><a href="#十三-自关联" class="headerlink" title="十三.自关联"></a>十三.自关联</h2><p>自关联是一个特殊的一对多关系。</p><p>自关联模型，就是表中的某一列，关联了这个表中的另外一列。最典型的自关联模型就是地区表。省、市、县都在一张表里面。省的pid为null，市的pid为省的id，县的pid为市的id。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Area</span><span class="params">(models.Model)</span>:</span>    </span><br><span class="line">        name = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">'名称'</span>)</span><br><span class="line">        <span class="comment"># 自关联(特殊的一对多): 生成的字段名 parent_id</span></span><br><span class="line">        parent = models.ForeignKey(<span class="string">'self'</span>, verbose_name=<span class="string">'上级行政区划'</span>)</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">            db_table = <span class="string">'tb_areas'</span></span><br><span class="line">            verbose_name = <span class="string">'行政区划'</span></span><br></pre></td></tr></table></figure><p>查询方法：</p><p>如果知道一个市，叫a市，想查他属于什么省。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = Area.objects.get(id=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b就是a市的省份的对象</span></span><br><span class="line"></span><br><span class="line">b = a.parent</span><br></pre></td></tr></table></figure><blockquote><p>如果知道一个省，叫a省，想查他有什么市。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = Area.object.get(id=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># b就是a省的全部市的对象</span></span><br><span class="line"></span><br><span class="line">b = a.area_set.all()    <span class="comment">#类名小写+'_set'</span></span><br></pre></td></tr></table></figure><h2 id="十四-管理器"><a href="#十四-管理器" class="headerlink" title="十四.管理器"></a>十四.管理器</h2><p><strong>BookInfo.objects.all()         —-&gt; objects 是什么东西呢？</strong></p><p>答：objects 是Django 帮我自动生成的管理器对象，通过这个管理器可以实现对数据的查询。</p><p>objects 是 models.Manger 类的一个对象，自定义管理器之后Django不在帮我们生成默认的 objects 管理器。</p><ol><li>自定义管理器类，这个类继承models.manger类。</li><li>再在集体的模型类李定义一个自定义管理器的对象。</li></ol><p>自定义管理器的应用场景：</p><ol><li><p>改变查询的结果集。</p><p>比如调用BookInfo.books.all() 返回的是没有删除的图书数据。</p><p><strong>下面是一个自定义模型管理器：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoManager</span><span class="params">(models.Manager)</span>:</span>  //自定义方法使用manager</span><br><span class="line">  <span class="string">'''图书模型管理器'''</span></span><br><span class="line">  <span class="comment"># 1. 改变查询结果集。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">all</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment">#1.调用父类的all,获取所有数据。</span></span><br><span class="line">    books = super().all()   <span class="comment">#返回QuerSet对象。</span></span><br><span class="line">    <span class="comment">#2.对数据进行过滤。</span></span><br><span class="line">    books = books.filter(isDelete = <span class="literal">False</span>)   //写过滤条件</span><br><span class="line">    <span class="comment">#3.返回books</span></span><br><span class="line">    <span class="keyword">return</span> books</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>添加额外方法。</p><p>管理器类定义一个方法帮我们擦欧总模型类对应的数据表。</p><p>使用 self.model() 就可以创建一个跟自定义管理器对应的模型类对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">  name = Model.CharField(max_length=<span class="number">20</span>)</span><br><span class="line">  bpub_date = Model.</span><br><span class="line">  <span class="string">"""在表类里定义添加方法"""</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create_book</span><span class="params">(cls,name)</span>:</span>        //传一个形参</span><br><span class="line">    <span class="comment">#1.创建一个图书对象。</span></span><br><span class="line">    obj = cls()</span><br><span class="line">    obj.name = name</span><br><span class="line">    <span class="comment">#2.保存数据库。</span></span><br><span class="line">    obj.save()</span><br><span class="line">    <span class="comment">#3.返回 obj</span></span><br><span class="line">    <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><p>这种方法定义在模型类里，模型类的内容就会很多，这种方法一般我们通常定义在模型管理器里。</p><p>封装函数：操作模型类对应的数据表（增删改查）都可以写在里面。</p><p><strong>模型管理类与模型类之间的关系</strong></p><p><img src=".%5Cassets%5C%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%8E%E6%A8%A1%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="模型管理类与模型类的关系"></p></li></ol><h2 id="十五-元选项"><a href="#十五-元选项" class="headerlink" title="十五.元选项"></a>十五.元选项</h2><p>Django默认生成的表名：</p><p>​    应用名小写_模型类名小写</p><p>元选项：</p><p>​    需要在模型类中定义一个元类Meta,在里面定义一个雷属性 db_table 就可以只当表名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">  db_table = <span class="string">'bookinfo'</span>     //指定模型类对应的表名</span><br></pre></td></tr></table></figure><p>指定之后需要从新做迁移。</p><h3 id="模型元选项"><a href="#模型元选项" class="headerlink" title="模型元选项"></a>模型元选项</h3><p>Options.abstract:<br>如果 abstract = True， 就表示模型是 抽象基类 (abstract base class).</p><p>Options.db_table:<br>该模型所用的数据表的名称：<br>db_table = ‘music_album’</p><p>Options.db_tablespace:<br>当前模型所使用的数据库表空间 的名字。<br>默认值是项目设置中的DEFAULT_TABLESPACE，如果它存在的话。<br>如果后端并不支持表空间，这个选项可以忽略。</p><p>get_latest_by<br>Options.get_latest_by<br>模型中某个可排序的字段的名称，比如DateField、DateTimeField或者IntegerField。<br>它指定了Manager的latest()和earliest()中使用的默认字段。</p><p>Options.managed<br>默认为True，意思是Django在migrate命令中创建合适的数据表，并且会在 flush 管理命令中移除它们。<br>换句话说，Django会管理这些数据表的生命周期。<br>如果是False，Django 就不会为当前模型创建和删除数据表。</p><p>Options.order_with_respect_to<br>按照给定的字段把这个对象标记为”可排序的“。这一属性通常用到关联对象上面，使它在父对象中有序。<br>相关联的对象也有两个方法， get_next_in_order() 和get_previous_in_order()，用于按照合适的顺序访问它们。</p><p>Options.ordering<br>对象默认的顺序，获取一个对象的列表时使用：<br>ordering = [‘-order_date’]<br>它是一个字符串的列表或元组。每个字符串是一个字段名，前面带有可选的“-”前缀表示倒序。<br>前面没有“-”的字段表示正序。使用”?”来表示随机排序</p><p>Options.permissions<br>设置创建对象时权限表中额外的权限。增加、删除和修改权限会自动为每个模型创建。</p><p>Options.proxy<br>如果proxy = True, 作为该模型子类的另一个模型会被视为代理模型。</p><p>Options.unique_together<br>用来设置的不重复的字段组合：<br>unique_together = ((“driver”, “restaurant”),)<br>它是一个元组的元组，组合起来的时候必须是唯一的。它在Django后台中被使用，<br>在数据库层上约束数据(比如，在 CREATE TABLE 语句中包含 UNIQUE语句)。</p><p>Options.index_together<br>用来设置带有索引的字段组合：<br>index_together = [<br>    [“pub_date”, “deadline”],<br>]</p><h2 id="十六-抽象基类"><a href="#十六-抽象基类" class="headerlink" title="十六.抽象基类"></a>十六.抽象基类</h2><p><strong>抽象基类在你将一些共同信息导入到多个其他模型的时候很有用。</strong></p><p><strong>你写你的基类，并在Meta类（元类）中设置abstract=True。该模型不用于生成任何数据库表。反而，当抽象基类用于其他模型的一个基类是，它的fields（字段）会被添加到那些子类中。</strong></p><p>这个是错误的：抽象基类和其子类拥有同名的字段（Django会报异常）。</p><p>一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">age = models.PositiveIntegerField()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line"></span><br><span class="line">abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(CommonInfo)</span>:</span></span><br><span class="line"></span><br><span class="line">home_group = models.CharField(max_length=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上例中，Student模型有3个字段，name，age和home_group.CommonInfo模型不能用于普通Django模型，因为这是个抽象基类。CommonInfo不会生成一个数据库表或者拥有一个管理器，不能被实例化和直接存储。</p><p>对于许多用户来说，这种继承模型类型正是你想要的。它提供了在Python级别分解共同信息的一种方法，同时只根据数据库等级的子模型来生成一个数据库表。</p><p>###Meta继承：</p><p>   创建抽象基类的时候，Django 会将你在基类中所声明的有效的 Meta 内嵌类做为一个属性。</p><p>如果子类没有声明自己的Meta类，它将继承父类的Meta类。如果子类想要扩展父Meta类，可以子类化。</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonInfo</span><span class="params">(model.Model)</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line"></span><br><span class="line">abstrasct = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">ordering = [<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(CommonInfo)</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(CommonInfo.Meta)</span>:</span></span><br><span class="line"></span><br><span class="line"> db_table = ‘student_info’</span><br></pre></td></tr></table></figure><p>Django对抽象基类的Meta类做了一个调整：在安装Meta属性前，设置abstract=False.这意味着抽象基类的子类本身不会自动变成抽象类。当然，你可以通过从其他抽象基类继承的方法来生成一个抽象基类。你只要记住，每次明确地设置abstract=True。</p><p>对抽象基类而言，有些属性放在Meta内嵌类中没有意义。例如，包含db_table意味着所有子类（那些没有Meta内嵌类的子类）将会使用相同的数据库表，当然这也不是你想要的。</p><p>对于related_name 和 related_query_name要特别小心</p><p>当你正在ForeignKey或者MangToManyField中正使用related_name或者related_query_name时，你总要给字段（field）明确一个unique reverse name（唯一反向名称）和query time。这通常会在抽象基类中导致出现问题，因为Django会将基类字段添加进子类当中，而每个子类的字段属性值基本相同。这样，在使用ForeignKey或者ManyToManyField反向指定时，就无法确定指向哪个子类了。</p><p>为解决这个问题，当你（仅）在抽象基类中使用related_time或者related_query_name时，部分值应该包含’%(app_label)s’和‘%（class）s’。</p><p>‘%（class）s’会被子类名字取代；</p><p>‘%（app_label）s’会被子类所在App的名字取代。</p><p>举例：</p><p>假定有个app common/models.py:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">m2m = models.ManyToManyField(</span><br><span class="line"></span><br><span class="line">OtherModel,</span><br><span class="line"></span><br><span class="line">related_name = <span class="string">"%(app_label)s_%(class)s_related"</span>,</span><br><span class="line"></span><br><span class="line">related_query_name = <span class="string">"%(app_label)s_%(class)ss"</span>,</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line"></span><br><span class="line">abstract = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildA</span><span class="params">(Base)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildB</span><span class="params">(Base)</span>：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">pass</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">在另一个<span class="title">app</span>，<span class="title">rare</span>/<span class="title">models</span>.<span class="title">py</span>中：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">from</span> <span class="title">common</span>.<span class="title">models</span> <span class="title">import</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ChildB</span><span class="params">(base)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那么，common.ChildA.m2m字段的反向名称common_childa_related,</p><p>   common_ChildB.m2m字段的反向名称为commom_childb_related;</p><p>   rare app中，rare.ChildB.m2m字段的反向名称为rare_childb_related.</p><p>如果你没有在抽象基类中为某个关联字段定义related_name属性，那么默认的反向名称就是子类名称加上‘_set’,它能否正常工作取决于你是否在子类中定义了同名字段。</p><p>例如，上面代码中，如果去掉related_name属性，在ChildA中，m2m字段的反向名称就是childa_set；</p><p>而ChildB的m2m字段的反向名称就是childb_set.</p><p>###Multi-table继承 多表继承</p><p>这是Django支持的第二种继承方式。使用这种继承方式时，同一层级下的每个子model本身是一个model。</p><p>每个子model都有自己的数据库表，可单独查询与创建。继承关系在子model和它的每个父类之间采用链接方式。（通过自动创建的OneToOneField）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Place</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"></span><br><span class="line">name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">address = models.CharField(max_length=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(Place)</span>:</span></span><br><span class="line"></span><br><span class="line">serves_hot_dogs = models.BooleanField(default=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">serves_pizza = models.BooleanField(default=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>Place的所有字段在Restaurant中都可以使用，尽管数据驻留在不同的数据库表中。所以下面这些都是可能的：</p><blockquote><p>Place.objects.filter(name=”Bob’s Cafe”)</p></blockquote><blockquote><p>Restaurant.objects.filter(name=”Bob’s Cafe”)</p></blockquote><p>如果你有一个Place，同时也是Restaurant，你可以使用小写的model名称，从Place对象得到Restaurant对象：</p><blockquote><p>p = Place.objects.get(id=12)</p></blockquote><p>If p is restaurant object, this will give the child class:</p><blockquote><p>p.restaurant</p></blockquote><p>Restaurant:…</p><p>如果上例中p不是一个Restaurant，（它已经直接有Place对象创建或者是一些其他类的父类）。引用p.restaurtant将抛出Restaurant.DoesNotExist异常：</p><blockquote><p>from myapp.models import Place,Restaurant</p></blockquote><blockquote><p>p=Place.objects.create(name=’Place’,addres=‘Place’）</p></blockquote><blockquote><p>p.restaurant</p></blockquote><p>DoesNotExist:Place has no restaurant.</p><p>自动创建的Restaurant的OneToOneField字段链接Place如下：</p><p>place_ptr = models.OneToOneField(Placemon_delete=models.CASCADE,parent_link=Terue,)</p><p>你可以重载Restaurant的字段，通过在自己的OneToOneField中申明parent_link=True。</p><p>###Meta和多表继承</p><p>在多表继承中，子类继承父类的Meta内嵌类没什么不清楚的。所有Meta选项已经对父类起作用了，再次使用只会起反作用（这与使用抽象基类的情况正好相反，因为抽象基类并没有属于它自己的内容）</p><p>待续。。。。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django视图V</title>
      <link href="/2016/06/07/3.Django%E8%A7%86%E5%9B%BEV/"/>
      <url>/2016/06/07/3.Django%E8%A7%86%E5%9B%BEV/</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="一-视图的功能"><a href="#一-视图的功能" class="headerlink" title="一.视图的功能"></a>一.视图的功能</h2><p>请求接受，进行处理，与M和T进行交互，返回应答。</p><p>返回 html 内容 HttpResponse  也可以重定向 redirect</p><h2 id="二-视图函数使用"><a href="#二-视图函数使用" class="headerlink" title="二.视图函数使用"></a>二.视图函数使用</h2><h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h3><ul><li>定义视图函数 request 参数必须有。是一个 HttpRequest类型对象。参数名可以变换，但不要更改。</li><li>配置url建立url 和视图函数之间的对应关系。</li></ul><h3 id="2-url配置过程"><a href="#2-url配置过程" class="headerlink" title="2.url配置过程"></a>2.url配置过程</h3><ul><li>在项目的urls 文件中包含具体应用的urls 文件，在具体应用的urls文件中包含具体url和视图的对应关系。</li><li>url配置项是定义在一个叫 urlpatterns 的列表中，其中每一个元素就是一个配置项，每一个配置项都调用urlh函数。</li></ul><h3 id="3-url匹配的过程"><a href="#3-url匹配的过程" class="headerlink" title="3.url匹配的过程"></a>3.url匹配的过程</h3><p><img src=".%5Cassets%5C%E8%B7%AF%E7%94%B1%E5%8C%B9%E8%BF%87%E7%A8%8B.png" alt></p><p>url:<a href="http://127.0.0.1:8000/aindex?a=1" target="_blank" rel="noopener">http://127.0.0.1:8000/aindex?a=1</a></p><ol><li>去除域名和后面的参数，剩下/aindex，再把前面的/去掉，剩下aindex</li><li>拿aindex先到项目的url.py 文件中进行从上到下的匹配，匹配成功后执行后面对应的处理动作，就是把匹配成功的部分a字符去掉，然后拿剩下的部分index到应用的urls.py 文件中在进行从上到下的匹配。</li><li>如果匹配成功则调用相应的视图产生内容返回给客户端。如果匹配失败则产生404错误。</li></ol><h3 id="4-错误视图"><a href="#4-错误视图" class="headerlink" title="4.错误视图"></a>4.错误视图</h3><p>404：找不到页面，关闭浏览器调试模式之后，默认会显示一个标准的错误页面，如果要显示自定义的页面，则需要的templates目录下面自定义一个404.html文件。</p><ol><li>url没有配置</li><li>url配置错误</li></ol><p>500：服务器端的错误。</p><ol><li>视图错误</li></ol><p>网站开发完成需要关闭调试模式，在settings.py 文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG = <span class="literal">False</span></span><br><span class="line">ALLOWED_HOST=[<span class="string">"*"</span>]</span><br></pre></td></tr></table></figure><h3 id="5-捕获url参数"><a href="#5-捕获url参数" class="headerlink" title="5.捕获url参数"></a>5.捕获url参数</h3><p>进行url匹配时，把所需要的捕获的部分设置成一个正则表达式组，这样Django框架就会自动把匹配成功后相应组的内容作为参数传递给视图函数。</p><ol><li><p>位置参数</p><ul><li><p>位置参数，参数名可以随意指定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">  path(<span class="string">'index(\d+)'</span>,views.index),          //捕获url参数：位置参数</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关键字参数：在位置参数的基础伤给正则表达式组命名即可。</p><ul><li><p>?P&lt;组名&gt;</p></li><li><p>关键字参数，视图中参数名必须和正则表达式组名一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">  path(<span class="string">'index(?p&lt;num&gt;\d+)'</span>,views.index),          //捕获url参数：关键字参数</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><strong>request就是HttpRequest类型的对象</strong></li><li><strong>request包含浏览器请求的信息</strong></li></ul><h3 id="6-普通登陆案例"><a href="#6-普通登陆案例" class="headerlink" title="6.普通登陆案例"></a>6.普通登陆案例</h3><ul><li><p>显示出登陆页面</p><ul><li><p>设计url,通过浏览器访问 <a href="http://127.0.0.1:8000/login" target="_blank" rel="noopener">http://127.0.0.1:8000/login</a> 的时候显示登陆页面</p></li><li><p>设计url对应的视图函数logjn</p></li><li><p>编写模板文件 login.html</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span> = <span class="string">'POST'</span> <span class="attr">action</span> = <span class="string">'/login_check'</span>&gt;</span>   //提交方式，提交到那个页面</span><br><span class="line">  用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">name</span>=<span class="string">'username'</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'password'</span> <span class="attr">name</span>=<span class="string">'password'</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'submit'</span> <span class="attr">value</span>=<span class="string">'登陆'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- POST：提交的参数请求头。- GET：提交的参数在url中。</code></pre><p>属性：</p><ul><li>path ：一个字符串，表示请求的页面的完整路径，不包含域名和部分参数。</li><li>method  : 一个字符串，表示请求使用的HTTP方法，常用值包括 GET 、POST 。<ul><li>在浏览器中给出地址发请求采用get方式，如超链接。</li><li>在浏览器中点击表单的提交按钮发起请求，如果表单的method设置为post则为post请求。</li></ul></li><li>encoding : 一个字符串，表示提交的数据编码方式。<ul><li>如果为None则表示使用浏览器的默认设置，一般为utf-8.</li><li>这个属性是可写的，可以通过修改它来访问表单数据使用的编码，接下来对属性的任何访问将使用鑫的encoding值。</li></ul></li><li>GET ：QueryDict类型对象，类似与字典，包含get请求方式所有参数。</li><li>POST：QueryDict类型对象，类似于字典，包含post请求方式的所有参数。</li><li>FILES : 一个类似于字典的对象，包含所有上传文件。</li><li>COOKIES ： 一个标准的Python字典，包含所有cookie，键和值都为字符串。</li><li>session : 一个既可以读 又可以写的类似于字典的对象，表示当前的话，只当有Django 启用绘画的支持时才可使用，详情内容见 “状态保持”。</li><li>运行服务器，在浏览器中浏览首页，可以在浏览器“开发者工具”中看到下图：</li></ul><h3 id="7-Ajax"><a href="#7-Ajax" class="headerlink" title="7.Ajax"></a>7.Ajax</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="(1).基本概念"></a>(1).基本概念</h4><p><img src=".%5Cassets%5Cajax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt></p><ol><li><p>点击普通的超链接和手动输入地址。</p></li><li><p>表单提交。</p></li><li><p>通过ajax请求。</p><p> 请求  –&gt; 响应</p></li></ol><p>处理函数</p><ol><li>返回页面 HttpResponse</li><li>重定向 HttpResoonseRedirect</li><li>返回Json数据 JsonResponse</li></ol><p>发起请求后不等结束，程序直接进行的被成为异步</p><p>异步就是发起请求后，代码继续执行不会等回调函数执行，等到服务器返回j’son之后，这个回调函数才会被执行。</p><p>同步ajax请求是按照代码的顺序依次执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//绑定btnAax的click事件</span></span><br><span class="line">$(<span class="string">'#btnAjax'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>)</span><br><span class="line">    .ajax(&#123;</span><br><span class="line">      <span class="string">'url'</span>:<span class="string">'/ajax_handle'</span>,</span><br><span class="line">      <span class="string">'dataType'</span>:<span class="string">'json'</span>,</span><br><span class="line">      <span class="string">'async'</span>:<span class="literal">false</span>,        <span class="comment">//同步的ajax请求</span></span><br><span class="line">    &#125;).success(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//进行处理</span></span><br><span class="line">      alter(<span class="number">2</span>)</span><br><span class="line">      <span class="keyword">if</span> (data.res ==<span class="number">1</span>)&#123;</span><br><span class="line">        $(<span class="string">'#messags'</span>).show().html(‘提示信息)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    alert(<span class="number">3</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-Ajax登陆案例"><a href="#2-Ajax登陆案例" class="headerlink" title="(2).Ajax登陆案例"></a>(2).Ajax登陆案例</h4><p>首先分析出访问地址时候需要携带的参数。</p><p>视图函数处理完成之后，所返回的json的格式。</p><ol><li><p>显示出登陆页面</p><ol><li><p>设计url，通过浏览器访问 <a href="http://127.0.0.1:8000/login_ajax" target="_blank" rel="noopener">http://127.0.0.1:8000/login_ajax</a> 时候显示登陆页面。</p></li><li><p>设计url对应的视图函数 login_ajax</p></li><li><p>编写模板文件 login_ajax.html</p><p>在里面写jquery代码发起ajax请求。</p></li></ol></li><li><p>登陆校验功能</p><ol><li><p>设计url,点击登陆页的登陆按钮发起请求<a href="http://127.0.0.1:8000/login_ajax_check时进行校验。" target="_blank" rel="noopener">http://127.0.0.1:8000/login_ajax_check时进行校验。</a></p></li><li><p>设计url对应的视图函数 login_ajax_check</p><p>接受post提交过来的数据。</p><p>进行登陆校验，并返回json内容。JsonResonse</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&apos;res&apos;:&apos;1&apos;&#125;       //表示登陆成功</span><br><span class="line">&#123;&apos;res&apos;:&apos;0&apos;&#125;       //表示登陆失败</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="8-状态保持"><a href="#8-状态保持" class="headerlink" title="8.状态保持"></a>8.状态保持</h3><p><strong>Http协议是无访问状态的。下一次去访问同一个页面并不知道上一次对这个页面做了什么。</strong></p><h4 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="(1).Cookie"></a>(1).Cookie</h4><p><img src=".%5Cassets%5Ccookie.png" alt></p><p>比如你去卖豆浆，你是浏览器，老板是服务器，你去买豆浆就是一个请求，你请求网站的时候他记不住信息 他记不住你买过豆浆他就给了你一个单子 就是cookie,这个单子交给浏览器 由你来保管下次你再来访问 服务器的时候 你就会把单子给服务器，老板就知道你买过豆浆。</p><p>cookie:是有服务器生成，存储在浏览器的一小段文本信息。</p><p>#####cooie的特点：</p><ol><li><p>以键值对方式进行存储。</p></li><li><p>通过浏览器访问一个网站时，会将浏览器存储的跟网站相关的所有cookie信息发送给网站的服务器。request.COOKIES</p><p>（你去买烧饼，你去买烧饼，你只会把买少烧饼的单子给他 你肯定不会把卖豆浆的单子也起给他）</p></li><li><p>cookie 是基于域名安全的。</p></li><li><p>cookie是有过期时间的，如果不指定，默认关闭浏览器之后 cookie就会过期。</p></li></ol><p>#####注册Cookie</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_cookie</span><span class="params">(request)</span>:</span></span><br><span class="line">  <span class="string">'''设置cookie信息'''</span></span><br><span class="line">  response = HttpResponse(<span class="string">'设置一个cookie'</span>)</span><br><span class="line">  <span class="comment">#设置一个cookie信息名字为 'mum'值为1</span></span><br><span class="line">  response.set_cookie(<span class="string">'num'</span>,<span class="number">1</span>)</span><br><span class="line">  <span class="comment">#返回response</span></span><br><span class="line">  <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>#####获取Cookie</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cookie</span><span class="params">(request)</span>:</span></span><br><span class="line">  <span class="string">'''获取cookie的信息'''</span></span><br><span class="line">  <span class="comment">#取出cookie num的值</span></span><br><span class="line">  num = request.COOKIES[<span class="string">'num'</span>]</span><br><span class="line">  <span class="comment"># 返回 num</span></span><br><span class="line">  <span class="keyword">return</span> HttpResponse(num)</span><br></pre></td></tr></table></figure><h5 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h5><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>max_age=</td><td>设置秒，保存cookie的时候是多少秒过期</td></tr><tr><td>expires=</td><td>设置时间，到达一定时间后过期</td></tr></tbody></table><p>max_age设置cookie两周过期：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.set_cookie(<span class="string">'num'</span>:<span class="number">1</span>,max_age = <span class="number">14</span>*<span class="number">24</span>*<span class="number">3600</span>)</span><br></pre></td></tr></table></figure><p>expires 设置cookie两周过期</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime,timedelta</span><br><span class="line"></span><br><span class="line">response.set_cookie(<span class="string">'num'</span>:<span class="number">1</span>,expires=datetime.now()+timedelta(days=<span class="number">14</span>))</span><br></pre></td></tr></table></figure><p>HttpResponse子类对象：</p><ul><li>HttpResponseRedirect</li><li>JsonResponse</li></ul><h5 id="记住用户案例"><a href="#记住用户案例" class="headerlink" title="记住用户案例"></a>记住用户案例</h5><p>view代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(request)</span>:</span></span><br><span class="line">  <span class="string">'''显示登陆页面'''</span></span><br><span class="line">  <span class="comment">#获取cookie username</span></span><br><span class="line">  <span class="keyword">if</span> <span class="string">'username'</span> <span class="keyword">in</span> request.COOKIES:</span><br><span class="line">    <span class="comment">#获取记住的用户名</span></span><br><span class="line">    username = request.COOKIES[<span class="string">'username'</span>]</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    username = <span class="string">''</span>              <span class="comment">#如果没有返回为空</span></span><br><span class="line">  <span class="keyword">return</span> render(request,<span class="string">'booktest/login.html'</span>,&#123;<span class="string">'username'</span>:username&#125;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_check</span><span class="params">(request)</span>:</span></span><br><span class="line">  <span class="string">'''登陆校验视图'''</span></span><br><span class="line">  <span class="comment">#request.POST 保存post方式提交参数 QueryDict</span></span><br><span class="line">  <span class="comment">#request.GET 保存get方式提交的参数</span></span><br><span class="line">  <span class="comment">#1.获取提交的用户名和密码</span></span><br><span class="line">  username = request.POST.get(<span class="string">'username'</span>)      <span class="comment">#获取用户名   </span></span><br><span class="line">  password = request.POST.get(<span class="string">'password'</span>)<span class="comment">#获取密码</span></span><br><span class="line">  remember = request.POST.get(<span class="string">'remember'</span>)      <span class="comment">#获取是否保存用户密码</span></span><br><span class="line">  <span class="comment">#2.进行登陆的校验</span></span><br><span class="line">  <span class="comment">#实际开发：根据用户名和密码查找数据库</span></span><br><span class="line">  <span class="comment">#模拟：smart 123</span></span><br><span class="line">  <span class="keyword">if</span> username ==<span class="string">'smart'</span> <span class="keyword">and</span> password ==<span class="string">'123'</span>:</span><br><span class="line">    <span class="comment">#用户名密码正确跳转到首页</span></span><br><span class="line">    response = redirect(<span class="string">'/index'</span>)</span><br><span class="line">    <span class="comment">#判断是否需要记住用户名</span></span><br><span class="line">    <span class="keyword">if</span> remember ==<span class="string">'on'</span>:           <span class="comment">#点击事件选中返回为’on‘ 未选中返回’None‘</span></span><br><span class="line">      <span class="comment">#设置cookie username 过期时间为一周</span></span><br><span class="line">      response.set_cookie(<span class="string">'username'</span>:username,max_age=<span class="number">7</span>*<span class="number">24</span>*<span class="number">3600</span>)</span><br><span class="line">  <span class="keyword">return</span> response</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#用户名密码错误跳转到首页</span></span><br><span class="line">  <span class="keyword">return</span> redirect(<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure><p>template/login.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  POST：提交的参数请求头，数据安全性要去比较高的时候用post.</span><br><span class="line">  GET:提交参数在url.</span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span> = <span class="string">'post'</span> <span class="attr">action</span>=<span class="string">'logjin_check'</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span> <span class="attr">name</span> =<span class="string">'username'</span> <span class="attr">value</span>=<span class="string">'&#123;&#123;username&#125;&#125;'</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'password'</span> <span class="attr">name</span>=<span class="string">'pawword'</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'checkbox'</span> <span class="attr">name</span>=<span class="string">'remember'</span> &gt;</span>记住用户名<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'submit'</span> <span class="attr">value</span> = <span class="string">'登录'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>####(2).Session</p><p><img src=".%5Cassets%5Csession.png" alt></p><p>session 存储在服务器端。</p><h5 id="session的特点："><a href="#session的特点：" class="headerlink" title="session的特点："></a>session的特点：</h5><ol><li><p>session是以键值对进行存储的。</p></li><li><p>session依赖于cookie。唯一的标识码保存在sessionid cookie 中。</p><ul><li><p>问：所有请求者的session 都会存储在服务器中，服务器如何区分请求者和session的数据对应关系呢？</p></li><li><p>答：在使用session后，会在Cookie中存储一条sessionid的数据，每次请求时浏览器都会将这个数据发给服务器，服务器接收sessionid后，会根据这个值找到这个请求者的session.</p></li><li><p>结果如果想使用session，浏览器必须支持cookie，否则就无法使用session了。</p></li><li><p>存储session时，键与Cookie中的sessionid相同，值是开发人员设置的键值对信息进行了base64编码，过期时间有开发人员设置。</p></li></ul></li><li><p>session 也是有过期时间的，如果不指定，默认就会两周过期。</p></li></ol><h5 id="对象及方法"><a href="#对象及方法" class="headerlink" title="对象及方法"></a>对象及方法</h5><p>通过HttpRequest对象的session属性进行会话的读写操作。</p><ol><li><p>以键值对的格式写session.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.session[<span class="string">'键'</span>] = 值</span><br></pre></td></tr></table></figure></li><li><p>根据键获取值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.session.get[<span class="string">'键'</span>,默认值]</span><br></pre></td></tr></table></figure></li><li><p>清除所有session,在存储中删除部分值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.session.clear()</span><br></pre></td></tr></table></figure></li><li><p>清除session数据，在存储中删除session的整条数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.session.flush()</span><br></pre></td></tr></table></figure></li><li><p>删除session中指定键及值，在存储中只删除某个键及对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> request.session[<span class="string">'键'</span>]</span><br></pre></td></tr></table></figure></li><li><p>设置会话超时时间，如果没有指定过期时间则两星期后过期。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.session.set_expiry(value)</span><br></pre></td></tr></table></figure><ul><li>如果value是一个整数，会话的session_id cookie 将在value秒没有活动后过期。</li><li>如果value为0，那么用户的session_id cookie 将在用户的浏览器关闭时过期。</li><li>如果value为None，那么会话的session_id cookie 两周之后过期。</li></ul></li></ol><h5 id="设置session"><a href="#设置session" class="headerlink" title="设置session"></a>设置session</h5><p>设置session : request.session[‘username’]=’root’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_session</span><span class="params">(request)</span>:</span></span><br><span class="line">  <span class="string">'''设置session'''</span></span><br><span class="line">  request.session[<span class="string">'username'</span>] = <span class="string">'root'</span></span><br><span class="line">  request.session[<span class="string">'password'</span>] = <span class="string">'123456'</span></span><br><span class="line">  <span class="keyword">return</span> HttpResponse(<span class="string">'设置session'</span>)</span><br></pre></td></tr></table></figure><h5 id="获取session"><a href="#获取session" class="headerlink" title="获取session"></a>获取session</h5><p>获取session：request.session[‘username’]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_session</span><span class="params">(request)</span>:</span></span><br><span class="line">  <span class="string">'''获取session'''</span></span><br><span class="line">  username = request.session[<span class="string">'username'</span>]</span><br><span class="line">  password = request.session[<span class="string">'password'</span>]</span><br><span class="line">  <span class="keyword">return</span> HttpResponse(username+<span class="string">":"</span>+password)     <span class="comment">#session保存进去什么字符取出来也是什么字符</span></span><br></pre></td></tr></table></figure><h5 id="清除session"><a href="#清除session" class="headerlink" title="清除session"></a>清除session</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clear_session</span><span class="params">(request)</span>:</span></span><br><span class="line">  request.session.clear()        //清除部分数据通过 base64解码后看到结果是清除了 字典中的数据</span><br><span class="line">  request.session.clush()        //清除所有关于session的数据。</span><br><span class="line">  <span class="keyword">del</span> request.session[<span class="string">'键'</span>]     //session里面存储多个键值对，可以指定删除某一个。</span><br><span class="line">  <span class="keyword">return</span> HttpResponse(<span class="string">'清除成功！！'</span>)</span><br></pre></td></tr></table></figure><p>#####session过期时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_session</span><span class="params">(request)</span>:</span></span><br><span class="line">  <span class="string">'''设置session'''</span></span><br><span class="line">  request.session[<span class="string">'username'</span>] = <span class="string">'root'</span></span><br><span class="line">  request.session[<span class="string">'password'</span>] = <span class="string">'123456'</span></span><br><span class="line">  </span><br><span class="line">  request.session.set_expiry(<span class="number">5</span>)       // 以秒为单位 设置session过期时间为<span class="number">5</span>秒</span><br><span class="line">  <span class="keyword">return</span> HttpResponse(<span class="string">'设置session'</span>)</span><br></pre></td></tr></table></figure><h4 id="3-cookie和session的应用场景"><a href="#3-cookie和session的应用场景" class="headerlink" title="(3).cookie和session的应用场景"></a>(3).cookie和session的应用场景</h4><p>Cookie:</p><ul><li><p>记住用户名。</p></li><li><p>保存在浏览器端。</p></li><li><p>对于安全性要求不高的数据可以使用cookie进行保存。</p></li></ul><p>session:</p><ul><li><p>记住用户的登录状态</p></li><li><p>保存在服务器端</p></li><li><p>对于安全性要求比较高的，比如用户银行卡等信息使用session进行保存。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django配置</title>
      <link href="/2016/06/07/4.Dhabgi-Views/"/>
      <url>/2016/06/07/4.Dhabgi-Views/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 开启项目：django-admin startproject pro</span><br><span class="line"></span><br><span class="line">* 开启子应用：cd pro  python manage.py startapp pro_app</span><br><span class="line"></span><br><span class="line">  * 业务分化，方便团队合作</span><br><span class="line">  * APP：承担不同功能，</span><br><span class="line"></span><br><span class="line">* urls.：配置一个视图函数路由，</span><br><span class="line"></span><br><span class="line">  * pro/urls.py</span><br><span class="line"></span><br><span class="line">* models.：使用orm语法创建模型类</span><br><span class="line"></span><br><span class="line">  * 对于模型类的操作就是在操作表</span><br><span class="line">  * 在settings-&gt;INSTALLL_APPS-&gt;pro_app，记得注册APP在配置中</span><br><span class="line">  * python manage.py makemigrations 查找数据库变更，寻找差异，生成迁移文件</span><br><span class="line">  * python manage.py migrate 根据迁移文件生成SQL</span><br><span class="line"></span><br><span class="line">* admin.：能展示，管理当前APP所使用的数据表</span><br><span class="line"></span><br><span class="line">  * admin.py：admin.site.register(models.Studetn)</span><br><span class="line">  * verbose_name：设置字段的可读名称</span><br><span class="line"></span><br><span class="line">  * `__str__`(self) ：设置当前一条数据的可读名称</span><br><span class="line"></span><br><span class="line">* views.：主要编写视图代码</span><br><span class="line"></span><br><span class="line">  * 响应request</span><br><span class="line">  * 返回response</span><br><span class="line">    * HttpResponse() # 返回普通字符串</span><br><span class="line">    * render(request, &apos;index.html&apos;, locals()) # 渲染页面 并返回、</span><br><span class="line">    * redirect(to, permanent=False)：重定向，搜索引擎，用户</span><br><span class="line">      * permanent：当该参数为False时，使用302，当该参数为True时，使用301</span><br><span class="line">      * 302：临时重定向</span><br><span class="line">      * 301：永久重定向</span><br><span class="line">      * a - &gt; b</span><br><span class="line">      * show -&gt; sh</span><br><span class="line"></span><br><span class="line">* template：render模板页面</span><br><span class="line"></span><br><span class="line">  * 配置模板页面保存路径</span><br><span class="line">  * `settings-&gt;TEMPLATES-&gt;DIRS-&gt;[os.path.join(BASE_DIR,&apos;template&apos;)]`</span><br><span class="line">  * 模板变量：&#123;&#123; var &#125;&#125;</span><br><span class="line">  * 模板标签：&#123;% for %&#125;</span><br><span class="line">  * tempalte &gt; jinja2</span><br><span class="line"></span><br><span class="line">* `static：静态资源`</span><br><span class="line">* STATICFILES_DIRS = ()</span><br><span class="line">  * 确定当前django项目</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Views</span><br><span class="line"></span><br><span class="line">* 视图层</span><br><span class="line">* 编写具体的逻辑代码</span><br><span class="line"></span><br><span class="line">#### request</span><br><span class="line"></span><br><span class="line">* request.method  # 判断当前用户访问方式</span><br><span class="line">  * request.method == &apos;GET&apos;</span><br><span class="line">  * request.method  == &apos;POST&apos;</span><br><span class="line">* request.POST：获取POST形式提交的数据</span><br><span class="line">  * 获取表单多值时候，不能使用get函数</span><br><span class="line">  * 我们需要使用getlist</span><br><span class="line">  * 解析到的数据类型为：application/x-www-form-urlencoded，form-data</span><br><span class="line">* request.GET：获取GET形式提交的数据</span><br><span class="line">  * get形式提交的数据</span><br><span class="line">* request.META：访问的头部信息</span><br><span class="line">  * REMOTE_ADDR：获取访问者的IP地址</span><br><span class="line"></span><br><span class="line">* request.FILES</span><br><span class="line"></span><br><span class="line">### 学生管理系统</span><br><span class="line"></span><br><span class="line">* centos：runserver 0.0.0.0:8000</span><br><span class="line">  * `systemctl stop firewalld`</span><br><span class="line"></span><br><span class="line">* 记录学生信息</span><br><span class="line">  * 存储、建表：姓名，年龄，爱好，IP地址、头像</span><br><span class="line">  * request.META.get(&apos;REMOTE_ADDR&apos;)</span><br><span class="line">* 逻辑功能</span><br><span class="line">  * 1：页面展示所有学生</span><br><span class="line">  * 2：提供表单页面，以供学生填写</span><br><span class="line">    * 视图函数处理表单接收到的数据</span><br><span class="line">    * 首先判断IP，是否已经出现在数据库中</span><br><span class="line">      * 如果出现过，不允许表单值存入数据库，重定向到展示页面</span><br><span class="line">      * 没有出现过，可以表单存入数据库，并且重定向到展示页面</span><br><span class="line">  * 列表页，详情页</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django其他技术</title>
      <link href="/2016/06/07/5.Django-%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/"/>
      <url>/2016/06/07/5.Django-%E5%85%B6%E4%BB%96%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="一-静态文件"><a href="#一-静态文件" class="headerlink" title="一.静态文件"></a>一.静态文件</h1><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h2><p>在Django 如果要使用静态文件需要建立一个静态文件夹。</p><h1 id="二-中间件"><a href="#二-中间件" class="headerlink" title="二.中间件"></a>二.中间件</h1><p><strong>中间件函数是Django框架给我们预留的函数接口，让我们可以干预请求和应答过程。</strong></p><h2 id="1-获取浏览器端的IP地址"><a href="#1-获取浏览器端的IP地址" class="headerlink" title="1.获取浏览器端的IP地址"></a>1.获取浏览器端的IP地址</h2><p>使用request对象META属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip = request.META[<span class="string">'REMOTE_ADDR'</span>]</span><br></pre></td></tr></table></figure><h3 id="获取访问者IP"><a href="#获取访问者IP" class="headerlink" title="获取访问者IP"></a>获取访问者IP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">'''首页'''</span></span><br><span class="line">    <span class="comment">#获取浏览器端的ip地址</span></span><br><span class="line">    user_ip request.META[<span class="string">'REMOTE_ADDR'</span>]</span><br><span class="line">    print(user_ip)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'booktest/index.html'</span>)</span><br></pre></td></tr></table></figure><h3 id="阻止某IP访问"><a href="#阻止某IP访问" class="headerlink" title="阻止某IP访问"></a>阻止某IP访问</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXCLUDE_IPS = [<span class="string">'172.16.19.26'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">'''首页'''</span></span><br><span class="line">    <span class="comment">#获取浏览器端的ip地址</span></span><br><span class="line">    user_ip request.META[<span class="string">'REMOTE_ADDR'</span>]</span><br><span class="line">    <span class="keyword">if</span> user_ip <span class="keyword">in</span> EXCLUDE_IPS:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'禁止访问'</span>)</span><br><span class="line">    print(user_ip)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'booktest/index.html'</span>)</span><br></pre></td></tr></table></figure><h3 id="阻止IP访问装饰器"><a href="#阻止IP访问装饰器" class="headerlink" title="阻止IP访问装饰器"></a>阻止IP访问装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line">EXCLUDE_IPS = [<span class="string">'172.16.19.26'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocked_ips</span><span class="params">(view_func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(request, **view_args, **view_kwargs)</span>:</span></span><br><span class="line">        user_ip request.META[<span class="string">'REMOTE_ADDR'</span>]</span><br><span class="line">    <span class="keyword">if</span> user_ip <span class="keyword">in</span> EXCLUDE_IPS:</span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">'禁止访问'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> view_func(request, *views_args, **view_kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><h2 id="2-使用中间件"><a href="#2-使用中间件" class="headerlink" title="2.使用中间件"></a>2.使用中间件</h2><p>中间件是每个函数调用之前自动会执行的。</p><ol><li><p>新建一个middleware.py文件。 </p><ul><li><p>app文件下创建这个文件。</p></li><li><p>名字可以改变但是一般都叫做这middleware</p></li></ul></li><li><p>打开middleware.py 创建中间件函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockedIPSMiddleware</span><span class="params">(object)</span>:</span>  <span class="comment">#中间件类</span></span><br><span class="line">    EXCLUDE_IPS = [<span class="string">'172.16.19.26'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self,request, view_func , *view_args, **view_kwargs)</span>:</span>   <span class="comment">#中间件函数</span></span><br><span class="line">        <span class="string">'''视图函数调用之前会调用'''</span></span><br><span class="line">        user_ip request.META[<span class="string">'REMOTE_ADDR'</span>]</span><br><span class="line">            <span class="keyword">if</span> user_ip <span class="keyword">in</span> BlockedIPSMiddleware.EXCLUDE_IPS:</span><br><span class="line">                <span class="keyword">return</span> HttpResponse(<span class="string">'禁止访问'</span>)</span><br></pre></td></tr></table></figure></li><li><p>在setting 的 MIDDLEWARE 里面注册中间件类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">    <span class="string">'booktest.middleware.BlockedIPSMiddleware'</span>,       <span class="comment">#注册中间件类</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><h3 id="在类中定义中间件预留函数"><a href="#在类中定义中间件预留函数" class="headerlink" title="在类中定义中间件预留函数"></a>在类中定义中间件预留函数</h3>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__init__:服务器响应第一个请求的时候调用。</span><br><span class="line">process_request:是在产生request对象，进行url匹配之前调用。</span><br><span class="line">process_view：是在url匹配之后，调用视图函数之前。</span><br><span class="line">process_response：视图函数调用之后，内容返回给浏览器之前。</span><br><span class="line">process_exception:视图函数出现异常，会调用这个函数。</span><br><span class="line">如果注册多个中间件包含process_exception函数的时候，调用的顺序跟注册的顺序相反的。</span><br></pre></td></tr></table></figure><p>   <img src=".%5Cassets%5CDjango%E4%B8%AD%E9%97%B4%E4%BB%B6.png" alt></p><h3 id="中间件函数执行过程、"><a href="#中间件函数执行过程、" class="headerlink" title="中间件函数执行过程、"></a>中间件函数执行过程、</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''中间件类'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''服务器重启之后，接收第一个请求时调用'''</span></span><br><span class="line">        print(<span class="string">'----init------'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''产生request对象之后，url匹配之前调用'''</span></span><br><span class="line">        print(<span class="string">'----process_request------'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_view</span><span class="params">(self,qequest, view_func, *view_args, **view_kwargs)</span>:</span></span><br><span class="line">        <span class="string">'''url匹配之后，视图函数调用之前调用'''</span></span><br><span class="line">        print(<span class="string">'----process_view------'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_response</span><span class="params">(self,qequest, response)</span>:</span></span><br><span class="line">        <span class="string">'''url匹配之后，视图函数调用之前调用'''</span></span><br><span class="line">        print(<span class="string">'----process_response------'</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionTestMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_exption</span><span class="params">(self, request ,exception)</span>:</span></span><br><span class="line">        <span class="string">'''视图函数发生异常时候调用'''</span></span><br><span class="line">        print(<span class="string">'----process_exportion------'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django上传图片</title>
      <link href="/2016/06/07/6.Django-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2016/06/07/6.Django-%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h1><h2 id="1-配置上传文件的保存目录"><a href="#1-配置上传文件的保存目录" class="headerlink" title="1.配置上传文件的保存目录"></a>1.配置上传文件的保存目录</h2><ul><li>新建上传文件的保存目录</li><li>配置上传文件的保存目录</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置上传文件的保存路径</span></span><br><span class="line">  MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">'static/media'</span>)</span><br></pre></td></tr></table></figure><h2 id="2-后台管理页面上传图片"><a href="#2-后台管理页面上传图片" class="headerlink" title="2.后台管理页面上传图片"></a>2.后台管理页面上传图片</h2><ol><li><p>设计模型类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PicTest</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="string">'''上传图片'''</span></span><br><span class="line">    good_pic = models.ImageFiled(upload_to = <span class="string">"booktest"</span>)    <span class="comment">#upload_to 指定你的图片上传到哪个目录，这个目录相对于media</span></span><br></pre></td></tr></table></figure><p>ImageFiled  上传的必须是一个有效的图片否则报错</p></li></ol><h2 id="3-用户自定义页面上传图片"><a href="#3-用户自定义页面上传图片" class="headerlink" title="3.用户自定义页面上传图片"></a>3.用户自定义页面上传图片</h2><ol><li><p>定义用户上传图片页面并显示，是一个自定义表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/up_load/"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">&#123; csrf_token &#125;           //放跨站攻击</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'file'</span> <span class="attr">name</span>=<span class="string">'pic'</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'submit'</span> <span class="attr">value</span>=<span class="string">'上传'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django路由</title>
      <link href="/2016/06/07/5.Django-urls/"/>
      <url>/2016/06/07/5.Django-urls/</url>
      
        <content type="html"><![CDATA[<h2 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">'路由映射字符串/'</span>, views.index)</span><br><span class="line">path(<span class="string">'abc/'</span>, views.index)</span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><blockquote><p>将参数做到连接里</p></blockquote><ul><li><p>路由命名传参：</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path(<span class="string">'index/&lt;str:name&gt;/&lt;int:age&gt;/'</span>, views.index),</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re_path(<span class="string">r'^index/(?P&lt;name&gt;[a-z]&#123;3&#125;)/(?P&lt;age&gt;\d&#123;1,2&#125;)/'</span>,views.index ),</span><br></pre></td></tr></table></figure></li><li><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?P&lt;id&gt;\w+)/</span><br></pre></td></tr></table></figure></li></ul></li><li><p>路由非命名传参：更灵活，但是必须对应参数位置</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re_path(<span class="string">r'^index/([a-z]&#123;3&#125;)/(\d&#123;1,2&#125;)/'</span>,views.index)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>空白符号：<code>\r \n \v \t \b</code></p></li></ul><h2 id="路由分发"><a href="#路由分发" class="headerlink" title="路由分发"></a>路由分发</h2><ul><li><p>APP：业务分化，方便团队合作</p></li><li><p>主路由文件：只做分发</p></li><li><p>子路由文件：需要我们手动创建，实现视图映射</p></li><li><p>主路由-》子路由-》分发</p></li></ul><h2 id="路由命名"><a href="#路由命名" class="headerlink" title="路由命名"></a>路由命名</h2><blockquote><p>当路由修改时，如果HTML页面跳转与视图函数重定向使用的是原始的连接内容，那么都需要更改</p><p>耦合性太强</p><p>现在通过路由反向解析，可以解决这个问题</p></blockquote><ul><li><p>path(‘’, views, name=)</p></li><li><p>html:</p><ul><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">href=&#123;% url 'url_name' 'args1' 'args2'... %&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>views:</p><ul><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,redirect,reverse</span><br><span class="line">redirect(reverse(<span class="string">'url_name'</span>,args=(<span class="string">'args1'</span>,<span class="string">'args2'</span>)))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li><p>在路由文件：子路由</p><ul><li>app_name 全局变量，一般使用app名作为命名空间名</li></ul></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">href=&#123;% url 'app_name:url_name' 'args1' 'args2'... %&#125;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render,redirect,reverse</span><br><span class="line">redirect(reverse(<span class="string">'app_name:url_name'</span>,args=(<span class="string">'args1'</span>,<span class="string">'args2'</span>)))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django分页</title>
      <link href="/2016/06/07/7.Django-%E5%88%86%E9%A1%B5/"/>
      <url>/2016/06/07/7.Django-%E5%88%86%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h1><p>导包：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator</span><br></pre></td></tr></table></figure><p>paginator对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paginator = Paginator(areas,<span class="number">10</span>) <span class="comment">#按照每页十条数据进行分页</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tername = models.User.objects.all()   //获取查询集</span><br><span class="line">p = Paginator(tername,3)   //第一个参数查询集，第二个参数一页展示几条数据</span><br><span class="line">if pindex ==&apos;&apos;:          //判断如果pindex为空</span><br><span class="line">   pindex =1             //默认为1</span><br><span class="line">else:                       //如果不为空</span><br><span class="line">   pindex = int(pindex)       //我把它转为int类型并重新赋值给他</span><br><span class="line">page = p.page(pindex)      //获取p里面的 page(展示那一页)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;%for a in page%&#125;             //循环查询机</span><br><span class="line">&#123;&#123;a.name&#125;&#125;               //取name字段</span><br><span class="line">&#123;%endfor%&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;%for a in page.paginator.page_range%&#125;         //获取所有页数</span><br><span class="line">&lt;a href=&apos;/regrate&#123;&#123;a&#125;&#125;/&apos;&gt;&#123;&#123;a&#125;&#125;&lt;/a&gt;         //遍历给a标签</span><br><span class="line">&#123;%endfor%&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-数据库关系</title>
      <link href="/2016/06/07/9.Django-Model-Rel-2/"/>
      <url>/2016/06/07/9.Django-Model-Rel-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一对一关联反向查询"><a href="#一对一关联反向查询" class="headerlink" title="一对一关联反向查询"></a>一对一关联反向查询</h2><ul><li><p>查询：</p><ul><li><p>表层面：</p><ul><li><p>查询所有是蝴蝶的毛毛虫</p></li><li><p>MaoMao.objects.filter(hudie__wings__gt=0)：反向查询</p><ul><li>用的是隐藏起来哪个关联表字段进行查询 就是反向查询</li></ul></li><li><p>Hudie.maomao : 正向</p></li></ul></li><li><p>数据层面</p><ul><li>m1 = MaoMaoobjects.get()</li><li>m1.hudie<ul><li>hudie不是一条m1的字段，他是django做出来隐藏的</li></ul></li></ul></li></ul></li></ul><h2 id="多对一查询"><a href="#多对一查询" class="headerlink" title="多对一查询"></a>多对一查询</h2><ul><li>查询一个球队的所有球员<ul><li>数据层面<ul><li>t1.player_set.all() 反向</li><li>_set == models.objects</li></ul></li><li>表层面：<ul><li>Team.objects.filter(player__name__startswith=’刘’)  反向</li><li>Player.objects.filter(team__name=’恒中’) 正向</li></ul></li></ul></li><li>修改<ul><li>单独修改简单：直接字段赋值，save即可</li><li>批量修改<ul><li>set.update(team=t2) 直接为这些set数据 批量修改</li><li>直接立竿见影到数据库，不需要save</li></ul></li></ul></li><li>删除：<ul><li>on_delete<ul><li>models.CASCADE：球队删除，球员也跟着消失</li><li>models.SET_NULL：球队删除，球员外键为null，数据还在<ul><li>null=True，</li></ul></li></ul></li></ul></li><li>我是偶像</li><li>你们是粉丝</li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul><li>学生表，老师表</li><li>三个多对一例子：<ul><li>增删改查</li><li>反向查询的语句：表层面、数据层面 反向查询 念出来语句</li></ul></li><li><code>在django中三种实现原生SQL的方式</code><ul><li>excute</li><li>raw</li><li>curser.excute</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-数据库配置</title>
      <link href="/2016/06/07/7.Django-Models/"/>
      <url>/2016/06/07/7.Django-Models/</url>
      
        <content type="html"><![CDATA[<h2 id="配置数据库为MYsql"><a href="#配置数据库为MYsql" class="headerlink" title="配置数据库为MYsql"></a>配置数据库为MYsql</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.sqlite3'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: os.path.join(BASE_DIR, <span class="string">'db.sqlite3'</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">    <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>, <span class="comment"># 数据库引擎</span></span><br><span class="line">    <span class="string">'NAME'</span>: <span class="string">"django_data"</span>, <span class="comment"># 使用的库名</span></span><br><span class="line">    <span class="string">"USER"</span>: <span class="string">"root"</span>, <span class="comment"># 用户名</span></span><br><span class="line">    <span class="string">"PASSWORD"</span>: <span class="string">"woaini21g"</span>, <span class="comment"># 数据库密码</span></span><br><span class="line">    <span class="string">"HOST"</span>: <span class="string">"localhost"</span>, <span class="comment"># 数据库主机地址</span></span><br><span class="line">    <span class="string">"PORT"</span>: <span class="string">"3306"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="python-manage-py-shell"><a href="#python-manage-py-shell" class="headerlink" title="python manage.py shell"></a>python manage.py shell</h2><blockquote><p> 开启一个包含当前项目所有环境的命令行工具</p></blockquote><ul><li>p1 = models.Person.objects.create(name=’张三’)<ul><li>直接立竿见影创建在数据库</li></ul></li><li>p1 = models.Person(name=’李四’)<ul><li>p1.age = 17</li><li>p1.save()</li></ul></li></ul><h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><ul><li>隐含了一个继承关系</li><li>增加：<ul><li>一对一关系在创建时</li><li>先创建一个被关联表的数据</li><li>people = 具体的people数据</li></ul></li><li>删除：<ul><li>删除people数据那么father也消失</li><li>如果只是删除father数据，那么people不会影响</li></ul></li><li>改：<ul><li>获取到某个father对象</li><li>f1.people = p2 给关联字段重新赋值一个新的people数据</li><li>f1.save() 这样就可以实现修改，类似过户</li></ul></li><li>查：<ul><li>father.babe</li><li>father.people.name</li><li>Father.objects.filter(people__name=’张三’)  表的关联查询</li></ul></li></ul><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul><li>pip3 install memcached<ul><li>python连接mem的需要的模块</li></ul></li><li>apt-get install memcached<ul><li>linux安装命令</li></ul></li><li>写三个一对一关系模型<ul><li>并且分别实现增删改查，要求记录在比记录把具体代码</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-Jinja2模板</title>
      <link href="/2016/06/07/Django-Jinja2%E6%A8%A1%E6%9D%BF/"/>
      <url>/2016/06/07/Django-Jinja2%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="Jinja2模板的中文文档"><a href="#Jinja2模板的中文文档" class="headerlink" title="Jinja2模板的中文文档"></a>Jinja2模板的中文文档</h2><p><a href="http://docs.jinkan.org/docs/jinja2/" target="_blank" rel="noopener">http://docs.jinkan.org/docs/jinja2/</a></p><h2 id="Jinja2模板的使用语法"><a href="#Jinja2模板的使用语法" class="headerlink" title="Jinja2模板的使用语法"></a>Jinja2模板的使用语法</h2><h3 id="变量表示"><a href="#变量表示" class="headerlink" title="- 变量表示"></a>- 变量表示</h3><ul><li>应用把变量传递到模板，你可能在模板中弄混。变量上面也可以有你能访问的属性或元 素。变量看起来是什么，完全取决于应用提供了什么。</li><li>你可以使用点（ <code>.</code> ）来访问变量的属性，作为替代，也可以使用所谓的“下标”语 法（ <code>[]</code>）。下面的几行效果是一样的:</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; foo.bar &#125;&#125;             </span><br><span class="line">&#123;&#123; foo['bar'] &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>知晓花括号 <em>不是</em> 变量的一部分，而是打印语句的一部分是重要的。如果你访问标签 里的不带括号的变量。</li><li>如果变量或属性不存在，会返回一个未定义值。你可以对这类值做什么取决于应用的配 置，默认的行为是它如果被打印，其求值为一个空字符串，并且你可以迭代它，但其它 操作会失败。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">实现</span><br><span class="line">为方便起见，Jinja2 中 foo.bar 在 Python 层中做下面的事情:</span><br><span class="line"></span><br><span class="line">- 检查 foo 上是否有一个名为 bar 的属性。</span><br><span class="line">- 如果没有，检查 foo 中是否有一个 &apos;bar&apos; 项 。</span><br><span class="line">- 如果没有，返回一个未定义对象。</span><br><span class="line">foo[&apos;bar&apos;] 的方式相反，只在顺序上有细小差异:</span><br><span class="line"></span><br><span class="line">- 检查在 foo 中是否有一个 &apos;bar&apos; 项。</span><br><span class="line">- 如果没有，检查 foo 上是否有一个名为 bar 的属性。</span><br><span class="line">- 如果没有，返回一个未定义对象。</span><br><span class="line">如果一个对象有同名的项和属性，这很重要。此外，有一个 attr() 过滤 器，它只查找属性。</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="- for循环"></a>- for循环</h3><ul><li>遍历列表中的每一个选项。例如，要显示一个由 users` 变量提供的用户列表:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;Members&lt;/h1&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&#123;% for user in users %&#125;</span><br><span class="line">  &lt;li&gt;&#123;&#123; user.username|e &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><ul><li>因为模板中的变量保留它们的对象属性，可以迭代像 dict 的容器:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">&#123;% for key, value in my_dict.iteritems() %&#125;</span><br><span class="line">    &lt;dt&gt;&#123;&#123; key|e &#125;&#125;&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;&#123;&#123; value|e &#125;&#125;&lt;/dd&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><ul><li>注意无论如何字典通常是无序的，所以你可能需要把它作为一个已排序的列表传入 到模板或使用 dictsort 过滤器。</li><li>在一个 for 循环块中你可以访问这些特殊的变量:</li></ul><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>loop.index</td><td>当循环迭代的次数（从1开始）</td></tr><tr><td>loop.index0</td><td>当循环迭代的次数(从0开始)</td></tr><tr><td>loop.revindex</td><td>到循环结束需要迭代的次数（从1开始）</td></tr><tr><td>loop.revindex0</td><td>到循环结束需要迭代的次数（从0开始）</td></tr><tr><td>loop.first</td><td>如果第一次迭代，为True</td></tr><tr><td>loop.lost</td><td>如果最后一次迭代，为True</td></tr><tr><td>loop.length</td><td>序列中的项目数</td></tr><tr><td>loop.cycle</td><td>在一串序列间期取值的辅助函数。见下面的解释</td></tr></tbody></table><ul><li>在 for 循环中，可以使用特殊的 loop.cycle 辅助函数，伴随循环在一个字符串/变 量列表中周期取值:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for row in rows %&#125;</span><br><span class="line">    &lt;li class=&quot;&#123;&#123; loop.cycle(&apos;odd&apos;, &apos;even&apos;) &#125;&#125;&quot;&gt;&#123;&#123; row &#125;&#125;&lt;/li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django知识点综合</title>
      <link href="/2016/06/07/Django%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2016/06/07/Django%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MVC框架"><a href="#1-MVC框架" class="headerlink" title="1.MVC框架"></a>1.MVC框架</h2><p>MVC的核心思想：<strong>解耦</strong> </p><p>MVC框架里面的三个模块：</p><ul><li>M：Model模型，和数据库进行交互。</li><li>V：View视图，产生HTML页面。</li><li>C：Controller控制器，接收请求，进行处理，与M和V进行交互，返回应答。</li></ul><h2 id="2-MVT"><a href="#2-MVT" class="headerlink" title="2.MVT"></a>2.MVT</h2><ul><li>M：Model模型。和MVC中的M功能相同，和数据库进行交互。</li><li>V：View视图。和MVC中C功能相同，接收请求，进行处理，与M和T进行交互，返回应答。</li><li>T：Template,模板。和MVC中V功能相同，产生HTML页面。</li></ul><h2 id="3-ORM"><a href="#3-ORM" class="headerlink" title="3.ORM"></a>3.ORM</h2><p>ORM 可以通过类和对象去操作他对应的表，不需要sql语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object:对象 - 类</span><br><span class="line">Mapping:映射</span><br><span class="line">Relations:关系，关系数据库中的表</span><br></pre></td></tr></table></figure><h2 id="4-F对象"><a href="#4-F对象" class="headerlink" title="4.F对象"></a>4.F对象</h2><p>作用：用于类属性之间的比较。</p><p>解释F：之前我们的查询都是对一个值进行比较，而F对象适用于跟一个 属性之间进行比较。</p><p>使用之前需要导入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br></pre></td></tr></table></figure><p>例：查询阅读量大于评论量图书的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用F把表内字段 包起来就行了。</span><br><span class="line">BookInfo.objects.filter(bread__gt = F( <span class="string">"bcomment"</span> ))</span><br></pre></td></tr></table></figure><p>例：查询图书阅读量大于2倍评论量的图书信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接在后面写 * <span class="number">2</span> 就OK</span><br><span class="line">BookInfo.objects.filter(bread__gt = F( <span class="string">"bcomment"</span> )*<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="5-Q对象"><a href="#5-Q对象" class="headerlink" title="5.Q对象"></a>5.Q对象</h2><p><strong>作用：用于查询是条件之间的逻辑。and or not ,可以对Q对象进行 &amp;|~ 操作。</strong></p><p>使用之前需要先导入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>Q</strong></th><th><strong>所查询的对象需要被Q()包含</strong></th></tr></thead><tbody><tr><td><strong>|</strong></td><td><strong>逻辑或</strong></td></tr><tr><td><strong>&amp;</strong></td><td><strong>和逻辑与</strong></td></tr><tr><td><strong>~</strong></td><td><strong>逻辑非</strong></td></tr></tbody></table><p>例：查询id大于3且阅读量大于30的图书信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">普通方法  两个条件是逻辑与的关系。</span><br><span class="line">BookInfo.objects.filter( id__gt=<span class="number">3</span> , bread__gt=<span class="number">30</span> )</span><br><span class="line"></span><br><span class="line">Q对象方法 要被查询的字段需要被Q()包含  &amp;代表逻辑与</span><br><span class="line">BookInfo.objects.filter( Q(id__gt=<span class="number">3</span>) &amp; Q(bread__gt=<span class="number">30</span>) )</span><br></pre></td></tr></table></figure><p>例：查询id大于3或者阅读量大于30的图书信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| 是逻辑或  用它连接Q的条件。</span><br><span class="line">BookInfo.objects.filter( Q(id__gt=<span class="number">3</span>) | Q(bread__gt=<span class="number">30</span>) )</span><br></pre></td></tr></table></figure><p>例：查询id不等于3的图书信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ 不等于的意思，</span><br><span class="line">BookInfo.objects.filter(~ Q(id=<span class="number">3</span>) )</span><br></pre></td></tr></table></figure><h2 id="6-查询相关函数"><a href="#6-查询相关函数" class="headerlink" title="6.查询相关函数"></a>6.查询相关函数</h2><ul><li><p>get:返回一个且只能有一条数据，返回值是一个对象，参数可以写查询条件。</p></li><li><p>all:返回模型类对应表的所有数据，返回值是QuerySet.</p></li><li><p>filter:返回满足套件的数据，返回值是QuerySet,参数可以写查询条件。</p></li><li><p>exclude:返回不满足条件的数据，返回值是QuerySer，参数可以写查询条件。</p></li><li><p>order_by:对查询结果进行排序返回值是QuerySet,参数中写排序的字段。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from django.db.models import F,Q,Count,Max,Min</span><br></pre></td></tr></table></figure><ul><li>F对象：用于类属性之间进行比较。</li><li>Q对象：用于条件之间的逻辑关系。</li></ul><ul><li>aggregate:进行聚合操作，返回值是一个字典，进行聚合的时候，需要先导入聚合类。</li><li>count:返回结果集中数据的目的，返回值是一个数字。</li></ul><p>注意：</p><p>​    对一个QuerySet实例对象，可以据需调用上面的所有函数。</p><p>注意：</p><ol><li>通过模型类实现关联查询时，要查那个表中的数据，就需要通过那个类来查。</li><li>写关联查询条件的时候，如果类中没有关系属性，条件需要对应类的名，如果类中有关系属性，直接写关系属性。</li></ol><h2 id="9-查询集"><a href="#9-查询集" class="headerlink" title="9.查询集"></a>9.查询集</h2><p><strong>all  、 filter 、 exclude 、 order_by 调用这些函数会产生查询集，QuerySet类对象可以继续调用上限所有函数。</strong></p><ol><li>惰性查询：只有在实际使用查询集中的数据的时候才会发生对数据的真正查询。</li><li>缓存：当使用的是统计一个查询集的时候，第一次的时候就会发生实际数据库的查询，然后把结果缓存起来，之后在使用这个查询集的时候，使用的是缓存的结果。</li></ol><p><strong>限制查询集：</strong></p><p>可以对一个查询集进行去下表或者切片操作来限制查询集的结果。</p><p>对一个查询集进行切片操作会产生一个新的查询集，下表不允许为负数。</p><p>取出查询集第一条数据的两种方式：</p><table><thead><tr><th>方式</th><th>说明</th></tr></thead><tbody><tr><td>b[0]</td><td>如果  b[0] 不存在，就会抛出一个 IndexError异常。</td></tr><tr><td>b[0:1].get()</td><td>如果 b[0:1].get() 不存在，就会抛出DoesNotExist异常。</td></tr></tbody></table><p>exists:来判断一个查询集中是否有数据。 True False</p><h2 id="10-抽象基类"><a href="#10-抽象基类" class="headerlink" title="10.抽象基类"></a>10.抽象基类</h2><p><strong>抽象基类在你将一些共同信息导入到多个其他模型的时候很有用。</strong></p><p><strong>你写你的基类，并在Meta类（元类）中设置abstract=True。该模型不用于生成任何数据库表。反而，当抽象基类用于其他模型的一个基类是，它的fields（字段）会被添加到那些子类中。</strong></p><h2 id="11-url配置过程"><a href="#11-url配置过程" class="headerlink" title="11.url配置过程"></a>11.url配置过程</h2><ul><li>在项目的urls 文件中包含具体应用的urls 文件，在具体应用的urls文件中包含具体url和视图的对应关系。</li><li>url配置项是定义在一个叫 urlpatterns 的列表中，其中每一个元素就是一个配置项，每一个配置项都调用urlh函数。</li></ul><h2 id="12-属性"><a href="#12-属性" class="headerlink" title="12.属性"></a>12.属性</h2><ul><li>path ：一个字符串，表示请求的页面的完整路径，不包含域名和部分参数。</li><li>method  : 一个字符串，表示请求使用的HTTP方法，常用值包括 GET 、POST 。<ul><li>在浏览器中给出地址发请求采用get方式，如超链接。</li><li>在浏览器中点击表单的提交按钮发起请求，如果表单的method设置为post则为post请求。</li></ul></li><li>encoding : 一个字符串，表示提交的数据编码方式。<ul><li>如果为None则表示使用浏览器的默认设置，一般为utf-8.</li><li>这个属性是可写的，可以通过修改它来访问表单数据使用的编码，接下来对属性的任何访问将使用鑫的encoding值。</li></ul></li><li>GET ：QueryDict类型对象，类似与字典，包含get请求方式所有参数。</li><li>POST：QueryDict类型对象，类似于字典，包含post请求方式的所有参数。</li><li>FILES : 一个类似于字典的对象，包含所有上传文件。</li><li>COOKIES ： 一个标准的Python字典，包含所有cookie，键和值都为字符串。</li><li>session : 一个既可以读 又可以写的类似于字典的对象，表示当前的话，只当有Django 启用绘画的支持时才可使用，详情内容见 “状态保持”。</li><li>运行服务器，在浏览器中浏览首页，可以在浏览器“开发者工具”中看到下图：</li></ul><h2 id="13-cooie的特点："><a href="#13-cooie的特点：" class="headerlink" title="13.cooie的特点："></a>13.cooie的特点：</h2><ol><li><p>以键值对方式进行存储。</p></li><li><p>通过浏览器访问一个网站时，会将浏览器存储的跟网站相关的所有cookie信息发送给网站的服务器。request.COOKIES</p><p>（你去买烧饼，你去买烧饼，你只会把买少烧饼的单子给他 你肯定不会把卖豆浆的单子也起给他）</p></li><li><p>cookie 是基于域名安全的。</p></li><li><p>cookie是有过期时间的，如果不指定，默认关闭浏览器之后 cookie就会过期。</p></li></ol><h2 id="14-session的特点："><a href="#14-session的特点：" class="headerlink" title="14.session的特点："></a>14.session的特点：</h2><ol><li>session是以键值对进行存储的。</li><li>session依赖于cookie。唯一的标识码保存在sessionid cookie 中。<ul><li>问：所有请求者的session 都会存储在服务器中，服务器如何区分请求者和session的数据对应关系呢？</li><li>答：在使用session后，会在Cookie中存储一条sessionid的数据，每次请求时浏览器都会将这个数据发给服务器，服务器接收sessionid后，会根据这个值找到这个请求者的session.</li><li>结果如果想使用session，浏览器必须支持cookie，否则就无法使用session了。</li><li>存储session时，键与Cookie中的sessionid相同，值是开发人员设置的键值对信息进行了base64编码，过期时间有开发人员设置。</li></ul></li><li>session 也是有过期时间的，如果不指定，默认就会两周过期。</li></ol><h2 id="15-cookie和session的应用场景"><a href="#15-cookie和session的应用场景" class="headerlink" title="15.cookie和session的应用场景"></a>15.cookie和session的应用场景</h2><p>Cookie:</p><ul><li>记住用户名。</li><li>保存在浏览器端。</li><li>对于安全性要求不高的数据可以使用cookie进行保存。</li></ul><p>session:</p><ul><li>记住用户的登录状态</li><li>保存在服务器端</li><li>对于安全性要求比较高的，比如用户银行卡等信息使用session进行保存。</li></ul><h2 id="16-HTML转义"><a href="#16-HTML转义" class="headerlink" title="16.HTML转义"></a>16.HTML转义</h2><p>什么是HTML转义？</p><p>通过模板上下文，传递给模板文件的数据里面含有，大于小于单引号双引号和and符号的话，他在显示的时候会进行一个转义。</p><p>应用场景：</p><p>后期做项目，编辑商品详情信息的时候通常是由后台管理员进行编辑，通常我们会某个字体设置一些格式，比如加粗，加标题，这部分你内容 保存在数据库就是保存html的内容。</p><p>在模板上下文中的html标记默认是会被转义的。</p><h2 id="17-csrf攻击"><a href="#17-csrf攻击" class="headerlink" title="17.csrf攻击"></a>17.csrf攻击</h2><p>跨站伪造</p><ol><li>在进行网站开发的时候，有些页面是用户登陆之后才可以访问的，假如用户访问了这个地址，需要进行登陆的判断，如果用户登陆了话，可以进行后续的操作，如果没有登陆，跳转到登陆页面。</li></ol><h2 id="18-django防止csrf的方式："><a href="#18-django防止csrf的方式：" class="headerlink" title="18.django防止csrf的方式："></a>18.django防止csrf的方式：</h2><ol><li><p>默认打开csrf中间件。</p></li><li><p>表单post提交数据的时候加上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% csrf token %&#125;  标签</span><br></pre></td></tr></table></figure></li></ol><p># </p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django数据库关系</title>
      <link href="/2016/06/07/Django-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2016/06/07/Django-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Django数据库"><a href="#Django数据库" class="headerlink" title="Django数据库"></a>Django数据库</h1><h2 id="区分一对一，多对多"><a href="#区分一对一，多对多" class="headerlink" title="区分一对一，多对多"></a>区分一对一，多对多</h2><p><strong>一对一：子表从母表中选出一条数据一一对应，母表中选出来一条就少一条，子表不可以再选择母表中已被选择的那条数据</strong></p><p><strong>一对多：子表从母表中选出一条数据一一对应，但母表的这条数据还可以被其他子表数据选择</strong></p><p><strong>共同点是在admin中添加数据的话，都会出现一个select选框，但只能单选，因为不论一对一还是一对多，自己都是“一”</strong></p><p><strong>多对多总结：</strong></p><p>　　<strong>比如有多个孩子，和多种颜色、</strong></p><p>　　<strong>每个孩子可以喜欢多种颜色，一种颜色可以被多个孩子喜欢，对于双向均是可以有多个选择</strong></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><strong>一对一：一般用于某张表的补充，比如用户基本信息是一张表，但并非每一个用户都需要有登录的权限，不需要记录用户名和密码，此时，合理的做法就是新建一张记录登录信息的表，与用户信息进行一对一的关联，可以方便的从子表查询母表信息或反向查询</strong></p><p><strong>外键：有很多的应用场景，比如每个员工归属于一个部门，那么就可以让员工表的部门字段与部门表进行一对多关联，可以查询到一个员工归属于哪个部门，也可反向查出某一部门有哪些员工</strong></p><p><strong>多对多：如很多公司，一台服务器可能会有多种用途，归属于多个产品线当中，那么服务器与产品线之间就可以做成对多对，多对多在A表添加manytomany字段或者从B表添加，效果一致</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colors</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    colors=models.CharField(max_length=<span class="number">10</span>) <span class="comment">#蓝色</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.colors</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    color=models.OneToOneField(<span class="string">"Colors"</span>)  <span class="comment">#与颜色表为一对一，颜色表为母表</span></span><br><span class="line">    description=models.CharField(max_length=<span class="number">10</span>) <span class="comment">#描述</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.description</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clothes</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    color=models.ForeignKey(<span class="string">"Colors"</span>)   <span class="comment">#与颜色表为外键，颜色表为母表</span></span><br><span class="line">    description=models.CharField(max_length=<span class="number">10</span>) <span class="comment">#描述</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.description   </span><br><span class="line">     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name=models.CharField(max_length=<span class="number">10</span>)   <span class="comment">#姓名  </span></span><br><span class="line">    favor=models.ManyToManyField(<span class="string">'Colors'</span>)    <span class="comment">#与颜色表为多对多</span></span><br></pre></td></tr></table></figure><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><h3 id="查："><a href="#查：" class="headerlink" title="查："></a>查：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#子表查询母表,找到红球对应的颜色</span></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">print(models.Ball.objects.get(description=<span class="string">"红球"</span>).color.colors)  </span><br><span class="line"><span class="comment">#返回红，通过子表查询母表，写法："子表对象.母表表名的小写.母表字段名" ；</span></span><br><span class="line"><span class="comment">#通过Ball表查到description为"红球"，查找到对应colors</span></span><br><span class="line"><span class="comment">#写法2，反向从母表入手：</span></span><br><span class="line">print(models.Colors.objects.get(ball__description=<span class="string">"红球"</span>).colors) </span><br><span class="line"><span class="comment">#返回红，通过子表查询母表，但形式上是从母表对象自身直接获取字段，</span></span><br><span class="line"><span class="comment">#写法："母表.objects.get(子表名小写__子表字段="xxx").母表字段名" ；效果和上边完全一致，另一种形式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#母表查询子表，找到红色对应的球的名字</span></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">print(models.Colors.objects.get(colors=<span class="string">"红"</span>).ball.description)  </span><br><span class="line"><span class="comment">#返回红球，通过母表查询子表，写法："母表对象.子表表名的小写.子表字段名"；</span></span><br><span class="line"><span class="comment">#找到颜色为红色的Ball的description</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写法2，反向从子表入手：</span></span><br><span class="line">print(models.Ball.objects.get(color__colors=<span class="string">"红"</span>).description)  </span><br><span class="line"><span class="comment">#返回红球，通过母表查询子表，但形式上是从子表对象自身直接获取字段，</span></span><br><span class="line"><span class="comment">#写法："子表.objects.get(一对一的子表字段__母表字段="xxx").子表字段"；效果和上边完全一致，另一种形式</span></span><br></pre></td></tr></table></figure><h3 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加一种颜色黑，并添加黑球</span></span><br><span class="line">color_obj=models.Colors.objects.create(colors=<span class="string">"黑"</span>)  </span><br><span class="line"><span class="comment">#先在母表中创建颜色，并实例化给颜色表对象</span></span><br><span class="line"></span><br><span class="line">models.Ball.objects.create(color=color_obj,description=<span class="string">"黑球"</span>)  </span><br><span class="line"><span class="comment">#更新Ball表，color字段为颜色表对象，添加description字段</span></span><br></pre></td></tr></table></figure><p>###备注：增添数据的三种常用方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增添数据的三种写法：</span></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">color_obj=models.Colors.objects.create(colors=<span class="string">"黑"</span>)</span><br><span class="line">models.Ball.objects.create(color=color_obj,description=<span class="string">"黑球"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#写法1补充：</span></span><br><span class="line">color_id=models.Colors.objects.create(colors=<span class="string">"黑"</span>).id</span><br><span class="line">models.Ball.objects.create(color_id=color_id,description=<span class="string">"黑球"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#写法2：</span></span><br><span class="line">color_obj=models.Colors.objects.create(colors=<span class="string">"黑"</span>)</span><br><span class="line">ball_obj=models.Ball(color=color_obj,description=<span class="string">"黑球"</span>)</span><br><span class="line">ball_obj.save()</span><br><span class="line"></span><br><span class="line"><span class="comment">#写法3(字典导入)：</span></span><br><span class="line">color_obj=models.Colors.objects.create(colors=<span class="string">"黑"</span>)</span><br><span class="line">ball_dic=&#123;<span class="string">'description'</span>:<span class="string">"黑球"</span>&#125;</span><br><span class="line">models.Ball.objects.create(color=color_obj,**ball_dic)</span><br></pre></td></tr></table></figure><p>###改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">color_obj=models.Colors.objects.get(colors=<span class="string">"黑"</span>) </span><br><span class="line"><span class="comment">#.get()等同于.filter().first()</span></span><br><span class="line"></span><br><span class="line">color_obj.colors=<span class="string">"灰"</span></span><br><span class="line">color_obj.save()</span><br><span class="line"></span><br><span class="line">models.Ball.objects.filter(description=<span class="string">"黑球"</span>).update(color=color_obj,description=<span class="string">"灰球"</span>) </span><br><span class="line"><span class="comment">#update(),delete()是QuerySet的方法</span></span><br></pre></td></tr></table></figure><p>###<em>备注：修改数据的常见方式</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#更新一条数据</span></span><br><span class="line">color_obj=models.Colors.objects.get(colors=<span class="string">"黑"</span>)</span><br><span class="line">color_obj.colors=<span class="string">"灰"</span></span><br><span class="line">color_obj.save()</span><br><span class="line"><span class="comment">#更新多条数据，把满足条件的球的description都变为灰球</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">models.Ball.objects.filter(color__colors=<span class="string">"红"</span>).update(description=<span class="string">"灰球"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#写法2：</span></span><br><span class="line">up_dic=&#123;<span class="string">"description"</span>:<span class="string">"灰球"</span>&#125;</span><br><span class="line">models.Ball.objects.filter(id__gt=<span class="number">0</span>).update(**up_dic)</span><br></pre></td></tr></table></figure><h3 id="删："><a href="#删：" class="headerlink" title="删："></a>删：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">models.Ball.objects.get(description=<span class="string">"灰球"</span>).delete() </span><br><span class="line"><span class="comment">#对象和QuerySet都有方法delete()</span></span><br><span class="line">models.Colors.objects.filter(colors=<span class="string">"灰"</span>).delete()</span><br><span class="line"></span><br><span class="line">models.Colors.objects.all().delete() <span class="comment">#清空一张表</span></span><br></pre></td></tr></table></figure><p>##一对多（外键）</p><h3 id="查：-1"><a href="#查：-1" class="headerlink" title="查："></a>查：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#外键表联合查询：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#外键子表查询母表,与一对一子表查询母表形式一致</span></span><br><span class="line"><span class="comment">#找到红裤衩所属的颜色表中的颜色--返回:红</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">print(models.Clothes.objects.get(description=<span class="string">"小虎哥"</span>).color.colors)  </span><br><span class="line"><span class="comment">#返回红，通过子表查询母表，写法："子表对象.母表表名的小写.母表字段名" ；</span></span><br><span class="line"><span class="comment">#通过Clothes表查到description为"小虎哥"，查找到对应colors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写法2，反向从母表入手：</span></span><br><span class="line">print(models.Colors.objects.get(clothes__description=<span class="string">"小虎哥"</span>).colors)  </span><br><span class="line"><span class="comment">#返回红，通过子表查询母表，但形式上是从母表对象自身直接获取字段，</span></span><br><span class="line"><span class="comment">#写法："母表.objects.get(子表名小写__子表字段="xxx").母表字段名" ；效果和上边完全一致，另一种形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#外键母表查询子表,与一对一形式不同，因为母表为"多"，</span></span><br><span class="line"><span class="comment">#不能像一对一一样通过.get().子表.子表字段的方式获取，但与多对多母表查询子表一致</span></span><br><span class="line"><span class="comment">#找到颜色为红的所有服装--返回:[&lt;Clothes: 大美女&gt;, &lt;Clothes: 小虎哥&gt;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">color_obj=models.Colors.objects.get(colors=<span class="string">"红"</span>)</span><br><span class="line">print(color_obj.clothes_set.all())  </span><br><span class="line"><span class="comment">#注意：子表小写_set的写法,它实际上是一个QuerySet,可以用update,delete,all,filter等方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写法2：</span></span><br><span class="line">print(models.Clothes.objects.filter(color=models.Colors.objects.get(colors=<span class="string">"红"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#写法2简便写法（推荐）：</span></span><br><span class="line">print(models.Clothes.objects.filter(color__colors=<span class="string">"红"</span>))  </span><br><span class="line"><span class="comment">#写法：filter(子表外键字段__母表字段='过滤条件')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写法3：</span></span><br><span class="line">color_id=models.Colors.objects.get(colors=<span class="string">"红"</span>).id  </span><br><span class="line"><span class="comment">#通过母表获取到颜色为红的id</span></span><br><span class="line">print(models.Clothes.objects.filter(color_id=color_id))  </span><br><span class="line"><span class="comment">#filter得到QuerySet,写法：filter(子表外键字段_母表主键=母表主键对象)</span></span><br></pre></td></tr></table></figure><h3 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h3><p>通过QuerySet的.values()方法，将QuerySet转化为ValuesQuerySet</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">print(models.Clothes.objects.filter(color=models.Colors.objects.get(colors=<span class="string">"红"</span>)).values(<span class="string">'color__colors'</span>,<span class="string">'description'</span>))  </span><br><span class="line"><span class="comment">#获取子表的description字段，和母表的colors字段，获取母表字段写法: 子表外键字段名__母表字段名--适用于values()或filter()</span></span><br><span class="line"><span class="comment">#简写形式补充：</span></span><br><span class="line">print(models.Clothes.objects.filter(color__colors=<span class="string">"红"</span>).values(<span class="string">'color__colors'</span>,<span class="string">'description'</span>))</span><br><span class="line"><span class="comment">#返回：</span></span><br><span class="line">[&#123;<span class="string">'description'</span>: <span class="string">u'\u7ea2\u5185\u8863'</span>, <span class="string">'color__colors'</span>: <span class="string">u'\u7ea2'</span>&#125;, &#123;<span class="string">'description'</span>: <span class="string">u'\u7ea2\u5185\u88e4'</span>, <span class="string">'color__colors'</span>: <span class="string">u'\u7ea2'</span>&#125;]</span><br><span class="line"><span class="comment">#如果不加values(),返回的是[&lt;Clothes: 大美女&gt;, &lt;Clothes: 小虎哥&gt;]这样一个QuerySet集合，通过values可以形成一个列表，列表中的每一个元素是一个字典，可以通过list()将ValuesQeurySet转化为列表，之后返回给templates</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#另外可通过.values_list()将QuerySet转化为ValuesListQuerySet。返回：[(u'\u7ea2', u'\u7ea2\u889c\u5b50'), (u'\u7ea2', u'\u7ea2\u889c\u5b50')]</span></span><br><span class="line"><span class="comment">#得到的是一个列表，列表中是多个元组，每个元组是ValuesQuerySet中字典的value，常用于从models里将数据取出后动态添加到前端模板中的select选项中。</span></span><br><span class="line"><span class="comment">#通过forms.py从models取值传给前端select选项，需重启django后，select选项才能更新，可在定义form时，添加如下关键字保障动态更新select选项</span></span><br><span class="line"><span class="comment">#forms.py</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> test1 <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClothesForm</span><span class="params">(forms.Form)</span>:</span></span><br><span class="line">    color=forms.IntegerField(required=<span class="literal">True</span>,widget=forms.Select(),)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,*args,**kwargs)</span>:</span>  <span class="comment">#定义这个关键字段，当使用form时，colors表新增了颜色，前端ClothesForm的color字段的选项会自动更新</span></span><br><span class="line">        super(ClothesForm, self).__init__(*args,**kwargs)</span><br><span class="line">        self.fields[<span class="string">'color'</span>].widget.choices=models.Colors.objects.all().order_by(<span class="string">'id'</span>).values_list(<span class="string">'id'</span>,<span class="string">'colors'</span>)</span><br></pre></td></tr></table></figure><h3 id="增：-1"><a href="#增：-1" class="headerlink" title="增："></a>增：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增添子表数据，形式与一对一一致</span></span><br><span class="line"><span class="comment">#添加颜色为绿的服装：小帅哥</span></span><br><span class="line"><span class="comment">#方法1：</span></span><br><span class="line">models.Clothes.objects.create(color=models.Colors.objects.get(colors=<span class="string">"绿"</span>),description=<span class="string">"小帅哥"</span>)</span><br><span class="line"><span class="comment">#方法1补充：</span></span><br><span class="line">models.Clothes.objects.create(color_id=models.Colors.objects.get(colors=<span class="string">"绿"</span>).id,description=<span class="string">"小帅哥"</span>)</span><br><span class="line"><span class="comment">#方法2：</span></span><br><span class="line">c_obj=models.Clothes(color=models.Colors.objects.get(colors=<span class="string">"绿"</span>),description=<span class="string">"小帅哥"</span>)</span><br><span class="line">c_obj.save()</span><br><span class="line"><span class="comment">#方法3：字典方式录入..参考一对一</span></span><br></pre></td></tr></table></figure><h3 id="改："><a href="#改：" class="headerlink" title="改："></a>改：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#颜色为红的服装，description都更新为大美女</span></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">models.Clothes.objects.filter(color__colors=<span class="string">"红"</span>).update(description=<span class="string">"大美女"</span>)</span><br><span class="line"><span class="comment">#写法2：</span></span><br><span class="line">models.Clothes.objects.filter(color_id=models.Colors.objects.get(colors=<span class="string">"红"</span>).id).update(description=<span class="string">"大美女"</span>)</span><br><span class="line"><span class="comment">#写法3：</span></span><br><span class="line">colors_obj=models.Colors.objects.get(colors=<span class="string">"红"</span>)</span><br><span class="line">colors_obj.clothes_set.filter(id__gte=<span class="number">1</span>).update(description=<span class="string">"大美女"</span>)</span><br><span class="line"><span class="comment">#其他写法参照一对一的修改和外键的查询</span></span><br></pre></td></tr></table></figure><h3 id="删：-1"><a href="#删：-1" class="headerlink" title="删："></a>删：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">models.Clothes.objects.get(description=<span class="string">"灰裙子"</span>).delete() </span><br><span class="line"><span class="comment">#对象和QuerySet都有方法delete()</span></span><br><span class="line"></span><br><span class="line">models.Colors.objects.filter(colors=<span class="string">"灰"</span>).delete()</span><br></pre></td></tr></table></figure><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>###查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#多对多子表查询母表,查找小明喜欢哪些颜色--返回:[&lt;Colors: 红&gt;, &lt;Colors: 黄&gt;, &lt;Colors: 蓝&gt;]</span></span><br><span class="line"><span class="comment">#与一对多子表查询母表的形式不同，因为一对多，查询的是母表的“一”；多对多，查询的是母表的“多”</span></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">child_obj=models.Child.objects.get(name=<span class="string">"小明"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#写法：子表对象.子表多对多字段.过滤条件(all()/filter())</span></span><br><span class="line">print(child_obj.favor.all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#写法2，反向从母表入手：</span></span><br><span class="line">print(models.Colors.objects.filter(child__name=<span class="string">"小明"</span>)) </span><br><span class="line"><span class="comment">#母表对象.filter(子表表名小写__子表字段名="过滤条件")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#多对多母表查询子表,查找有哪些人喜欢黄色--返回:[&lt;Child: 小明&gt;, &lt;Child: 丫蛋&gt;]</span></span><br><span class="line"><span class="comment">#与一对多母表查询子表的形式完全一致，因为查到的都是QuerySet，一对多和多对多，都是在查询子表的“多”</span></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">color_obj=models.Colors.objects.get(colors=<span class="string">"黄"</span>)</span><br><span class="line">print(color_obj.child_set.all())</span><br><span class="line"><span class="comment">#写法2：</span></span><br><span class="line">print(models.Child.objects.filter(favor=models.Colors.objects.get(colors=<span class="string">"黄"</span>)))</span><br><span class="line"><span class="comment">#写法2简便写法(推荐):</span></span><br><span class="line">print(models.Child.objects.filter(favor__colors=<span class="string">"黄"</span>))  </span><br><span class="line"><span class="comment">#写法：filter(子表外键字段__母表字段='过滤条件')</span></span><br><span class="line"><span class="comment">#写法3：</span></span><br><span class="line">color_id=models.Colors.objects.get(colors=<span class="string">"黄"</span>).id  </span><br><span class="line"><span class="comment">#通过母表获取到颜色为红的id</span></span><br><span class="line">print(models.Child.objects.filter(favor=color_id))  </span><br><span class="line"><span class="comment">#filter得到QuerySet,写法：filter(子表外键字段=母表主键对象),此处和一对多略有不同，是子表外键字段而不是外键字段_母表主键</span></span><br></pre></td></tr></table></figure><h3 id="增与改"><a href="#增与改" class="headerlink" title="增与改"></a>增与改</h3><p>(增添子表或母表数据参照一对一的增，多对多重点在于关系表的对应关系变更)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加子表关联关系</span></span><br><span class="line"><span class="comment">#添加小虎并让他喜欢所有颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">child_obj=models.Child.objects.create(name=<span class="string">"小虎"</span>)  </span><br><span class="line"><span class="comment">#如果是已有用户，使用.get()</span></span><br><span class="line">colors_obj=models.Colors.objects.all()  </span><br><span class="line"><span class="comment">#创建颜色表的所有颜色QuerySet对象</span></span><br><span class="line">child_obj.favor.add(*colors_obj)  </span><br><span class="line"><span class="comment">#添加对应关系,将小虎和所有颜色进行关联，写法：子表对象.子表多对多字段.add(*QuerySet对象)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#写法2：</span></span><br><span class="line">child_obj=models.Child.objects.get(name=<span class="string">"小虎"</span>)</span><br><span class="line">colors_obj=models.Colors.objects.all()</span><br><span class="line">child_obj.favor=colors_obj</span><br><span class="line">child_obj.save()</span><br><span class="line"><span class="comment">#让小虎喜欢黄色和蓝色(2种写法和上边一致，只展示一种写法)</span></span><br><span class="line">child_obj=models.Child.objects.get(name=<span class="string">"小虎"</span>)</span><br><span class="line">colors_obj=models.Colors.objects.filter(colors__in=[<span class="string">"蓝"</span>,<span class="string">"黄"</span>])  </span><br><span class="line"><span class="comment">#models默认只能用这种方式得到并集，如需更复杂的过滤逻辑，需使用模块Q</span></span><br><span class="line">child_obj.favor.clear()  </span><br><span class="line"><span class="comment">#清空小虎已经喜欢的颜色</span></span><br><span class="line">child_obj.favor.add(*colors_obj)  </span><br><span class="line"><span class="comment">#add是追加模式，如果当前小虎已经喜欢绿色，那么执行后，小虎会额外喜欢蓝，黄</span></span><br><span class="line"><span class="comment">#让小虎喜欢绿色(2种写法和上边一致，只展示一种写法)</span></span><br><span class="line">child_obj=models.Child.objects.get(name=<span class="string">"小虎"</span>)</span><br><span class="line">colors_obj=models.Colors.objects.get(colors=<span class="string">"绿"</span>)</span><br><span class="line">child_obj.favor.clear()</span><br><span class="line">child_obj.favor.add(colors_obj)  <span class="comment">#此处没有*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加母表关联关系</span></span><br><span class="line"><span class="comment">#让喜欢蓝色的人里添加小虎,可以用上边的方法，一个效果，让小虎喜欢蓝色，下边介绍反向插入(从母表入手)的写法</span></span><br><span class="line">child_obj=models.Child.objects.get(name=<span class="string">"小虎"</span>)</span><br><span class="line">colors_obj=models.Colors.objects.get(colors=<span class="string">"蓝"</span>)</span><br><span class="line">colors_obj.child_set.add(child_obj)  <span class="comment">#从colors表插入小虎，写法：母表对象.子表名小写_set.add(子表对象)。 让喜欢蓝色的child_set集合添加name="小虎"</span></span><br><span class="line"><span class="comment">#让所有人都喜欢蓝色</span></span><br><span class="line">children_obj=models.Child.objects.all()</span><br><span class="line">colors_obj=models.Colors.objects.get(colors=<span class="string">"蓝"</span>)</span><br><span class="line">colors_obj.child_set.add(*children_obj)</span><br><span class="line"><span class="comment">#关于_set写法，是否已经有些晕了，究竟什么时候使用_set,简单记忆，只有子表才有"子表名小写_set"的写法，得到的是一个QuerySet集合，后边可以接.add(),.remove(),.update(),.delete(),.clear()</span></span><br><span class="line"><span class="comment">#另外备注一下，colors_obj.child_set.clear()是让所有人喜欢的颜色里去掉蓝色，colors_obj.child_set.all().delete()是删除.child_set的所有人</span></span><br></pre></td></tr></table></figure><h3 id="删：删除多对多关系"><a href="#删：删除多对多关系" class="headerlink" title="删：删除多对多关系:"></a>删：删除多对多关系:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除子表与母表关联关系</span></span><br><span class="line"><span class="comment">#让小虎不喜欢任何颜色</span></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">child_obj=models.Child.objects.get(name=<span class="string">"小虎"</span>)</span><br><span class="line">colors_obj=models.Colors.objects.all()</span><br><span class="line">child_obj.favor=<span class="string">''</span></span><br><span class="line">child_obj.save()</span><br><span class="line"><span class="comment">#写法2：</span></span><br><span class="line">child_obj=models.Child.objects.get(name=<span class="string">"小虎"</span>)</span><br><span class="line">colors_obj=models.Colors.objects.all()</span><br><span class="line">child_obj.favor.remove(*colors_obj)</span><br><span class="line"><span class="comment">#写法3：</span></span><br><span class="line">child_obj=models.Child.objects.get(name=<span class="string">"小虎"</span>)</span><br><span class="line">child_obj.favor.clear()</span><br><span class="line"><span class="comment">#其他例子参照多对多的增与改案例，这里不做举例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除母表与子表关联关系</span></span><br><span class="line"><span class="comment">#让所有人不再喜欢蓝色</span></span><br><span class="line"><span class="comment">#写法1：</span></span><br><span class="line">children_obj=models.Child.objects.all()</span><br><span class="line">colors_obj=models.Colors.objects.get(colors=<span class="string">"蓝"</span>)</span><br><span class="line">colors_obj.child_set.remove(*children_obj)</span><br><span class="line"><span class="comment">#写法2：</span></span><br><span class="line">colors_obj=models.Colors.objects.get(colors=<span class="string">"蓝"</span>)</span><br><span class="line">colors_obj.child_set.clear()</span><br></pre></td></tr></table></figure><h3 id="删多对多表数据："><a href="#删多对多表数据：" class="headerlink" title="删多对多表数据："></a>删多对多表数据：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除子表数据</span></span><br><span class="line"><span class="comment">#喜欢蓝色的所有人都删掉</span></span><br><span class="line">colors_obj=models.Colors.objects.get(colors=<span class="string">"蓝"</span>)</span><br><span class="line">colors_obj.child_set.all().delete()  <span class="comment">#注意有.all()</span></span><br><span class="line"><span class="comment">#删除所有child</span></span><br><span class="line">models.Child.objects.all().delete()</span><br></pre></td></tr></table></figure><h3 id="删除母表数据："><a href="#删除母表数据：" class="headerlink" title="删除母表数据："></a>删除母表数据：</h3><p>默认情况下，比如列中，删除’红‘色，那么子表与颜色表是一对一或者外键关系的数据会自动删除，比如红球，小虎哥，</p><p>与颜色表是多对多关系的话，不会自动删除喜欢红色的人，热水去掉红色已选</p><p>如果想让与母表外键关联的子表在删除外键之后依旧可以保留子表的数据，需要子表建表时加入以下字段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clothes</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    color=models.ForeignKey(<span class="string">"Colors"</span>,null=<span class="literal">True</span>,on_delete=models.SET_NULL))  </span><br><span class="line">    <span class="comment">#可为空，如果外键被删后，子表数据此字段置空而不是直接删除这条数据，同理也可以SET_DEFAULT,需要此字段有默认值</span></span><br><span class="line">    description=models.CharField(max_length=<span class="number">10</span>)  </span><br><span class="line">    <span class="comment">#描述</span></span><br></pre></td></tr></table></figure><h3 id="choice"><a href="#choice" class="headerlink" title="choice"></a>choice</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#choices相当于实现一个简化版的外键，外键的选项不能动态更新，如可选项目较少，可以采用</span></span><br><span class="line"><span class="comment">#先在models添加choices字段</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    sex_choice=((<span class="number">0</span>,<span class="string">"男"</span>),(<span class="number">1</span>,<span class="string">"女"</span>))</span><br><span class="line">    name=models.CharField(max_length=<span class="number">10</span>)  <span class="comment">#姓名</span></span><br><span class="line">    favor=models.ManyToManyField(<span class="string">'Colors'</span>)    <span class="comment">#与颜色表为多对多</span></span><br><span class="line">    sex=models.IntegerField(choices=sex_choice,default=<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__unicode__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="comment">#在views.py中调用</span></span><br><span class="line">child_obj=models.Child.objects.get(name=<span class="string">"小虎"</span>)</span><br><span class="line">print(child_obj.sex)  <span class="comment">#返回0或1</span></span><br><span class="line">print(child_obj.get_sex_display())  <span class="comment">#返回男或女</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端框架框架 </tag>
            
            <tag> python </tag>
            
            <tag> 重量级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme主题介绍</title>
      <link href="/2015/05/05/%E4%B8%BB%E9%A2%98%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87/"/>
      <url>/2015/05/05/%E4%B8%BB%E9%A2%98%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95-%E4%B8%AD%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-matery"><a href="#hexo-theme-matery" class="headerlink" title="hexo-theme-matery"></a>hexo-theme-matery</h1><p><a href="http://hits.dwyl.io/blinkfox/hexo-theme-matery" target="_blank" rel="noopener"><img src="http://hits.dwyl.io/blinkfox/hexo-theme-matery.svg" alt="HitCount"></a> <a href="https://gitter.im/hexo-theme-matery/Lobby?utm_source=badge" target="_blank" rel="noopener"><img src="https://img.shields.io/gitter/room/blinkfox/hexo-theme-matery.svg" alt="Gitter"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/issues" target="_blank" rel="noopener"><img src="https://img.shields.io/github/issues/blinkfox/hexo-theme-matery.svg" alt="GitHub issues"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/github/license/blinkfox/hexo-theme-matery.svg" alt="GitHub license"></a> <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/downloads-master-green.svg" alt="Download"></a> <a href="http://hexo.io" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/hexo-%3E%3D%203.0-blue.svg" alt="Hexo Version"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/network" target="_blank" rel="noopener"><img src="https://img.shields.io/github/forks/blinkfox/hexo-theme-matery.svg" alt="GitHub forks"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/blinkfox/hexo-theme-matery.svg" alt="GitHub stars"></a></p><p><a href="README.md">English Document</a> | <a href="https://blinkfox.github.io/" target="_blank" rel="noopener">演示示例</a> | QQ 交流群: <code>926552981</code></p><blockquote><p>这是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题。</p></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>简单漂亮，文章内容美观易读</li><li><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>每天动态切换 <code>Banner</code> 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 <code>MathJax</code></li><li><code>TOC</code> 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li><li>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> 博客了。如果还没有的话，不妨使用 Hexo 和 <a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">Markdown</a> 来写博客和文章。</p><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p><p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>Git clone</code> 命令来下载:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/blinkfox/hexo-theme-matery.git</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">"categories"</span></span><br></pre></td></tr></table></figure><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-09</span><span class="bullet">-30</span> <span class="number">17</span><span class="string">:25:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"categories"</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">"categories"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">"tags"</span></span><br></pre></td></tr></table></figure><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-09</span><span class="bullet">-30</span> <span class="number">18</span><span class="string">:23:38</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">"about"</span></span><br></pre></td></tr></table></figure><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-09</span><span class="bullet">-30</span> <span class="number">17</span><span class="string">:25:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"about"</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">"about"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情连接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page <span class="string">"friends"</span></span><br></pre></td></tr></table></figure><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">friends</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-12</span><span class="bullet">-12</span> <span class="number">21</span><span class="string">:25:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"friends"</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">"friends"</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">"avatar"</span>: <span class="string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"码酱"</span>,</span><br><span class="line">    <span class="attr">"introduction"</span>: <span class="string">"我不是大佬，只是在追寻大佬的脚步"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"http://luokangyuan.com/"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"前去学习"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">"avatar"</span>: <span class="string">"http://image.luokangyuan.com/4027734.jpeg"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"闪烁之狐"</span>,</span><br><span class="line">    <span class="attr">"introduction"</span>: <span class="string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"https://blinkfox.github.io/"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"前去学习"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">"avatar"</span>: <span class="string">"http://image.luokangyuan.com/avatar.jpg"</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"ja_rome"</span>,</span><br><span class="line">    <span class="attr">"introduction"</span>: <span class="string">"平凡的脚步也可以走出伟大的行程"</span>,</span><br><span class="line">    <span class="attr">"url"</span>: <span class="string">"ttps://me.csdn.net/jlh912008548"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"前去学习"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S hexo-prism-plugin</span><br></pre></td></tr></table></figure><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">prism_plugin:</span></span><br><span class="line"><span class="attr">  mode:</span> <span class="string">'preprocess'</span>    <span class="comment"># realtime/preprocess</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">'tomorrow'</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">false</span>    <span class="comment"># default false</span></span><br><span class="line"><span class="attr">  custom_css:</span></span><br></pre></td></tr></table></figure><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure><h3 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-permalink-pinyin --save</span><br></pre></td></tr></table></figure><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink_pinyin:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  separator:</span> <span class="string">'-'</span> <span class="comment"># default: '-'</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wordCount:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span> <span class="comment"># 将这个值设置为 true 即可.</span></span><br><span class="line"><span class="attr">  postWordCount:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  min2read:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  totalCount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">atom</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">atom.xml</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">  hub:</span></span><br><span class="line"><span class="attr">  content:</span></span><br><span class="line"><span class="attr">  content_limit:</span> <span class="number">140</span></span><br><span class="line"><span class="attr">  content_limit_delim:</span> <span class="string">' '</span></span><br><span class="line"><span class="attr">  order_by:</span> <span class="bullet">-date</span></span><br></pre></td></tr></table></figure><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/blinkfox"</span> <span class="attr">class</span>=<span class="string">"tooltipped"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">data-tooltip</span>=<span class="string">"访问我的GitHub"</span> <span class="attr">data-position</span>=<span class="string">"top"</span> <span class="attr">data-delay</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-github"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons" target="_blank" rel="noopener">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fa-facebook</code></li><li>Twitter: <code>fa-twitter</code></li><li>Google-plus: <code>fa-google-plus</code></li><li>Linkedin: <code>fa-linkedin</code></li><li>Tumblr: <code>fa-tumblr</code></li><li>Medium: <code>fa-medium</code></li><li>Slack: <code>fa-slack</code></li><li>新浪微博: <code>fa-weibo</code></li><li>微信: <code>fa-wechat</code></li><li>QQ: <code>fa-qq</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>4.7.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。</p><p>首先，在你的博客 <code>source</code> 目录下的 <code>_data</code> 目录（没有的话就新建一个）中新建 <code>musics.json</code> 文件，文件内容如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"五月雨变奏电音"</span>,</span><br><span class="line"><span class="attr">"artist"</span>: <span class="string">"AnimeVibe"</span>,</span><br><span class="line"><span class="attr">"url"</span>: <span class="string">"http://xxx.com/music1.mp3"</span>,</span><br><span class="line"><span class="attr">"cover"</span>: <span class="string">"http://xxx.com/music-cover1.png"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"Take me hand"</span>,</span><br><span class="line"><span class="attr">"artist"</span>: <span class="string">"DAISHI DANCE,Cecile Corbel"</span>,</span><br><span class="line"><span class="attr">"url"</span>: <span class="string">"/medias/music/music2.mp3"</span>,</span><br><span class="line"><span class="attr">"cover"</span>: <span class="string">"/medias/music/cover2.png"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"Shape of You"</span>,</span><br><span class="line"><span class="attr">"artist"</span>: <span class="string">"J.Fla"</span>,</span><br><span class="line"><span class="attr">"url"</span>: <span class="string">"http://xxx.com/music3.mp3"</span>,</span><br><span class="line"><span class="attr">"cover"</span>: <span class="string">"http://xxx.com/music-cover3.png"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：以上 JSON 中的属性：<code>name</code>、<code>artist</code>、<code>url</code>、<code>cover</code> 分别表示音乐的名称、作者、音乐文件地址、音乐封面。</p></blockquote><p>然后，在主题的 <code>_config.yml</code> 配置文件中激活配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 是否在首页显示音乐.</span></span><br><span class="line"><span class="attr">music:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  showTitle:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  title:</span> <span class="string">听听音乐</span></span><br><span class="line"><span class="attr">  fixed:</span> <span class="literal">false</span> <span class="comment"># 是否开启吸底模式</span></span><br><span class="line"><span class="attr">  autoplay:</span> <span class="literal">false</span> <span class="comment"># 是否自动播放</span></span><br><span class="line"><span class="attr">  theme:</span> <span class="string">'#42b983'</span></span><br><span class="line"><span class="attr">  loop:</span> <span class="string">'all'</span> <span class="comment"># 音频循环播放, 可选值: 'all', 'one', 'none'</span></span><br><span class="line"><span class="attr">  order:</span> <span class="string">'list'</span> <span class="comment"># 音频循环顺序, 可选值: 'list', 'random'</span></span><br><span class="line"><span class="attr">  preload:</span> <span class="string">'auto'</span> <span class="comment"># 预加载，可选值: 'none', 'metadata', 'auto'</span></span><br><span class="line"><span class="attr">  volume:</span> <span class="number">0.7</span> <span class="comment"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span></span><br><span class="line"><span class="attr">  listFolded:</span> <span class="literal">false</span> <span class="comment"># 列表默认折叠</span></span><br><span class="line"><span class="attr">  listMaxHeight:</span> <span class="comment"># 列表最大高度</span></span><br></pre></td></tr></table></figure><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">typora-vue-theme主题介绍</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-09</span><span class="bullet">-07</span> <span class="number">09</span><span class="string">:25:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">typora-vue-theme主题介绍</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-09</span><span class="bullet">-07</span> <span class="number">09</span><span class="string">:25:00</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">赵奇</span></span><br><span class="line"><span class="attr">img:</span> <span class="string">/source/images/xxx.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">8</span><span class="string">d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">summary:</span> <span class="string">这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Markdown</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Typora</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Markdown</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p><p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p><p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p><p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span></span><br><span class="line"><span class="selector-class">.bg-color</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, #4cbf30 0%, #0f9d58 100%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 和背景颜色相同的文字颜色，目前仅在首页一个地方使用到，你也可以将此样式应用到其他地方. */</span></span><br><span class="line"><span class="selector-class">.text-color</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#0f9d58</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> rainbow &#123;</span><br><span class="line">   <span class="comment">/* 动态切换背景颜色. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> rainbow &#123;</span><br><span class="line">    <span class="comment">/* 动态切换背景颜色. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'.bg-cover'</span>).css(<span class="string">'background-image'</span>, <span class="string">'url(/medias/banner/'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getDay() + <span class="string">'.jpg)'</span>);</span><br></pre></td></tr></table></figure><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p><h2 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h2><ul><li>v1.0.0<ul><li>新增了所有基础功能；</li></ul></li><li>v1.0.1<ul><li>调整 <code>css</code>、<code>js</code> 的文件请求路径在主题的<code>_config.yml</code>中配置，便于你更快捷的配置自己的 CDN；</li><li>新增代码是否折行为可配置，默认为折行；</li><li>默认激活 <code>TOC</code> 功能，并新增为某篇文章关闭 <code>TOC</code> 的 <code>Front-matter</code> 配置选项；</li><li>修复文章滚动时，高亮的目录选项不准确的问题；</li><li><code>IOS</code>下移除搜索框自动获得焦点属性，防止自动获得焦点后导致视图上移；</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
